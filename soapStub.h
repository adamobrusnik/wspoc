/* soapStub.h
   Generated by gSOAP 2.8.7 from test.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"urn:poc"
#define SOAP_NAMESPACE_OF_ns2	"urn:poc"
#include "stdsoap2.h"
#if GSOAP_H_VERSION != 20807
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns2__DataDescriptionType
#define SOAP_TYPE_ns2__DataDescriptionType (149)
/* ns2:DataDescriptionType */
enum ns2__DataDescriptionType {ns2__DataDescriptionType__crossSection = 0, ns2__DataDescriptionType__collisionStrength = 1, ns2__DataDescriptionType__rateCoefficient = 2, ns2__DataDescriptionType__probability = 3, ns2__DataDescriptionType__effectiveCollisionStrength = 4, ns2__DataDescriptionType__sputteringYield = 5, ns2__DataDescriptionType__sputteredEnergyCoefficient = 6, ns2__DataDescriptionType__particleReflectionCoefficient = 7, ns2__DataDescriptionType__energyReflectionCoefficient = 8, ns2__DataDescriptionType__meanPenetrationDepth = 9};
#endif

#ifndef SOAP_TYPE_ns2__ReferenceFrameType
#define SOAP_TYPE_ns2__ReferenceFrameType (150)
/* ns2:ReferenceFrameType */
enum ns2__ReferenceFrameType {ns2__ReferenceFrameType__CenterOfMass = 0, ns2__ReferenceFrameType__LaboratoryFrame = 1, ns2__ReferenceFrameType__TargetFrame = 2};
#endif

#ifndef SOAP_TYPE_ns2__ParityType
#define SOAP_TYPE_ns2__ParityType (155)
/* ns2:ParityType */
enum ns2__ParityType {ns2__ParityType__even = 0, ns2__ParityType__odd = 1, ns2__ParityType__undefined = 2};
#endif

#ifndef SOAP_TYPE_ns2__MixingClassType
#define SOAP_TYPE_ns2__MixingClassType (156)
/* ns2:MixingClassType */
enum ns2__MixingClassType {ns2__MixingClassType__squared = 0, ns2__MixingClassType__signed_ = 1};
#endif

#ifndef SOAP_TYPE_ns2__CategoryType
#define SOAP_TYPE_ns2__CategoryType (159)
/* ns2:CategoryType */
enum ns2__CategoryType {ns2__CategoryType__book = 0, ns2__CategoryType__database = 1, ns2__CategoryType__journal = 2, ns2__CategoryType__preprint = 3, ns2__CategoryType__private_x0020communication = 4, ns2__CategoryType__proceedings = 5, ns2__CategoryType__report = 6, ns2__CategoryType__theses = 7};
#endif

#ifndef SOAP_TYPE_ns2__MethodCategoryType
#define SOAP_TYPE_ns2__MethodCategoryType (160)
/* ns2:MethodCategoryType */
enum ns2__MethodCategoryType {ns2__MethodCategoryType__experiment = 0, ns2__MethodCategoryType__theory = 1, ns2__MethodCategoryType__recommended = 2, ns2__MethodCategoryType__evaluated = 3, ns2__MethodCategoryType__empirical = 4, ns2__MethodCategoryType__scalingLaw = 5, ns2__MethodCategoryType__semiempirical = 6, ns2__MethodCategoryType__compilation = 7, ns2__MethodCategoryType__derived = 8, ns2__MethodCategoryType__observed = 9};
#endif

#ifndef SOAP_TYPE_ns2__C2SymmetryType
#define SOAP_TYPE_ns2__C2SymmetryType (161)
/* ns2:C2SymmetryType */
enum ns2__C2SymmetryType {ns2__C2SymmetryType___x002b = 0, ns2__C2SymmetryType___x002d = 1};
#endif

#ifndef SOAP_TYPE_ns2__CouplingListType
#define SOAP_TYPE_ns2__CouplingListType (162)
/* ns2:CouplingListType */
enum ns2__CouplingListType {ns2__CouplingListType__bBetaOther = 0, ns2__CouplingListType__bBetaJ = 1, ns2__CouplingListType__bBetaS = 2, ns2__CouplingListType__bBetaN = 3};
#endif

#ifndef SOAP_TYPE_ns2__EfSymmetryType
#define SOAP_TYPE_ns2__EfSymmetryType (163)
/* ns2:EfSymmetryType */
enum ns2__EfSymmetryType {ns2__EfSymmetryType__e = 0, ns2__EfSymmetryType__f = 1};
#endif

#ifndef SOAP_TYPE_ns2__ModesListType
#define SOAP_TYPE_ns2__ModesListType (164)
/* ns2:ModesListType */
enum ns2__ModesListType {ns2__ModesListType__normalMode = 0, ns2__ModesListType__stretchingMode = 1, ns2__ModesListType__bendingMode = 2, ns2__ModesListType__torsionalMode = 3, ns2__ModesListType__localMode = 4, ns2__ModesListType__inversionMode = 5};
#endif

#ifndef SOAP_TYPE_ns2__PermutationSymmetryType
#define SOAP_TYPE_ns2__PermutationSymmetryType (165)
/* ns2:PermutationSymmetryType */
enum ns2__PermutationSymmetryType {ns2__PermutationSymmetryType__a = 0, ns2__PermutationSymmetryType__s = 1};
#endif

#ifndef SOAP_TYPE_ns2__ParticleNameType
#define SOAP_TYPE_ns2__ParticleNameType (166)
/* ns2:ParticleNameType */
enum ns2__ParticleNameType {ns2__ParticleNameType__photon = 0, ns2__ParticleNameType__electron = 1, ns2__ParticleNameType__muon = 2, ns2__ParticleNameType__positron = 3};
#endif

#ifndef SOAP_TYPE_ns2__IAEACodeType
#define SOAP_TYPE_ns2__IAEACodeType (168)
/* ns2:IAEACodeType */
enum ns2__IAEACodeType {ns2__IAEACodeType__EGN = 0, ns2__IAEACodeType__EAS = 1, ns2__IAEACodeType__EBS = 2, ns2__IAEACodeType__EDX = 3, ns2__IAEACodeType__EEL = 4, ns2__IAEACodeType__ELB = 5, ns2__IAEACodeType__ETS = 6, ns2__IAEACodeType__EDT = 7, ns2__IAEACodeType__EFL = 8, ns2__IAEACodeType__EEX = 9, ns2__IAEACodeType__EIN = 10, ns2__IAEACodeType__EMI = 11, ns2__IAEACodeType__ENI = 12, ns2__IAEACodeType__EMT = 13, ns2__IAEACodeType__EUP = 14, ns2__IAEACodeType__EDP = 15, ns2__IAEACodeType__EIP = 16, ns2__IAEACodeType__ERC = 17, ns2__IAEACodeType__ERR = 18, ns2__IAEACodeType__ERD = 19, ns2__IAEACodeType__ERT = 20, ns2__IAEACodeType__ERO = 21, ns2__IAEACodeType__EDC = 22, ns2__IAEACodeType__EDS = 23, ns2__IAEACodeType__EDR = 24, ns2__IAEACodeType__EDA = 25, ns2__IAEACodeType__EDE = 26, ns2__IAEACodeType__EDI = 27, ns2__IAEACodeType__PGN = 28, ns2__IAEACodeType__PTS = 29, ns2__IAEACodeType__PDS = 30, ns2__IAEACodeType__PES = 31, ns2__IAEACodeType__PMA = 32, ns2__IAEACodeType__PDT = 33, ns2__IAEACodeType__PFL = 34, ns2__IAEACodeType__PEX = 35, ns2__IAEACodeType__PIN = 36, ns2__IAEACodeType__PFF = 37, ns2__IAEACodeType__PEA = 38, ns2__IAEACodeType__PTA = 39, ns2__IAEACodeType__PAD = 40, ns2__IAEACodeType__PED = 41, ns2__IAEACodeType__PNL = 42, ns2__IAEACodeType__PZE = 43, ns2__IAEACodeType__PSE = 44, ns2__IAEACodeType__PGF = 45, ns2__IAEACodeType__PTF = 46, ns2__IAEACodeType__HGN = 47, ns2__IAEACodeType__HAS = 48, ns2__IAEACodeType__HLB = 49, ns2__IAEACodeType__HDS = 50, ns2__IAEACodeType__HDX = 51, ns2__IAEACodeType__HES = 52, ns2__IAEACodeType__HCX = 53, ns2__IAEACodeType__HUP = 54, ns2__IAEACodeType__HIR = 55, ns2__IAEACodeType__HEL = 56, ns2__IAEACodeType__HET = 57, ns2__IAEACodeType__HIP = 58, ns2__IAEACodeType__HRC = 59, ns2__IAEACodeType__HTS = 60, ns2__IAEACodeType__HDT = 61, ns2__IAEACodeType__HFL = 62, ns2__IAEACodeType__HEX = 63, ns2__IAEACodeType__HIN = 64, ns2__IAEACodeType__HPN = 65, ns2__IAEACodeType__HST = 66, ns2__IAEACodeType__HAT = 67, ns2__IAEACodeType__HAI = 68, ns2__IAEACodeType__HDI = 69, ns2__IAEACodeType__HDC = 70, ns2__IAEACodeType__HMN = 71};
#endif

#ifndef SOAP_TYPE_ns2__CodeType
#define SOAP_TYPE_ns2__CodeType (169)
/* ns2:CodeType */
enum ns2__CodeType {ns2__CodeType__phem = 0, ns2__CodeType__phab = 1, ns2__CodeType__phsc = 2, ns2__CodeType__elas = 3, ns2__CodeType__inel = 4, ns2__CodeType__exci = 5, ns2__CodeType__dexc = 6, ns2__CodeType__ioni = 7, ns2__CodeType__tran = 8, ns2__CodeType__exch = 9, ns2__CodeType__reco = 10, ns2__CodeType__elat = 11, ns2__CodeType__eldt = 12, ns2__CodeType__asso = 13, ns2__CodeType__diss = 14, ns2__CodeType__intr = 15, ns2__CodeType__chem = 16, ns2__CodeType__sure = 17, ns2__CodeType__suem = 18, ns2__CodeType__sudp = 19, ns2__CodeType__such = 20, ns2__CodeType__sope = 21, ns2__CodeType___x0000 = 22};
#endif

#ifndef SOAP_TYPE__ns2__units
#define SOAP_TYPE__ns2__units (173)
/* ns2:units */
enum _ns2__units {_ns2__units__undef = 0, _ns2__units__eV_x002famu = 1, _ns2__units__keV_x002famu = 2, _ns2__units__MeV_x002famu = 3, _ns2__units__eV = 4, _ns2__units__keV = 5, _ns2__units__MeV = 6, _ns2__units__au = 7, _ns2__units__1_x002fcm = 8, _ns2__units__J = 9, _ns2__units__Ry = 10, _ns2__units__unitless = 11, _ns2__units__kJ_x002fmol = 12, _ns2__units__kcal_x002fmol = 13, _ns2__units__K = 14, _ns2__units__Hz = 15, _ns2__units__kHz = 16, _ns2__units__MHz = 17, _ns2__units__m = 18, _ns2__units__cm = 19, _ns2__units__A = 20, _ns2__units__nm = 21, _ns2__units__deg = 22, _ns2__units__rad = 23, _ns2__units__srad = 24, _ns2__units__s = 25, _ns2__units__m3_x002fs = 26, _ns2__units__cm3_x002fs = 27, _ns2__units__cm6_x002fs = 28, _ns2__units__m2 = 29, _ns2__units__cm2 = 30, _ns2__units__b = 31, _ns2__units__Mb = 32, _ns2__units__1_x002fs = 33, _ns2__units__C_x002em = 34, _ns2__units__J_x002fT = 35, _ns2__units__C_x002em2 = 36, _ns2__units__m_x002fs = 37, _ns2__units__cm_x002fs = 38, _ns2__units__C = 39, _ns2__units__electron = 40, _ns2__units__g = 41, _ns2__units__amu = 42, _ns2__units__kg = 43, _ns2__units__1_x002fm2_x002fs = 44, _ns2__units__1_x002fcm2_x002fs = 45, _ns2__units__J_x002fm2_x002fs = 46, _ns2__units__J_x002fcm2_x002fs = 47, _ns2__units__1_x002fm2 = 48, _ns2__units__1_x002fcm2 = 49, _ns2__units__J_x002fm2 = 50, _ns2__units__J_x002fcm2 = 51, _ns2__units__W_x002fm2 = 52, _ns2__units__W_x002fcm2 = 53, _ns2__units__W = 54};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns2__PrimaryType
#define SOAP_TYPE_ns2__PrimaryType (20)
/* ns2:PrimaryType */
class SOAP_CMAC ns2__PrimaryType
{
public:
	std::string *Comments;	/* optional element of type xsd:string */
	std::string *ns2__sourceRef;	/* optional attribute */
	std::string *ns2__methodRef;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns2__PrimaryType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PrimaryType() { ns2__PrimaryType::soap_default(NULL); }
	virtual ~ns2__PrimaryType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ChemicalElementType
#define SOAP_TYPE_ns2__ChemicalElementType (21)
/* ns2:ChemicalElementType */
class SOAP_CMAC ns2__ChemicalElementType
{
public:
	std::string NuclearCharge;	/* required element of type xsd:positiveInteger */
	std::string *ElementSymbol;	/* optional element of type ns2:ElementSymbolType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns2__ChemicalElementType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ChemicalElementType() { ns2__ChemicalElementType::soap_default(NULL); }
	virtual ~ns2__ChemicalElementType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DataSetsType
#define SOAP_TYPE_ns2__DataSetsType (24)
/* ns2:DataSetsType */
class SOAP_CMAC ns2__DataSetsType
{
public:
	std::vector<class ns2__DataSetType * >DataSet;	/* required element of type ns2:DataSetType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns2__DataSetsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DataSetsType() { ns2__DataSetsType::soap_default(NULL); }
	virtual ~ns2__DataSetsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DataTableType
#define SOAP_TYPE_ns2__DataTableType (25)
/* ns2:DataTableType */
class SOAP_CMAC ns2__DataTableType
{
public:
	std::string DataList;	/* required element of type ns2:DataListType */
	std::string *Error;	/* optional element of type ns2:DataListType */
	std::string *NegativeError;	/* optional element of type ns2:DataListType */
	std::string *PositiveError;	/* optional element of type ns2:DataListType */
	char *DataDescription;	/* optional element of type xsd:anyType */
	enum _ns2__units ns2__units;	/* required attribute */
	std::string *parameter;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns2__DataTableType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DataTableType() { ns2__DataTableType::soap_default(NULL); }
	virtual ~ns2__DataTableType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DataXYType
#define SOAP_TYPE_ns2__DataXYType (26)
/* ns2:DataXYType */
class SOAP_CMAC ns2__DataXYType
{
public:
	std::vector<ns2__DataTableType * >X;	/* required element of type ns2:DataTableType */
	ns2__DataTableType *Y;	/* required element of type ns2:DataTableType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns2__DataXYType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DataXYType() { ns2__DataXYType::soap_default(NULL); }
	virtual ~ns2__DataXYType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FitParametersType
#define SOAP_TYPE_ns2__FitParametersType (29)
/* ns2:FitParametersType */
class SOAP_CMAC ns2__FitParametersType
{
public:
	std::vector<double >Parameter;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns2__FitParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FitParametersType() { ns2__FitParametersType::soap_default(NULL); }
	virtual ~ns2__FitParametersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FitValidityLimitsType
#define SOAP_TYPE_ns2__FitValidityLimitsType (30)
/* ns2:FitValidityLimitsType */
class SOAP_CMAC ns2__FitValidityLimitsType
{
public:
	double *LowerLimit;	/* optional element of type xsd:double */
	double *UpperLimit;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns2__FitValidityLimitsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FitValidityLimitsType() { ns2__FitValidityLimitsType::soap_default(NULL); }
	virtual ~ns2__FitValidityLimitsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArgumentsType
#define SOAP_TYPE_ns2__ArgumentsType (32)
/* ns2:ArgumentsType */
class SOAP_CMAC ns2__ArgumentsType
{
public:
	std::vector<class ns2__ArgumentType * >Argument;	/* required element of type ns2:ArgumentType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns2__ArgumentsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArgumentsType() { ns2__ArgumentsType::soap_default(NULL); }
	virtual ~ns2__ArgumentsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArgumentType
#define SOAP_TYPE_ns2__ArgumentType (33)
/* ns2:ArgumentType */
class SOAP_CMAC ns2__ArgumentType
{
public:
	char *Name;	/* required element of type xsd:anyType */
	char *Description;	/* optional element of type xsd:anyType */
	enum _ns2__units ns2__units;	/* required attribute */
	std::string parameter;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns2__ArgumentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArgumentType() { ns2__ArgumentType::soap_default(NULL); }
	virtual ~ns2__ArgumentType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ParametersType
#define SOAP_TYPE_ns2__ParametersType (34)
/* ns2:ParametersType */
class SOAP_CMAC ns2__ParametersType
{
public:
	std::vector<class ns2__ParameterType * >Parameter;	/* required element of type ns2:ParameterType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns2__ParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ParametersType() { ns2__ParametersType::soap_default(NULL); }
	virtual ~ns2__ParametersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ParameterType
#define SOAP_TYPE_ns2__ParameterType (35)
/* ns2:ParameterType */
class SOAP_CMAC ns2__ParameterType
{
public:
	std::string Name;	/* required element of type xsd:token */
	std::string *Description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns2__ParameterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ParameterType() { ns2__ParameterType::soap_default(NULL); }
	virtual ~ns2__ParameterType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__jjCouplingType
#define SOAP_TYPE_ns2__jjCouplingType (37)
/* ns2:jjCouplingType */
class SOAP_CMAC ns2__jjCouplingType
{
public:
	std::vector<std::string >j;	/* required element of type ns2:AngularMomentumType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns2__jjCouplingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__jjCouplingType() { ns2__jjCouplingType::soap_default(NULL); }
	virtual ~ns2__jjCouplingType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__jKCouplingType
#define SOAP_TYPE_ns2__jKCouplingType (38)
/* ns2:jKCouplingType */
class SOAP_CMAC ns2__jKCouplingType
{
public:
	std::string *j;	/* optional element of type ns2:AngularMomentumType */
	std::string *S2;	/* optional element of type ns2:AngularMomentumType */
	std::string K;	/* required element of type ns2:AngularMomentumType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns2__jKCouplingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__jKCouplingType() { ns2__jKCouplingType::soap_default(NULL); }
	virtual ~ns2__jKCouplingType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LKCouplingType
#define SOAP_TYPE_ns2__LKCouplingType (39)
/* ns2:LKCouplingType */
class SOAP_CMAC ns2__LKCouplingType
{
public:
	class ns2__OrbitalAngularMomentumType *L;	/* required element of type ns2:OrbitalAngularMomentumType */
	std::string K;	/* required element of type ns2:AngularMomentumType */
	std::string *S2;	/* optional element of type ns2:AngularMomentumType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns2__LKCouplingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LKCouplingType() { ns2__LKCouplingType::soap_default(NULL); }
	virtual ~ns2__LKCouplingType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__LSCouplingType_Seniority
#define SOAP_TYPE__ns2__LSCouplingType_Seniority (199)
/* Primitive ns2:LSCouplingType-Seniority schema type: */
class SOAP_CMAC _ns2__LSCouplingType_Seniority
{
public:
	std::string __item;
	std::string *ns2__sourceRef;	/* optional attribute */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE__ns2__LSCouplingType_Seniority */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__LSCouplingType_Seniority() { _ns2__LSCouplingType_Seniority::soap_default(NULL); }
	virtual ~_ns2__LSCouplingType_Seniority() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LSCouplingType
#define SOAP_TYPE_ns2__LSCouplingType (40)
/* ns2:LSCouplingType */
class SOAP_CMAC ns2__LSCouplingType
{
public:
	ns2__OrbitalAngularMomentumType *L;	/* required element of type ns2:OrbitalAngularMomentumType */
	std::string S;	/* required element of type ns2:AngularMomentumType */
	std::string *Multiplicity;	/* optional element of type xsd:positiveInteger */
	_ns2__LSCouplingType_Seniority *Seniority;	/* optional element of type ns2:LSCouplingType-Seniority */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns2__LSCouplingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LSCouplingType() { ns2__LSCouplingType::soap_default(NULL); }
	virtual ~ns2__LSCouplingType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OrbitalAngularMomentumType
#define SOAP_TYPE_ns2__OrbitalAngularMomentumType (42)
/* ns2:OrbitalAngularMomentumType */
class SOAP_CMAC ns2__OrbitalAngularMomentumType
{
public:
	std::string Value;	/* required element of type xsd:nonNegativeInteger */
	std::string *Symbol;	/* optional element of type ns2:OrbitalAngularMomentumSymbolType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns2__OrbitalAngularMomentumType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OrbitalAngularMomentumType() { ns2__OrbitalAngularMomentumType::soap_default(NULL); }
	virtual ~ns2__OrbitalAngularMomentumType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TermType
#define SOAP_TYPE_ns2__TermType (43)
/* ns2:TermType */
class SOAP_CMAC ns2__TermType
{
public:
	ns2__LSCouplingType *LS;	/* optional element of type ns2:LSCouplingType */
	ns2__jjCouplingType *jj;	/* optional element of type ns2:jjCouplingType */
	ns2__jjCouplingType *J1J2;	/* optional element of type ns2:jjCouplingType */
	ns2__jKCouplingType *jK;	/* optional element of type ns2:jKCouplingType */
	ns2__LKCouplingType *LK;	/* optional element of type ns2:LKCouplingType */
	std::string *TermLabel;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns2__TermType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TermType() { ns2__TermType::soap_default(NULL); }
	virtual ~ns2__TermType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__ReactantsType_sequence
#define SOAP_TYPE___ns2__ReactantsType_sequence (206)
/* Operation wrapper: */
class SOAP_CMAC __ns2__ReactantsType_sequence
{
public:
	std::string StateRef;	/* required element of type ns2:StateRef */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE___ns2__ReactantsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__ReactantsType_sequence() { __ns2__ReactantsType_sequence::soap_default(NULL); }
	virtual ~__ns2__ReactantsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReactantsType
#define SOAP_TYPE_ns2__ReactantsType (44)
/* ns2:ReactantsType */
class SOAP_CMAC ns2__ReactantsType
{
public:
	std::vector<__ns2__ReactantsType_sequence >__ReactantsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns2__ReactantsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReactantsType() { ns2__ReactantsType::soap_default(NULL); }
	virtual ~ns2__ReactantsType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__ProductsType_sequence
#define SOAP_TYPE___ns2__ProductsType_sequence (208)
/* Operation wrapper: */
class SOAP_CMAC __ns2__ProductsType_sequence
{
public:
	std::string StateRef;	/* required element of type ns2:StateRef */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE___ns2__ProductsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__ProductsType_sequence() { __ns2__ProductsType_sequence::soap_default(NULL); }
	virtual ~__ns2__ProductsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ProductsType
#define SOAP_TYPE_ns2__ProductsType (45)
/* ns2:ProductsType */
class SOAP_CMAC ns2__ProductsType
{
public:
	std::vector<__ns2__ProductsType_sequence >__ProductsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns2__ProductsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ProductsType() { ns2__ProductsType::soap_default(NULL); }
	virtual ~ns2__ProductsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AuthorType
#define SOAP_TYPE_ns2__AuthorType (46)
/* ns2:AuthorType */
class SOAP_CMAC ns2__AuthorType
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::string *Address;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns2__AuthorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AuthorType() { ns2__AuthorType::soap_default(NULL); }
	virtual ~ns2__AuthorType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SourcesType
#define SOAP_TYPE_ns2__SourcesType (47)
/* ns2:SourcesType */
class SOAP_CMAC ns2__SourcesType
{
public:
	std::vector<class ns2__SourceType * >Source;	/* required element of type ns2:SourceType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns2__SourcesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SourcesType() { ns2__SourcesType::soap_default(NULL); }
	virtual ~ns2__SourcesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SourceType
#define SOAP_TYPE_ns2__SourceType (48)
/* ns2:SourceType */
class SOAP_CMAC ns2__SourceType
{
public:
	enum ns2__CategoryType Category;	/* required element of type ns2:CategoryType */
	std::string SourceName;	/* required element of type xsd:string */
	std::string Year;	/* required element of type xsd:gYear */
	class ns2__AuthorsType *Authors;	/* required element of type ns2:AuthorsType */
	std::string *Title;	/* optional element of type xsd:string */
	std::string *Volume;	/* optional element of type xsd:string */
	std::string *DigitalObjectIdentifier;	/* optional element of type xsd:token */
	std::string *PageBegin;	/* optional element of type xsd:string */
	std::string *PageEnd;	/* optional element of type xsd:string */
	std::string *UniformResourceIdentifier;	/* optional element of type xsd:anyURI */
	std::string *Publisher;	/* optional element of type xsd:string */
	std::string *City;	/* optional element of type xsd:string */
	class ns2__EditorsType *Editors;	/* optional element of type ns2:EditorsType */
	std::string *ProductionDate;	/* optional element of type xsd:date */
	std::string *Version;	/* optional element of type xsd:string */
	std::string *Comments;	/* optional element of type xsd:string */
	std::string ns2__sourceID;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns2__SourceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SourceType() { ns2__SourceType::soap_default(NULL); }
	virtual ~ns2__SourceType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AuthorsType
#define SOAP_TYPE_ns2__AuthorsType (49)
/* ns2:AuthorsType */
class SOAP_CMAC ns2__AuthorsType
{
public:
	std::vector<ns2__AuthorType * >Author;	/* required element of type ns2:AuthorType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns2__AuthorsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AuthorsType() { ns2__AuthorsType::soap_default(NULL); }
	virtual ~ns2__AuthorsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EditorsType
#define SOAP_TYPE_ns2__EditorsType (50)
/* ns2:EditorsType */
class SOAP_CMAC ns2__EditorsType
{
public:
	std::vector<std::string >Name;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns2__EditorsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EditorsType() { ns2__EditorsType::soap_default(NULL); }
	virtual ~ns2__EditorsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MethodsType
#define SOAP_TYPE_ns2__MethodsType (51)
/* ns2:MethodsType */
class SOAP_CMAC ns2__MethodsType
{
public:
	std::vector<class ns2__MethodType * >Method;	/* required element of type ns2:MethodType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns2__MethodsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MethodsType() { ns2__MethodsType::soap_default(NULL); }
	virtual ~ns2__MethodsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MethodType
#define SOAP_TYPE_ns2__MethodType (52)
/* ns2:MethodType */
class SOAP_CMAC ns2__MethodType
{
public:
	enum ns2__MethodCategoryType Category;	/* required element of type ns2:MethodCategoryType */
	std::string Description;	/* required element of type xsd:string */
	std::string *Comments;	/* optional element of type xsd:string */
	std::string ns2__methodID;	/* required attribute */
	std::string *ns2__sourceRef;	/* optional attribute */
	std::string *ns2__functionRef;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns2__MethodType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MethodType() { ns2__MethodType::soap_default(NULL); }
	virtual ~ns2__MethodType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FunctionsType
#define SOAP_TYPE_ns2__FunctionsType (53)
/* ns2:FunctionsType */
class SOAP_CMAC ns2__FunctionsType
{
public:
	std::vector<class ns2__FunctionType * >Function;	/* required element of type ns2:FunctionType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns2__FunctionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FunctionsType() { ns2__FunctionsType::soap_default(NULL); }
	virtual ~ns2__FunctionsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IsotopeType
#define SOAP_TYPE_ns2__IsotopeType (57)
/* ns2:IsotopeType */
class SOAP_CMAC ns2__IsotopeType
{
public:
	class ns2__IsotopeParametersType *IsotopeParameters;	/* optional element of type ns2:IsotopeParametersType */
	std::vector<class ns2__IonStateType * >IonState;	/* required element of type ns2:IonStateType */
	std::string *Comments;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns2__IsotopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IsotopeType() { ns2__IsotopeType::soap_default(NULL); }
	virtual ~ns2__IsotopeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomicCoreType
#define SOAP_TYPE_ns2__AtomicCoreType (63)
/* ns2:AtomicCoreType */
class SOAP_CMAC ns2__AtomicCoreType
{
public:
	std::string *ElementCore;	/* optional element of type ns2:ElementSymbolType */
	class ns2__ConfigurationType *Configuration;	/* optional element of type ns2:ConfigurationType */
	ns2__TermType *Term;	/* optional element of type ns2:TermType */
	std::string *TotalAngularMomentum;	/* optional element of type ns2:AngularMomentumType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns2__AtomicCoreType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomicCoreType() { ns2__AtomicCoreType::soap_default(NULL); }
	virtual ~ns2__AtomicCoreType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomicComponentType
#define SOAP_TYPE_ns2__AtomicComponentType (64)
/* ns2:AtomicComponentType */
class SOAP_CMAC ns2__AtomicComponentType
{
public:
	class ns2__SuperConfigurationType *SuperConfiguration;	/* optional element of type ns2:SuperConfigurationType */
	ns2__ConfigurationType *Configuration;	/* optional element of type ns2:ConfigurationType */
	ns2__TermType *Term;	/* optional element of type ns2:TermType */
	class ns2__MixingCoefficientType *MixingCoefficient;	/* optional element of type ns2:MixingCoefficientType */
	std::string *Comments;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns2__AtomicComponentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomicComponentType() { ns2__AtomicComponentType::soap_default(NULL); }
	virtual ~ns2__AtomicComponentType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomicQuantumNumbersType
#define SOAP_TYPE_ns2__AtomicQuantumNumbersType (65)
/* ns2:AtomicQuantumNumbersType */
class SOAP_CMAC ns2__AtomicQuantumNumbersType
{
public:
	enum ns2__ParityType *Parity;	/* optional element of type ns2:ParityType */
	std::string *TotalAngularMomentum;	/* optional element of type ns2:AngularMomentumType */
	std::string *Kappa;	/* optional element of type ns2:AngularMomentumType */
	std::string *HyperfineMomentum;	/* optional element of type ns2:AngularMomentumType */
	std::string *MagneticQuantumNumber;	/* optional element of type ns2:AngularMomentumProjectionType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns2__AtomicQuantumNumbersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomicQuantumNumbersType() { ns2__AtomicQuantumNumbersType::soap_default(NULL); }
	virtual ~ns2__AtomicQuantumNumbersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ConfigurationType
#define SOAP_TYPE_ns2__ConfigurationType (66)
/* ns2:ConfigurationType */
class SOAP_CMAC ns2__ConfigurationType
{
public:
	ns2__AtomicCoreType *AtomicCore;	/* optional element of type ns2:AtomicCoreType */
	class ns2__ShellsType *Shells;	/* optional element of type ns2:ShellsType */
	std::string *ConfigurationLabel;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns2__ConfigurationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ConfigurationType() { ns2__ConfigurationType::soap_default(NULL); }
	virtual ~ns2__ConfigurationType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__ShellsType_sequence
#define SOAP_TYPE___ns2__ShellsType_sequence (238)
/* Operation wrapper: */
class SOAP_CMAC __ns2__ShellsType_sequence
{
public:
	std::vector<class ns2__ShellPairType * >ShellPair;	/* required element of type ns2:ShellPairType */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE___ns2__ShellsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__ShellsType_sequence() { __ns2__ShellsType_sequence::soap_default(NULL); }
	virtual ~__ns2__ShellsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ShellsType
#define SOAP_TYPE_ns2__ShellsType (67)
/* ns2:ShellsType */
class SOAP_CMAC ns2__ShellsType
{
public:
	std::vector<class ns2__ShellType * >Shell;	/* required element of type ns2:ShellType */
	std::vector<__ns2__ShellsType_sequence >__ShellsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns2__ShellsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ShellsType() { ns2__ShellsType::soap_default(NULL); }
	virtual ~ns2__ShellsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ShellPairType
#define SOAP_TYPE_ns2__ShellPairType (68)
/* ns2:ShellPairType */
class SOAP_CMAC ns2__ShellPairType
{
public:
	ns2__ShellType *Shell1;	/* required element of type ns2:ShellType */
	ns2__ShellType *Shell2;	/* required element of type ns2:ShellType */
	ns2__TermType *ShellPairTerm;	/* required element of type ns2:TermType */
	std::string shellPairID;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns2__ShellPairType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ShellPairType() { ns2__ShellPairType::soap_default(NULL); }
	virtual ~ns2__ShellPairType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ShellType
#define SOAP_TYPE_ns2__ShellType (69)
/* ns2:ShellType */
class SOAP_CMAC ns2__ShellType
{
public:
	std::string PrincipalQuantumNumber;	/* required element of type ns2:PrincipalQuantumNumberType */
	ns2__OrbitalAngularMomentumType *OrbitalAngularMomentum;	/* required element of type ns2:OrbitalAngularMomentumType */
	double NumberOfElectrons;	/* required element of type xsd:double */
	enum ns2__ParityType *Parity;	/* optional element of type ns2:ParityType */
	std::string *Kappa;	/* optional element of type ns2:AngularMomentumType */
	std::string *TotalAngularMomentum;	/* optional element of type ns2:AngularMomentumType */
	ns2__TermType *ShellTerm;	/* optional element of type ns2:TermType */
	std::string *shellID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns2__ShellType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ShellType() { ns2__ShellType::soap_default(NULL); }
	virtual ~ns2__ShellType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SuperConfigurationType
#define SOAP_TYPE_ns2__SuperConfigurationType (70)
/* ns2:SuperConfigurationType */
class SOAP_CMAC ns2__SuperConfigurationType
{
public:
	std::vector<class ns2__SuperShellType * >SuperShell;	/* required element of type ns2:SuperShellType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns2__SuperConfigurationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SuperConfigurationType() { ns2__SuperConfigurationType::soap_default(NULL); }
	virtual ~ns2__SuperConfigurationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SuperShellType
#define SOAP_TYPE_ns2__SuperShellType (71)
/* ns2:SuperShellType */
class SOAP_CMAC ns2__SuperShellType
{
public:
	std::string PrincipalQuantumNumber;	/* required element of type xsd:positiveInteger */
	double NumberOfElectrons;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns2__SuperShellType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SuperShellType() { ns2__SuperShellType::soap_default(NULL); }
	virtual ~ns2__SuperShellType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AsymmetricProjectionType
#define SOAP_TYPE_ns2__AsymmetricProjectionType (72)
/* ns2:AsymmetricProjectionType */
class SOAP_CMAC ns2__AsymmetricProjectionType
{
public:
	class ns2__MagneticQuantumNumberType *AsymmetricTau;	/* optional element of type ns2:MagneticQuantumNumberType */
	class ns2__MolecularQuantumNumberType *AsymmetricKa;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__MolecularQuantumNumberType *AsymmetricKc;	/* required element of type ns2:MolecularQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns2__AsymmetricProjectionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AsymmetricProjectionType() { ns2__AsymmetricProjectionType::soap_default(NULL); }
	virtual ~ns2__AsymmetricProjectionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HinderedMotionType
#define SOAP_TYPE_ns2__HinderedMotionType (73)
/* ns2:HinderedMotionType */
class SOAP_CMAC ns2__HinderedMotionType
{
public:
	ns2__MolecularQuantumNumberType *HinderedK1;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__MolecularQuantumNumberType *HinderedK2;	/* required element of type ns2:MolecularQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns2__HinderedMotionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HinderedMotionType() { ns2__HinderedMotionType::soap_default(NULL); }
	virtual ~ns2__HinderedMotionType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__AtomArrayType_sequence
#define SOAP_TYPE___ns2__AtomArrayType_sequence (247)
/* Operation wrapper: */
class SOAP_CMAC __ns2__AtomArrayType_sequence
{
public:
	class ns2__AtomNType *AtomN;	/* required element of type ns2:AtomNType */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE___ns2__AtomArrayType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__AtomArrayType_sequence() { __ns2__AtomArrayType_sequence::soap_default(NULL); }
	virtual ~__ns2__AtomArrayType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomArrayType
#define SOAP_TYPE_ns2__AtomArrayType (74)
/* ns2:AtomArrayType */
class SOAP_CMAC ns2__AtomArrayType
{
public:
	std::vector<__ns2__AtomArrayType_sequence >__AtomArrayType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns2__AtomArrayType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomArrayType() { ns2__AtomArrayType::soap_default(NULL); }
	virtual ~ns2__AtomArrayType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BondType
#define SOAP_TYPE_ns2__BondType (76)
/* ns2:BondType */
class SOAP_CMAC ns2__BondType
{
public:
	std::string *atomRefs2;	/* optional attribute */
	std::string *order;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns2__BondType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BondType() { ns2__BondType::soap_default(NULL); }
	virtual ~ns2__BondType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__BondArrayType_sequence
#define SOAP_TYPE___ns2__BondArrayType_sequence (251)
/* Operation wrapper: */
class SOAP_CMAC __ns2__BondArrayType_sequence
{
public:
	ns2__BondType *Bond;	/* required element of type ns2:BondType */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE___ns2__BondArrayType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__BondArrayType_sequence() { __ns2__BondArrayType_sequence::soap_default(NULL); }
	virtual ~__ns2__BondArrayType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BondArrayType
#define SOAP_TYPE_ns2__BondArrayType (77)
/* ns2:BondArrayType */
class SOAP_CMAC ns2__BondArrayType
{
public:
	std::vector<__ns2__BondArrayType_sequence >__BondArrayType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns2__BondArrayType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BondArrayType() { ns2__BondArrayType::soap_default(NULL); }
	virtual ~ns2__BondArrayType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__C2SymmetriesType
#define SOAP_TYPE_ns2__C2SymmetriesType (78)
/* ns2:C2SymmetriesType */
class SOAP_CMAC ns2__C2SymmetriesType
{
public:
	enum ns2__C2SymmetryType C2bSymmetry;	/* required element of type ns2:C2SymmetryType */
	enum ns2__C2SymmetryType C2cSymmetry;	/* required element of type ns2:C2SymmetryType */
	enum ns2__C2SymmetryType C2aSymmetry;	/* required element of type ns2:C2SymmetryType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns2__C2SymmetriesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__C2SymmetriesType() { ns2__C2SymmetriesType::soap_default(NULL); }
	virtual ~ns2__C2SymmetriesType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_DiatomAndLinearPolyatomicType
#define SOAP_TYPE__ns2__union_DiatomAndLinearPolyatomicType (257)
/* xsd:choice */
union _ns2__union_DiatomAndLinearPolyatomicType
{
#define SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecNoHyperF	(1)
	class ns2__LinearNoElecNoHyperFType *LinearNoElecNoHyperF;
#define SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecHyperF	(2)
	class ns2__LinearNoElecHyperFType *LinearNoElecHyperF;
#define SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearElecCoupling	(3)
	class ns2__LinearElecCouplingType *LinearElecCoupling;
};
#endif

#ifndef SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType
#define SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType (81)
/* Choice: */
class SOAP_CMAC ns2__DiatomAndLinearPolyatomicType
{
public:
	int __union_DiatomAndLinearPolyatomicType;	/* union discriminant (of union defined below) */
	union _ns2__union_DiatomAndLinearPolyatomicType union_DiatomAndLinearPolyatomicType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DiatomAndLinearPolyatomicType() { ns2__DiatomAndLinearPolyatomicType::soap_default(NULL); }
	virtual ~ns2__DiatomAndLinearPolyatomicType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ElectronicCharacterisationType
#define SOAP_TYPE_ns2__ElectronicCharacterisationType (82)
/* ns2:ElectronicCharacterisationType */
class SOAP_CMAC ns2__ElectronicCharacterisationType
{
public:
	class ns2__SymbolType *TermSymbol;	/* optional element of type ns2:SymbolType */
	class ns2__ReferencedTextType *Configuration;	/* optional element of type ns2:ReferencedTextType */
	std::string *Conformation;	/* optional element of type xsd:string */
	ns2__SymbolType *SymmetryGroup;	/* optional element of type ns2:SymbolType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns2__ElectronicCharacterisationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ElectronicCharacterisationType() { ns2__ElectronicCharacterisationType::soap_default(NULL); }
	virtual ~ns2__ElectronicCharacterisationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ElectronicComponentType
#define SOAP_TYPE_ns2__ElectronicComponentType (83)
/* ns2:ElectronicComponentType */
class SOAP_CMAC ns2__ElectronicComponentType
{
public:
	std::string *Description;	/* optional element of type xsd:token */
	std::string *SerialQuantumNumber;	/* optional element of type xsd:string */
	ns2__MixingCoefficientType *MixingCoefficient;	/* optional element of type ns2:MixingCoefficientType */
	ns2__ElectronicCharacterisationType *ElectronicCharacterisation;	/* optional element of type ns2:ElectronicCharacterisationType */
	ns2__MolecularQuantumNumberType *TotalMolecularProjectionL;	/* optional element of type ns2:MolecularQuantumNumberType */
	class ns2__VibrationalHomeType *VibrationalHome;	/* optional element of type ns2:VibrationalHomeType */
	std::string *Comment;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns2__ElectronicComponentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ElectronicComponentType() { ns2__ElectronicComponentType::soap_default(NULL); }
	virtual ~ns2__ElectronicComponentType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ElectronicHomeType
#define SOAP_TYPE_ns2__ElectronicHomeType (84)
/* ns2:ElectronicHomeType */
class SOAP_CMAC ns2__ElectronicHomeType
{
public:
	std::vector<ns2__ElectronicComponentType * >ElectronicComponent;	/* required element of type ns2:ElectronicComponentType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns2__ElectronicHomeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ElectronicHomeType() { ns2__ElectronicHomeType::soap_default(NULL); }
	virtual ~ns2__ElectronicHomeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularChemicalSpeciesType
#define SOAP_TYPE_ns2__MolecularChemicalSpeciesType (85)
/* ns2:MolecularChemicalSpeciesType */
class SOAP_CMAC ns2__MolecularChemicalSpeciesType
{
public:
	ns2__ReferencedTextType *OrdinaryStructuralFormula;	/* required element of type ns2:ReferencedTextType */
	std::string StoichiometricFormula;	/* required element of type xsd:string */
	std::string *IonCharge;	/* optional element of type xsd:integer */
	ns2__ReferencedTextType *ChemicalName;	/* optional element of type ns2:ReferencedTextType */
	ns2__ReferencedTextType *IUPACName;	/* optional element of type ns2:ReferencedTextType */
	std::string *URLFigure;	/* optional element of type xsd:anyURI */
	ns2__ReferencedTextType *InChI;	/* optional element of type ns2:ReferencedTextType */
	ns2__ReferencedTextType *InChIKey;	/* optional element of type ns2:ReferencedTextType */
	ns2__ReferencedTextType *CASRegistryNumber;	/* optional element of type ns2:ReferencedTextType */
	ns2__SymbolType *CNPIGroup;	/* optional element of type ns2:SymbolType */
	class ns2__MoleculeNuclearSpinsType *MoleculeNuclearSpins;	/* optional element of type ns2:MoleculeNuclearSpinsType */
	class ns2__MolecularPropertiesType *StableMolecularProperties;	/* optional element of type ns2:MolecularPropertiesType */
	std::string *Comment;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns2__MolecularChemicalSpeciesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularChemicalSpeciesType() { ns2__MolecularChemicalSpeciesType::soap_default(NULL); }
	virtual ~ns2__MolecularChemicalSpeciesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularProjectionType
#define SOAP_TYPE_ns2__MolecularProjectionType (86)
/* ns2:MolecularProjectionType */
class SOAP_CMAC ns2__MolecularProjectionType
{
public:
	ns2__MolecularQuantumNumberType *TotalMolecularProjectionN;	/* optional element of type ns2:MolecularQuantumNumberType */
	ns2__AsymmetricProjectionType *AsymmetricProjection;	/* optional element of type ns2:AsymmetricProjectionType */
	ns2__HinderedMotionType *HinderedMotion;	/* optional element of type ns2:HinderedMotionType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns2__MolecularProjectionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularProjectionType() { ns2__MolecularProjectionType::soap_default(NULL); }
	virtual ~ns2__MolecularProjectionType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__MolecularPropertiesType_sequence
#define SOAP_TYPE___ns2__MolecularPropertiesType_sequence (270)
/* Operation wrapper: */
class SOAP_CMAC __ns2__MolecularPropertiesType_sequence
{
public:
	class ns2__CharacterisationType *OtherProperties;	/* optional element of type ns2:CharacterisationType */
public:
	virtual int soap_type() const { return 270; } /* = unique id SOAP_TYPE___ns2__MolecularPropertiesType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__MolecularPropertiesType_sequence() { __ns2__MolecularPropertiesType_sequence::soap_default(NULL); }
	virtual ~__ns2__MolecularPropertiesType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularPropertiesType
#define SOAP_TYPE_ns2__MolecularPropertiesType (87)
/* ns2:MolecularPropertiesType */
class SOAP_CMAC ns2__MolecularPropertiesType
{
public:
	class ns2__DataType *MolecularWeight;	/* optional element of type ns2:DataType */
	std::vector<__ns2__MolecularPropertiesType_sequence >__MolecularPropertiesType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns2__MolecularPropertiesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularPropertiesType() { ns2__MolecularPropertiesType::soap_default(NULL); }
	virtual ~ns2__MolecularPropertiesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularStateCharacterisationType
#define SOAP_TYPE_ns2__MolecularStateCharacterisationType (89)
/* ns2:MolecularStateCharacterisationType */
class SOAP_CMAC ns2__MolecularStateCharacterisationType
{
public:
	class ns2__StateEnergyType *StateEnergy;	/* optional element of type ns2:StateEnergyType */
	std::string *TotalStatisticalWeight;	/* optional element of type xsd:positiveInteger */
	std::string *NuclearStatisticalWeight;	/* optional element of type xsd:positiveInteger */
	std::string *NuclearSpinSymmetry;	/* optional element of type xsd:string */
	ns2__DataType *LifeTime;	/* optional element of type ns2:DataType */
	std::vector<ns2__CharacterisationType * >Parameters;	/* optional element of type ns2:CharacterisationType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ns2__MolecularStateCharacterisationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularStateCharacterisationType() { ns2__MolecularStateCharacterisationType::soap_default(NULL); }
	virtual ~ns2__MolecularStateCharacterisationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType
#define SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType (90)
/* ns2:MolecularStateCharacterisation-oldType */
class SOAP_CMAC ns2__MolecularStateCharacterisation_oldType
{
public:
	ns2__StateEnergyType *StateEnergy;	/* optional element of type ns2:StateEnergyType */
	std::string *TotalStatisticalWeight;	/* optional element of type xsd:positiveInteger */
	std::string *NuclearStatisticalWeight;	/* optional element of type xsd:positiveInteger */
	class ns2__PseudoStatisticalWeightType *PseudoStatisticalWeight;	/* optional element of type ns2:PseudoStatisticalWeightType */
	ns2__PseudoStatisticalWeightType *PseudoNuclearStatisticalWeight;	/* optional element of type ns2:PseudoStatisticalWeightType */
	std::string *NuclearSpinSymmetry;	/* optional element of type xsd:string */
	ns2__DataType *LifeTime;	/* optional element of type ns2:DataType */
	std::vector<ns2__CharacterisationType * >Parameters;	/* optional element of type ns2:CharacterisationType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularStateCharacterisation_oldType() { ns2__MolecularStateCharacterisation_oldType::soap_default(NULL); }
	virtual ~ns2__MolecularStateCharacterisation_oldType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MoleculeNuclearSpinsType
#define SOAP_TYPE_ns2__MoleculeNuclearSpinsType (92)
/* ns2:MoleculeNuclearSpinsType */
class SOAP_CMAC ns2__MoleculeNuclearSpinsType
{
public:
	ns2__AtomArrayType *AtomArray;	/* required element of type ns2:AtomArrayType */
	ns2__BondArrayType *BondArray;	/* optional element of type ns2:BondArrayType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns2__MoleculeNuclearSpinsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MoleculeNuclearSpinsType() { ns2__MoleculeNuclearSpinsType::soap_default(NULL); }
	virtual ~ns2__MoleculeNuclearSpinsType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_NonLinearPolyatomicType
#define SOAP_TYPE__ns2__union_NonLinearPolyatomicType (282)
/* xsd:choice */
union _ns2__union_NonLinearPolyatomicType
{
#define SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecNoHyperF	(1)
	class ns2__NonLinearNoElecNoHyperFType *NonLinearNoElecNoHyperF;
#define SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecHyperF	(2)
	class ns2__NonLinearNoElecHyperFType *NonLinearNoElecHyperF;
#define SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecNoHyperF	(3)
	class ns2__NonLinearElecNoHyperFType *NonLinearElecNoHyperF;
#define SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecHyperF	(4)
	class ns2__NonLinearElecHyperFType *NonLinearElecHyperF;
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearPolyatomicType
#define SOAP_TYPE_ns2__NonLinearPolyatomicType (94)
/* Choice: */
class SOAP_CMAC ns2__NonLinearPolyatomicType
{
public:
	int __union_NonLinearPolyatomicType;	/* union discriminant (of union defined below) */
	union _ns2__union_NonLinearPolyatomicType union_NonLinearPolyatomicType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns2__NonLinearPolyatomicType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearPolyatomicType() { ns2__NonLinearPolyatomicType::soap_default(NULL); }
	virtual ~ns2__NonLinearPolyatomicType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RotationalCharacterisationType
#define SOAP_TYPE_ns2__RotationalCharacterisationType (95)
/* ns2:RotationalCharacterisationType */
class SOAP_CMAC ns2__RotationalCharacterisationType
{
public:
	ns2__SymbolType *RovibrationalSpeciesNotation;	/* optional element of type ns2:SymbolType */
	ns2__SymbolType *RovibronicSpeciesNotation;	/* optional element of type ns2:SymbolType */
	ns2__MagneticQuantumNumberType *RovibronicAngularMomentumP;	/* optional element of type ns2:MagneticQuantumNumberType */
	enum ns2__PermutationSymmetryType *PermutationSymmetry;	/* optional element of type ns2:PermutationSymmetryType */
	enum ns2__PermutationSymmetryType *InversionSymmetry;	/* optional element of type ns2:PermutationSymmetryType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns2__RotationalCharacterisationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotationalCharacterisationType() { ns2__RotationalCharacterisationType::soap_default(NULL); }
	virtual ~ns2__RotationalCharacterisationType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_RotationalComponentType
#define SOAP_TYPE__ns2__union_RotationalComponentType (286)
/* xsd:choice */
union _ns2__union_RotationalComponentType
{
#define SOAP_UNION__ns2__union_RotationalComponentType_DiatomAndLinearPolyatomic	(1)
	ns2__DiatomAndLinearPolyatomicType *DiatomAndLinearPolyatomic;
#define SOAP_UNION__ns2__union_RotationalComponentType_NonLinearPolyatomic	(2)
	ns2__NonLinearPolyatomicType *NonLinearPolyatomic;
};
#endif

#ifndef SOAP_TYPE_ns2__RotationalComponentType
#define SOAP_TYPE_ns2__RotationalComponentType (96)
/* ns2:RotationalComponentType */
class SOAP_CMAC ns2__RotationalComponentType
{
public:
	int __union_RotationalComponentType;	/* union discriminant (of union defined below) */
	union _ns2__union_RotationalComponentType union_RotationalComponentType;	/* required element of type xsd:choice */
	ns2__MixingCoefficientType *MixingCoefficient;	/* optional element of type ns2:MixingCoefficientType */
	std::string *SerialQuantumNumber;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns2__RotationalComponentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotationalComponentType() { ns2__RotationalComponentType::soap_default(NULL); }
	virtual ~ns2__RotationalComponentType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RotationalHomeType
#define SOAP_TYPE_ns2__RotationalHomeType (97)
/* ns2:RotationalHomeType */
class SOAP_CMAC ns2__RotationalHomeType
{
public:
	std::string *Description;	/* optional element of type xsd:string */
	ns2__RotationalCharacterisationType *RotationalCharacterisation;	/* optional element of type ns2:RotationalCharacterisationType */
	std::string *Comment;	/* optional element of type xsd:string */
	std::vector<ns2__RotationalComponentType * >RotationalComponent;	/* required element of type ns2:RotationalComponentType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns2__RotationalHomeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotationalHomeType() { ns2__RotationalHomeType::soap_default(NULL); }
	virtual ~ns2__RotationalHomeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularQuantumNumberType
#define SOAP_TYPE_ns2__MolecularQuantumNumberType (100)
/* ns2:MolecularQuantumNumberType */
class SOAP_CMAC ns2__MolecularQuantumNumberType
{
public:
	std::string Label;	/* required element of type xsd:string */
	std::string Value;	/* required element of type ns2:AngularMomentumType */
	std::string *Comment;	/* optional element of type xsd:string */
	std::string *quantumNumberID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns2__MolecularQuantumNumberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularQuantumNumberType() { ns2__MolecularQuantumNumberType::soap_default(NULL); }
	virtual ~ns2__MolecularQuantumNumberType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MagneticQuantumNumberType
#define SOAP_TYPE_ns2__MagneticQuantumNumberType (101)
/* ns2:MagneticQuantumNumberType */
class SOAP_CMAC ns2__MagneticQuantumNumberType
{
public:
	std::string Label;	/* required element of type xsd:string */
	std::string Value;	/* required element of type ns2:AngularMomentumProjectionType */
	std::string *Comment;	/* optional element of type xsd:string */
	std::string *quantumNumberID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns2__MagneticQuantumNumberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MagneticQuantumNumberType() { ns2__MagneticQuantumNumberType::soap_default(NULL); }
	virtual ~ns2__MagneticQuantumNumberType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SimpleSymbolType
#define SOAP_TYPE_ns2__SimpleSymbolType (102)
/* ns2:SimpleSymbolType */
class SOAP_CMAC ns2__SimpleSymbolType
{
public:
	class ns2__CentralSymbolType *CentralSymbol;	/* required element of type ns2:CentralSymbolType */
	std::string RightCoefficient;	/* required element of type xsd:string */
	std::string LeftCoefficient;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns2__SimpleSymbolType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SimpleSymbolType() { ns2__SimpleSymbolType::soap_default(NULL); }
	virtual ~ns2__SimpleSymbolType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VibrationalComponentType
#define SOAP_TYPE_ns2__VibrationalComponentType (106)
/* ns2:VibrationalComponentType */
class SOAP_CMAC ns2__VibrationalComponentType
{
public:
	std::string *Description;	/* optional element of type xsd:string */
	std::string *SerialQuantumNumber;	/* optional element of type xsd:string */
	ns2__MixingCoefficientType *MixingCoefficient;	/* optional element of type ns2:MixingCoefficientType */
	class ns2__VibrationalCharacterisationType *VibrationalCharacterisation;	/* optional element of type ns2:VibrationalCharacterisationType */
	class ns2__VibrationalQuantumNumbersType *VibrationalQuantumNumbers;	/* optional element of type ns2:VibrationalQuantumNumbersType */
	ns2__RotationalHomeType *RotationalHome;	/* optional element of type ns2:RotationalHomeType */
	std::string *Comment;	/* optional element of type xsd:token */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns2__VibrationalComponentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VibrationalComponentType() { ns2__VibrationalComponentType::soap_default(NULL); }
	virtual ~ns2__VibrationalComponentType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VibrationalCharacterisationType
#define SOAP_TYPE_ns2__VibrationalCharacterisationType (107)
/* ns2:VibrationalCharacterisationType */
class SOAP_CMAC ns2__VibrationalCharacterisationType
{
public:
	ns2__SymbolType *VibrationalSpeciesNotation;	/* optional element of type ns2:SymbolType */
	ns2__SymbolType *VibronicSpeciesNotation;	/* optional element of type ns2:SymbolType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns2__VibrationalCharacterisationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VibrationalCharacterisationType() { ns2__VibrationalCharacterisationType::soap_default(NULL); }
	virtual ~ns2__VibrationalCharacterisationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VibrationalHomeType
#define SOAP_TYPE_ns2__VibrationalHomeType (108)
/* ns2:VibrationalHomeType */
class SOAP_CMAC ns2__VibrationalHomeType
{
public:
	ns2__CharacterisationType *Polyad;	/* optional element of type ns2:CharacterisationType */
	std::vector<ns2__VibrationalComponentType * >VibrationalComponent;	/* required element of type ns2:VibrationalComponentType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns2__VibrationalHomeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VibrationalHomeType() { ns2__VibrationalHomeType::soap_default(NULL); }
	virtual ~ns2__VibrationalHomeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VibrationalQuantumNumbersType
#define SOAP_TYPE_ns2__VibrationalQuantumNumbersType (109)
/* ns2:VibrationalQuantumNumbersType */
class SOAP_CMAC ns2__VibrationalQuantumNumbersType
{
public:
	std::vector<class ns2__ComplexMolecularQuantumNumberType * >VibrationalNu;	/* optional element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MolecularQuantumNumberType *TotalVibrationL;	/* optional element of type ns2:MolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *VibronicAngularMomentumK;	/* optional element of type ns2:MagneticQuantumNumberType */
	ns2__MagneticQuantumNumberType *VibronicAngularMomentumP;	/* optional element of type ns2:MagneticQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns2__VibrationalQuantumNumbersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VibrationalQuantumNumbersType() { ns2__VibrationalQuantumNumbersType::soap_default(NULL); }
	virtual ~ns2__VibrationalQuantumNumbersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LinearNoElecNoHyperFType
#define SOAP_TYPE_ns2__LinearNoElecNoHyperFType (110)
/* ns2:LinearNoElecNoHyperFType */
class SOAP_CMAC ns2__LinearNoElecNoHyperFType
{
public:
	ns2__MolecularQuantumNumberType *TotalAngularMomentumN;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberN;	/* optional element of type ns2:MagneticQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns2__LinearNoElecNoHyperFType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LinearNoElecNoHyperFType() { ns2__LinearNoElecNoHyperFType::soap_default(NULL); }
	virtual ~ns2__LinearNoElecNoHyperFType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LinearNoElecHyperFType
#define SOAP_TYPE_ns2__LinearNoElecHyperFType (111)
/* ns2:LinearNoElecHyperFType */
class SOAP_CMAC ns2__LinearNoElecHyperFType
{
public:
	ns2__MolecularQuantumNumberType *TotalAngularMomentumN;	/* required element of type ns2:MolecularQuantumNumberType */
	class ns2__HyperfineQuantumNumbersType *HyperfineQuantumNumbers;	/* required element of type ns2:HyperfineQuantumNumbersType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns2__LinearNoElecHyperFType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LinearNoElecHyperFType() { ns2__LinearNoElecHyperFType::soap_default(NULL); }
	virtual ~ns2__LinearNoElecHyperFType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LinearElecCouplingType
#define SOAP_TYPE_ns2__LinearElecCouplingType (112)
/* ns2:LinearElecCouplingType */
class SOAP_CMAC ns2__LinearElecCouplingType
{
public:
	std::string Description;	/* required element of type xsd:string */
	enum ns2__EfSymmetryType *EfSymmetry;	/* optional element of type ns2:EfSymmetryType */
	class ns2__HundCaseAType *HundCaseA;	/* optional element of type ns2:HundCaseAType */
	class ns2__HyperfineCaseAAlphaType *HyperfineCaseAAlpha;	/* optional element of type ns2:HyperfineCaseAAlphaType */
	class ns2__HyperfineCaseABetaType *HyperfineCaseABeta;	/* optional element of type ns2:HyperfineCaseABetaType */
	class ns2__HundCaseBType *HundCaseB;	/* optional element of type ns2:HundCaseBType */
	class ns2__HyperfineCouplingBType *HyperfineCouplingHundCaseB;	/* optional element of type ns2:HyperfineCouplingBType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns2__LinearElecCouplingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LinearElecCouplingType() { ns2__LinearElecCouplingType::soap_default(NULL); }
	virtual ~ns2__LinearElecCouplingType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HundCaseAType
#define SOAP_TYPE_ns2__HundCaseAType (113)
/* ns2:HundCaseAType */
class SOAP_CMAC ns2__HundCaseAType
{
public:
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumJ;	/* required element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MolecularQuantumNumberType *TotalMolecularProjectionJ;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberJ;	/* optional element of type ns2:MagneticQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE_ns2__HundCaseAType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HundCaseAType() { ns2__HundCaseAType::soap_default(NULL); }
	virtual ~ns2__HundCaseAType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HundCaseBType
#define SOAP_TYPE_ns2__HundCaseBType (114)
/* ns2:HundCaseBType */
class SOAP_CMAC ns2__HundCaseBType
{
public:
	ns2__MolecularQuantumNumberType *TotalAngularMomentumN;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumJ;	/* required element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberJ;	/* optional element of type ns2:MagneticQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_ns2__HundCaseBType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HundCaseBType() { ns2__HundCaseBType::soap_default(NULL); }
	virtual ~ns2__HundCaseBType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HyperfineCaseAAlphaType
#define SOAP_TYPE_ns2__HyperfineCaseAAlphaType (115)
/* ns2:HyperfineCaseAAlphaType */
class SOAP_CMAC ns2__HyperfineCaseAAlphaType
{
public:
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumF;	/* required element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MolecularQuantumNumberType *TotalMolecularProjectionF;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberF;	/* optional element of type ns2:MagneticQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE_ns2__HyperfineCaseAAlphaType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HyperfineCaseAAlphaType() { ns2__HyperfineCaseAAlphaType::soap_default(NULL); }
	virtual ~ns2__HyperfineCaseAAlphaType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HyperfineCaseABetaType
#define SOAP_TYPE_ns2__HyperfineCaseABetaType (116)
/* ns2:HyperfineCaseABetaType */
class SOAP_CMAC ns2__HyperfineCaseABetaType
{
public:
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumJ;	/* required element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MolecularQuantumNumberType *TotalMolecularProjectionJ;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__HyperfineQuantumNumbersType *HyperfineQuantumNumbers;	/* required element of type ns2:HyperfineQuantumNumbersType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_ns2__HyperfineCaseABetaType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HyperfineCaseABetaType() { ns2__HyperfineCaseABetaType::soap_default(NULL); }
	virtual ~ns2__HyperfineCaseABetaType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HyperfineCouplingBType
#define SOAP_TYPE_ns2__HyperfineCouplingBType (117)
/* ns2:HyperfineCouplingBType */
class SOAP_CMAC ns2__HyperfineCouplingBType
{
public:
	enum ns2__CouplingListType CouplingType;	/* required element of type ns2:CouplingListType */
	ns2__MolecularQuantumNumberType *TotalAngularMomentumN;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumJ;	/* optional element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__HyperfineQuantumNumbersType *HyperfineQuantumNumbers;	/* required element of type ns2:HyperfineQuantumNumbersType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_ns2__HyperfineCouplingBType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HyperfineCouplingBType() { ns2__HyperfineCouplingBType::soap_default(NULL); }
	virtual ~ns2__HyperfineCouplingBType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearElecCouplingType
#define SOAP_TYPE_ns2__NonLinearElecCouplingType (118)
/* ns2:NonLinearElecCouplingType */
class SOAP_CMAC ns2__NonLinearElecCouplingType
{
public:
	std::string *Label;	/* optional element of type xsd:string */
	enum ns2__EfSymmetryType *EfSymmetry;	/* optional element of type ns2:EfSymmetryType */
	ns2__MolecularQuantumNumberType *TotalAngularMomentumN;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumJ;	/* required element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MolecularProjectionType *MolecularProjection;	/* required element of type ns2:MolecularProjectionType */
	class ns2__RoVibronicSplittingType *RoVibronicSplitting;	/* optional element of type ns2:RoVibronicSplittingType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE_ns2__NonLinearElecCouplingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearElecCouplingType() { ns2__NonLinearElecCouplingType::soap_default(NULL); }
	virtual ~ns2__NonLinearElecCouplingType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearNoElecType
#define SOAP_TYPE_ns2__NonLinearNoElecType (121)
/* ns2:NonLinearNoElecType */
class SOAP_CMAC ns2__NonLinearNoElecType
{
public:
	ns2__MolecularQuantumNumberType *TotalAngularMomentumN;	/* required element of type ns2:MolecularQuantumNumberType */
	ns2__MolecularProjectionType *MolecularProjection;	/* required element of type ns2:MolecularProjectionType */
	ns2__C2SymmetriesType *C2Symmetries;	/* optional element of type ns2:C2SymmetriesType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE_ns2__NonLinearNoElecType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearNoElecType() { ns2__NonLinearNoElecType::soap_default(NULL); }
	virtual ~ns2__NonLinearNoElecType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_HyperfineQuantumNumbersType
#define SOAP_TYPE__ns2__union_HyperfineQuantumNumbersType (309)
/* xsd:choice */
union _ns2__union_HyperfineQuantumNumbersType
{
#define SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_ISum	(1)
	ns2__ComplexMolecularQuantumNumberType *ISum;
#define SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_IntermediateHyperfineQuantumNumber	(2)
	ns2__ComplexMolecularQuantumNumberType *IntermediateHyperfineQuantumNumber;
};
#endif

#ifndef SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType
#define SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType (308)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_HyperfineQuantumNumbersType
{
public:
	int __union_HyperfineQuantumNumbersType;	/* union discriminant (of union defined below) */
	union _ns2__union_HyperfineQuantumNumbersType union_HyperfineQuantumNumbersType;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 308; } /* = unique id SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_HyperfineQuantumNumbersType() { __ns2__union_HyperfineQuantumNumbersType::soap_default(NULL); }
	virtual ~__ns2__union_HyperfineQuantumNumbersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HyperfineQuantumNumbersType
#define SOAP_TYPE_ns2__HyperfineQuantumNumbersType (124)
/* ns2:HyperfineQuantumNumbersType */
class SOAP_CMAC ns2__HyperfineQuantumNumbersType
{
public:
	int __size_HyperfineQuantumNumbersType;	/* sequence of elements <-union-HyperfineQuantumNumbersType> */
	__ns2__union_HyperfineQuantumNumbersType *__union_HyperfineQuantumNumbersType;
	ns2__ComplexMolecularQuantumNumberType *TotalAngularMomentumF;	/* required element of type ns2:ComplexMolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberF;	/* optional element of type ns2:MagneticQuantumNumberType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE_ns2__HyperfineQuantumNumbersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HyperfineQuantumNumbersType() { ns2__HyperfineQuantumNumbersType::soap_default(NULL); }
	virtual ~ns2__HyperfineQuantumNumbersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ParticlesType
#define SOAP_TYPE_ns2__ParticlesType (127)
/* ns2:ParticlesType */
class SOAP_CMAC ns2__ParticlesType
{
public:
	std::vector<class ns2__ParticleType * >Particle;	/* required element of type ns2:ParticleType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE_ns2__ParticlesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ParticlesType() { ns2__ParticlesType::soap_default(NULL); }
	virtual ~ns2__ParticlesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ParticleType
#define SOAP_TYPE_ns2__ParticleType (128)
/* ns2:ParticleType */
class SOAP_CMAC ns2__ParticleType
{
public:
	class ns2__ParticlePropertiesType *ParticleProperties;	/* optional element of type ns2:ParticlePropertiesType */
	std::string *Comments;	/* optional element of type xsd:string */
	std::string ns2__stateID;	/* required attribute */
	enum ns2__ParticleNameType *name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE_ns2__ParticleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ParticleType() { ns2__ParticleType::soap_default(NULL); }
	virtual ~ns2__ParticleType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ParticlePropertiesType
#define SOAP_TYPE_ns2__ParticlePropertiesType (129)
/* ns2:ParticlePropertiesType */
class SOAP_CMAC ns2__ParticlePropertiesType
{
public:
	std::string *ParticleCharge;	/* optional element of type xsd:integer */
	ns2__DataType *ParticleMass;	/* optional element of type ns2:DataType */
	std::string *ParticleSpin;	/* optional element of type ns2:AngularMomentumType */
	std::string *ParticlePolarization;	/* optional element of type ns2:AngularMomentumProjectionType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE_ns2__ParticlePropertiesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ParticlePropertiesType() { ns2__ParticlePropertiesType::soap_default(NULL); }
	virtual ~ns2__ParticlePropertiesType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_MaterialComponentType
#define SOAP_TYPE__ns2__union_MaterialComponentType (317)
/* xsd:choice */
union _ns2__union_MaterialComponentType
{
#define SOAP_UNION__ns2__union_MaterialComponentType_StoichiometricValue	(1)
	std::string *StoichiometricValue;
#define SOAP_UNION__ns2__union_MaterialComponentType_Percentage	(2)
	std::string *Percentage;
};
#endif

#ifndef SOAP_TYPE_ns2__MaterialComponentType
#define SOAP_TYPE_ns2__MaterialComponentType (132)
/* ns2:MaterialComponentType */
class SOAP_CMAC ns2__MaterialComponentType
{
public:
	ns2__ChemicalElementType *ChemicalElement;	/* required element of type ns2:ChemicalElementType */
	int __union_MaterialComponentType;	/* union discriminant (of union defined below) */
	union _ns2__union_MaterialComponentType union_MaterialComponentType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE_ns2__MaterialComponentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MaterialComponentType() { ns2__MaterialComponentType::soap_default(NULL); }
	virtual ~ns2__MaterialComponentType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MaterialType
#define SOAP_TYPE_ns2__MaterialType (133)
/* ns2:MaterialType */
class SOAP_CMAC ns2__MaterialType
{
public:
	std::string MaterialName;	/* required element of type xsd:string */
	class ns2__MaterialCompositionType *MaterialComposition;	/* required element of type ns2:MaterialCompositionType */
	ns2__DataType *MaterialThickness;	/* optional element of type ns2:DataType */
	std::string *MaterialTopology;	/* optional element of type xsd:string */
	ns2__DataType *MaterialTemperature;	/* optional element of type ns2:DataType */
	std::string *Comments;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE_ns2__MaterialType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MaterialType() { ns2__MaterialType::soap_default(NULL); }
	virtual ~ns2__MaterialType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CollisionalProcessClassType
#define SOAP_TYPE_ns2__CollisionalProcessClassType (144)
/* ns2:CollisionalProcessClassType */
class SOAP_CMAC ns2__CollisionalProcessClassType
{
public:
	char *UserDefinition;	/* optional element of type xsd:anyType */
	std::vector<enum ns2__CodeType >Code;	/* optional element of type ns2:CodeType */
	enum ns2__IAEACodeType *IAEACode;	/* optional element of type ns2:IAEACodeType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE_ns2__CollisionalProcessClassType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CollisionalProcessClassType() { ns2__CollisionalProcessClassType::soap_default(NULL); }
	virtual ~ns2__CollisionalProcessClassType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__XSAMSDataType
#define SOAP_TYPE_ns2__XSAMSDataType (145)
/* ns2:XSAMSDataType */
class SOAP_CMAC ns2__XSAMSDataType
{
public:
	class ns2__StatesType *States;	/* required element of type ns2:StatesType */
	class ns2__ProcessesType *Processes;	/* optional element of type ns2:ProcessesType */
	ns2__SourcesType *ns2__Sources;	/* required element of type ns2:SourcesType */
	ns2__MethodsType *ns2__Methods;	/* optional element of type ns2:MethodsType */
	ns2__FunctionsType *ns2__Functions;	/* optional element of type ns2:FunctionsType */
	std::string *Comments;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE_ns2__XSAMSDataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__XSAMSDataType() { ns2__XSAMSDataType::soap_default(NULL); }
	virtual ~ns2__XSAMSDataType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ProcessesType
#define SOAP_TYPE_ns2__ProcessesType (146)
/* ns2:ProcessesType */
class SOAP_CMAC ns2__ProcessesType
{
public:
	class ns2__RadiativeType *Radiative;	/* optional element of type ns2:RadiativeType */
	class ns2__NonRadiativeType *ns2__NonRadiative;	/* optional element of type ns2:NonRadiativeType */
	class ns2__CollisionsType *Collisions;	/* optional element of type ns2:CollisionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE_ns2__ProcessesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ProcessesType() { ns2__ProcessesType::soap_default(NULL); }
	virtual ~ns2__ProcessesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__StatesType
#define SOAP_TYPE_ns2__StatesType (147)
/* ns2:StatesType */
class SOAP_CMAC ns2__StatesType
{
public:
	class ns2__AtomsType *Atoms;	/* optional element of type ns2:AtomsType */
	class ns2__MoleculesType *Molecules;	/* optional element of type ns2:MoleculesType */
	class ns2__SolidsType *Solids;	/* optional element of type ns2:SolidsType */
	ns2__ParticlesType *Particles;	/* optional element of type ns2:ParticlesType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE_ns2__StatesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__StatesType() { ns2__StatesType::soap_default(NULL); }
	virtual ~ns2__StatesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DataType
#define SOAP_TYPE_ns2__DataType (22)
/* ns2:DataType */
class SOAP_CMAC ns2__DataType : public ns2__PrimaryType
{
public:
	class ns2__ValueType *Value;	/* required element of type ns2:ValueType */
	std::string *Accuracy;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns2__DataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DataType() { ns2__DataType::soap_default(NULL); }
	virtual ~ns2__DataType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DataSetType
#define SOAP_TYPE_ns2__DataSetType (23)
/* ns2:DataSetType */
class SOAP_CMAC ns2__DataSetType : public ns2__PrimaryType
{
public:
	std::vector<class ns2__FitDataType * >FitData;	/* optional element of type ns2:FitDataType */
	std::vector<class ns2__TabulatedDataType * >TabulatedData;	/* optional element of type ns2:TabulatedDataType */
	enum ns2__DataDescriptionType dataDescription;	/* required attribute */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns2__DataSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DataSetType() { ns2__DataSetType::soap_default(NULL); }
	virtual ~ns2__DataSetType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TabulatedDataType
#define SOAP_TYPE_ns2__TabulatedDataType (27)
/* ns2:TabulatedDataType */
class SOAP_CMAC ns2__TabulatedDataType : public ns2__PrimaryType
{
public:
	ns2__DataXYType *DataXY;	/* required element of type ns2:DataXYType */
	enum ns2__ReferenceFrameType *ReferenceFrame;	/* optional element of type ns2:ReferenceFrameType */
	std::string *PhysicalUncertainty;	/* optional element of type xsd:string */
	std::string *ProductionDate;	/* optional element of type xsd:date */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns2__TabulatedDataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TabulatedDataType() { ns2__TabulatedDataType::soap_default(NULL); }
	virtual ~ns2__TabulatedDataType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FitDataType
#define SOAP_TYPE_ns2__FitDataType (28)
/* ns2:FitDataType */
class SOAP_CMAC ns2__FitDataType : public ns2__PrimaryType
{
public:
	std::string FunctionRef;	/* required element of type xsd:IDREF */
	std::vector<ns2__FitValidityLimitsType * >FitValidityLimits;	/* required element of type ns2:FitValidityLimitsType */
	ns2__FitParametersType *FitParameters;	/* required element of type ns2:FitParametersType */
	std::string *FitAccuracy;	/* optional element of type xsd:string */
	std::string *PhysicalUncertainty;	/* optional element of type xsd:string */
	std::string *ProductionDate;	/* optional element of type xsd:date */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns2__FitDataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FitDataType() { ns2__FitDataType::soap_default(NULL); }
	virtual ~ns2__FitDataType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ExpressionType
#define SOAP_TYPE_ns2__ExpressionType (31)
/* Primitive ns2:ExpressionType schema type: */
class SOAP_CMAC ns2__ExpressionType
{
public:
	std::string __item;
	std::string computerLanguage;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns2__ExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ExpressionType() { ns2__ExpressionType::soap_default(NULL); }
	virtual ~ns2__ExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ValueType
#define SOAP_TYPE_ns2__ValueType (36)
/* Primitive ns2:ValueType schema type: */
class SOAP_CMAC ns2__ValueType
{
public:
	double __item;
	enum _ns2__units ns2__units;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns2__ValueType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ValueType() { ns2__ValueType::soap_default(NULL); }
	virtual ~ns2__ValueType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MixingCoefficientType
#define SOAP_TYPE_ns2__MixingCoefficientType (41)
/* Primitive ns2:MixingCoefficientType schema type: */
class SOAP_CMAC ns2__MixingCoefficientType
{
public:
	double __item;
	enum ns2__MixingClassType mixingClass;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns2__MixingCoefficientType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MixingCoefficientType() { ns2__MixingCoefficientType::soap_default(NULL); }
	virtual ~ns2__MixingCoefficientType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FunctionType
#define SOAP_TYPE_ns2__FunctionType (54)
/* ns2:FunctionType */
class SOAP_CMAC ns2__FunctionType : public ns2__PrimaryType
{
public:
	std::string *Name;	/* optional element of type xsd:string */
	ns2__ExpressionType *Expression;	/* required element of type ns2:ExpressionType */
	ns2__ArgumentType *Y;	/* required element of type ns2:ArgumentType */
	ns2__ArgumentsType *Arguments;	/* required element of type ns2:ArgumentsType */
	ns2__ParametersType *Parameters;	/* optional element of type ns2:ParametersType */
	enum ns2__ReferenceFrameType *ReferenceFrame;	/* optional element of type ns2:ReferenceFrameType */
	std::string *Description;	/* optional element of type xsd:string */
	std::string *SourceCodeURL;	/* optional element of type xsd:string */
	std::string ns2__functionID;	/* required attribute */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns2__FunctionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FunctionType() { ns2__FunctionType::soap_default(NULL); }
	virtual ~ns2__FunctionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomsType
#define SOAP_TYPE_ns2__AtomsType (55)
/* ns2:AtomsType */
class SOAP_CMAC ns2__AtomsType : public ns2__PrimaryType
{
public:
	std::vector<class ns2__AtomType * >Atom;	/* required element of type ns2:AtomType */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns2__AtomsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomsType() { ns2__AtomsType::soap_default(NULL); }
	virtual ~ns2__AtomsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomType
#define SOAP_TYPE_ns2__AtomType (56)
/* ns2:AtomType */
class SOAP_CMAC ns2__AtomType : public ns2__PrimaryType
{
public:
	ns2__ChemicalElementType *ChemicalElement;	/* required element of type ns2:ChemicalElementType */
	std::vector<ns2__IsotopeType * >Isotope;	/* required element of type ns2:IsotopeType */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns2__AtomType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomType() { ns2__AtomType::soap_default(NULL); }
	virtual ~ns2__AtomType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IsotopeParametersType
#define SOAP_TYPE_ns2__IsotopeParametersType (58)
/* ns2:IsotopeParametersType */
class SOAP_CMAC ns2__IsotopeParametersType : public ns2__PrimaryType
{
public:
	std::string MassNumber;	/* required element of type xsd:integer */
	ns2__DataType *Mass;	/* optional element of type ns2:DataType */
	std::string *NuclearSpin;	/* optional element of type ns2:AngularMomentumType */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns2__IsotopeParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IsotopeParametersType() { ns2__IsotopeParametersType::soap_default(NULL); }
	virtual ~ns2__IsotopeParametersType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IonStateType
#define SOAP_TYPE_ns2__IonStateType (59)
/* ns2:IonStateType */
class SOAP_CMAC ns2__IonStateType : public ns2__PrimaryType
{
public:
	std::string IonCharge;	/* required element of type xsd:integer */
	std::string *IsoelectronicSequence;	/* optional element of type ns2:ElementSymbolType */
	std::vector<class ns2__AtomicStateType * >AtomicState;	/* required element of type ns2:AtomicStateType */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns2__IonStateType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IonStateType() { ns2__IonStateType::soap_default(NULL); }
	virtual ~ns2__IonStateType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomicStateType
#define SOAP_TYPE_ns2__AtomicStateType (60)
/* ns2:AtomicStateType */
class SOAP_CMAC ns2__AtomicStateType : public ns2__PrimaryType
{
public:
	std::string *Description;	/* optional element of type xsd:string */
	class ns2__AtomicNumericalDataType *AtomicNumericalData;	/* optional element of type ns2:AtomicNumericalDataType */
	ns2__AtomicQuantumNumbersType *AtomicQuantumNumbers;	/* optional element of type ns2:AtomicQuantumNumbersType */
	class ns2__AtomicCompositionType *AtomicComposition;	/* optional element of type ns2:AtomicCompositionType */
	std::string ns2__stateID;	/* required attribute */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns2__AtomicStateType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomicStateType() { ns2__AtomicStateType::soap_default(NULL); }
	virtual ~ns2__AtomicStateType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomicNumericalDataType
#define SOAP_TYPE_ns2__AtomicNumericalDataType (61)
/* ns2:AtomicNumericalDataType */
class SOAP_CMAC ns2__AtomicNumericalDataType : public ns2__PrimaryType
{
public:
	ns2__DataType *StateEnergy;	/* optional element of type ns2:DataType */
	ns2__DataType *IonizationEnergy;	/* optional element of type ns2:DataType */
	ns2__DataType *LandeFactor;	/* optional element of type ns2:DataType */
	ns2__DataType *QuantumDefect;	/* optional element of type ns2:DataType */
	ns2__DataType *TotalLifeTime;	/* optional element of type ns2:DataType */
	ns2__DataType *Polarizability;	/* optional element of type ns2:DataType */
	double *StatisticalWeight;	/* optional element of type xsd:double */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns2__AtomicNumericalDataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomicNumericalDataType() { ns2__AtomicNumericalDataType::soap_default(NULL); }
	virtual ~ns2__AtomicNumericalDataType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomicCompositionType
#define SOAP_TYPE_ns2__AtomicCompositionType (62)
/* ns2:AtomicCompositionType */
class SOAP_CMAC ns2__AtomicCompositionType : public ns2__PrimaryType
{
public:
	std::vector<ns2__AtomicComponentType * >Component;	/* required element of type ns2:AtomicComponentType */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns2__AtomicCompositionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomicCompositionType() { ns2__AtomicCompositionType::soap_default(NULL); }
	virtual ~ns2__AtomicCompositionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AtomNType
#define SOAP_TYPE_ns2__AtomNType (75)
/* ns2:AtomNType */
class SOAP_CMAC ns2__AtomNType : public ns2__PrimaryType
{
public:
	std::string *nuclearSpinID;	/* optional attribute */
	std::string *elementSymbol;	/* optional attribute */
	std::string *isotope;	/* optional attribute */
	std::string *nuclearSpin;	/* optional attribute */
	std::string *hydrogenCount;	/* optional attribute */
	std::string *count;	/* optional attribute */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns2__AtomNType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AtomNType() { ns2__AtomNType::soap_default(NULL); }
	virtual ~ns2__AtomNType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CentralSymbolType
#define SOAP_TYPE_ns2__CentralSymbolType (79)
/* Primitive ns2:CentralSymbolType schema type: */
class SOAP_CMAC ns2__CentralSymbolType
{
public:
	std::string __item;
	std::string *UpperLeftValue;	/* optional attribute */
	std::string *LowerLeftValue;	/* optional attribute */
	std::string *UpperRightValue;	/* optional attribute */
	std::string *LowerRightValue;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns2__CentralSymbolType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CentralSymbolType() { ns2__CentralSymbolType::soap_default(NULL); }
	virtual ~ns2__CentralSymbolType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType
#define SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType (80)
/* ns2:ComplexMolecularQuantumNumberType */
class SOAP_CMAC ns2__ComplexMolecularQuantumNumberType : public ns2__MolecularQuantumNumberType
{
public:
	enum ns2__ModesListType *modesType;	/* optional attribute */
	std::string *vibrationLNu_i;	/* optional attribute */
	std::string *vibrationSymmetry;	/* optional attribute */
	std::string *vibrationInversion;	/* optional attribute */
	std::string *vibrationSymmetryIndex;	/* optional attribute */
	std::string *nuclearSpinRefs2;	/* optional attribute */
	std::string *nuclearSpinRef;	/* optional attribute */
	std::string *spinSumRef;	/* optional attribute */
	std::string *electronicSpinRef;	/* optional attribute */
	std::string *quantumNumberRef;	/* optional attribute */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ComplexMolecularQuantumNumberType() { ns2__ComplexMolecularQuantumNumberType::soap_default(NULL); }
	virtual ~ns2__ComplexMolecularQuantumNumberType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MolecularStateType
#define SOAP_TYPE_ns2__MolecularStateType (88)
/* ns2:MolecularStateType */
class SOAP_CMAC ns2__MolecularStateType : public ns2__PrimaryType
{
public:
	std::string Description;	/* required element of type xsd:string */
	ns2__MolecularStateCharacterisationType *MolecularStateCharacterisation;	/* optional element of type ns2:MolecularStateCharacterisationType */
	ns2__MolecularQuantumNumberType *TotalSpinMomentumS;	/* optional element of type ns2:MolecularQuantumNumberType */
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberS;	/* optional element of type ns2:MagneticQuantumNumberType */
	enum ns2__ParityType *Parity;	/* optional element of type ns2:ParityType */
	std::string *Comment;	/* optional element of type xsd:string */
	ns2__ElectronicHomeType *ElectronicHome;	/* optional element of type ns2:ElectronicHomeType */
	std::string ns2__stateID;	/* required attribute */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns2__MolecularStateType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MolecularStateType() { ns2__MolecularStateType::soap_default(NULL); }
	virtual ~ns2__MolecularStateType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MoleculeType
#define SOAP_TYPE_ns2__MoleculeType (91)
/* ns2:MoleculeType */
class SOAP_CMAC ns2__MoleculeType : public ns2__PrimaryType
{
public:
	ns2__MolecularChemicalSpeciesType *MolecularChemicalSpecies;	/* required element of type ns2:MolecularChemicalSpeciesType */
	std::vector<ns2__MolecularStateType * >MolecularState;	/* required element of type ns2:MolecularStateType */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ns2__MoleculeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MoleculeType() { ns2__MoleculeType::soap_default(NULL); }
	virtual ~ns2__MoleculeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MoleculesType
#define SOAP_TYPE_ns2__MoleculesType (93)
/* ns2:MoleculesType */
class SOAP_CMAC ns2__MoleculesType : public ns2__PrimaryType
{
public:
	std::vector<ns2__MoleculeType * >Molecule;	/* required element of type ns2:MoleculeType */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns2__MoleculesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MoleculesType() { ns2__MoleculesType::soap_default(NULL); }
	virtual ~ns2__MoleculesType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PseudoStatisticalWeightType
#define SOAP_TYPE_ns2__PseudoStatisticalWeightType (98)
/* ns2:PseudoStatisticalWeightType */
class SOAP_CMAC ns2__PseudoStatisticalWeightType : public ns2__PrimaryType
{
public:
	std::string Value;	/* required element of type xsd:positiveInteger */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns2__PseudoStatisticalWeightType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PseudoStatisticalWeightType() { ns2__PseudoStatisticalWeightType::soap_default(NULL); }
	virtual ~ns2__PseudoStatisticalWeightType() { }
};
#endif

#ifndef SOAP_TYPE___ns2__RoVibronicSplittingType_sequence
#define SOAP_TYPE___ns2__RoVibronicSplittingType_sequence (366)
/* Operation wrapper: */
class SOAP_CMAC __ns2__RoVibronicSplittingType_sequence
{
public:
	std::string Label;	/* required element of type xsd:string */
	std::string Type;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 366; } /* = unique id SOAP_TYPE___ns2__RoVibronicSplittingType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__RoVibronicSplittingType_sequence() { __ns2__RoVibronicSplittingType_sequence::soap_default(NULL); }
	virtual ~__ns2__RoVibronicSplittingType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RoVibronicSplittingType
#define SOAP_TYPE_ns2__RoVibronicSplittingType (99)
/* ns2:RoVibronicSplittingType */
class SOAP_CMAC ns2__RoVibronicSplittingType : public ns2__PrimaryType
{
public:
	std::vector<__ns2__RoVibronicSplittingType_sequence >__RoVibronicSplittingType_sequence;
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns2__RoVibronicSplittingType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RoVibronicSplittingType() { ns2__RoVibronicSplittingType::soap_default(NULL); }
	virtual ~ns2__RoVibronicSplittingType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SymbolType
#define SOAP_TYPE_ns2__SymbolType (104)
/* ns2:SymbolType */
class SOAP_CMAC ns2__SymbolType : public ns2__PrimaryType
{
public:
	std::vector<ns2__SimpleSymbolType * >Symbol;	/* required element of type ns2:SimpleSymbolType */
	std::string *LatexExpression;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns2__SymbolType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SymbolType() { ns2__SymbolType::soap_default(NULL); }
	virtual ~ns2__SymbolType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearElecHyperFType
#define SOAP_TYPE_ns2__NonLinearElecHyperFType (119)
/* ns2:NonLinearElecHyperFType */
class SOAP_CMAC ns2__NonLinearElecHyperFType : public ns2__NonLinearElecCouplingType
{
public:
	ns2__HyperfineQuantumNumbersType *HyperfineQuantumNumbers;	/* required element of type ns2:HyperfineQuantumNumbersType */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE_ns2__NonLinearElecHyperFType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearElecHyperFType() { ns2__NonLinearElecHyperFType::soap_default(NULL); }
	virtual ~ns2__NonLinearElecHyperFType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearElecNoHyperFType
#define SOAP_TYPE_ns2__NonLinearElecNoHyperFType (120)
/* ns2:NonLinearElecNoHyperFType */
class SOAP_CMAC ns2__NonLinearElecNoHyperFType : public ns2__NonLinearElecCouplingType
{
public:
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberJ;	/* optional element of type ns2:MagneticQuantumNumberType */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_ns2__NonLinearElecNoHyperFType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearElecNoHyperFType() { ns2__NonLinearElecNoHyperFType::soap_default(NULL); }
	virtual ~ns2__NonLinearElecNoHyperFType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType
#define SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType (122)
/* ns2:NonLinearNoElecNoHyperFType */
class SOAP_CMAC ns2__NonLinearNoElecNoHyperFType : public ns2__NonLinearNoElecType
{
public:
	ns2__MagneticQuantumNumberType *TotalMagneticQuantumNumberN;	/* optional element of type ns2:MagneticQuantumNumberType */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearNoElecNoHyperFType() { ns2__NonLinearNoElecNoHyperFType::soap_default(NULL); }
	virtual ~ns2__NonLinearNoElecNoHyperFType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonLinearNoElecHyperFType
#define SOAP_TYPE_ns2__NonLinearNoElecHyperFType (123)
/* ns2:NonLinearNoElecHyperFType */
class SOAP_CMAC ns2__NonLinearNoElecHyperFType : public ns2__NonLinearNoElecType
{
public:
	ns2__HyperfineQuantumNumbersType *HyperfineQuantumNumbers;	/* required element of type ns2:HyperfineQuantumNumbersType */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_ns2__NonLinearNoElecHyperFType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonLinearNoElecHyperFType() { ns2__NonLinearNoElecHyperFType::soap_default(NULL); }
	virtual ~ns2__NonLinearNoElecHyperFType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReferencedTextType
#define SOAP_TYPE_ns2__ReferencedTextType (125)
/* Primitive ns2:ReferencedTextType schema type: */
class SOAP_CMAC ns2__ReferencedTextType
{
public:
	std::string __item;
	std::string *ns2__sourceRef;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE_ns2__ReferencedTextType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReferencedTextType() { ns2__ReferencedTextType::soap_default(NULL); }
	virtual ~ns2__ReferencedTextType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_CharacterisationType
#define SOAP_TYPE__ns2__union_CharacterisationType (371)
/* xsd:choice */
union _ns2__union_CharacterisationType
{
#define SOAP_UNION__ns2__union_CharacterisationType_IntValue	(1)
	std::string *IntValue;
#define SOAP_UNION__ns2__union_CharacterisationType_FloatValue	(2)
	float FloatValue;
#define SOAP_UNION__ns2__union_CharacterisationType_StringValue	(3)
	std::string *StringValue;
};
#endif

#ifndef SOAP_TYPE_ns2__CharacterisationType
#define SOAP_TYPE_ns2__CharacterisationType (126)
/* ns2:CharacterisationType */
class SOAP_CMAC ns2__CharacterisationType : public ns2__PrimaryType
{
public:
	std::string *Name;	/* optional element of type xsd:string */
	int __union_CharacterisationType;	/* union discriminant (of union defined below) */
	union _ns2__union_CharacterisationType union_CharacterisationType;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE_ns2__CharacterisationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CharacterisationType() { ns2__CharacterisationType::soap_default(NULL); }
	virtual ~ns2__CharacterisationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SolidType
#define SOAP_TYPE_ns2__SolidType (130)
/* ns2:SolidType */
class SOAP_CMAC ns2__SolidType : public ns2__PrimaryType
{
public:
	std::vector<ns2__MaterialType * >Layer;	/* required element of type ns2:MaterialType */
	std::string ns2__stateID;	/* required attribute */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE_ns2__SolidType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SolidType() { ns2__SolidType::soap_default(NULL); }
	virtual ~ns2__SolidType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SolidsType
#define SOAP_TYPE_ns2__SolidsType (131)
/* ns2:SolidsType */
class SOAP_CMAC ns2__SolidsType : public ns2__PrimaryType
{
public:
	std::vector<ns2__SolidType * >Solid;	/* required element of type ns2:SolidType */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE_ns2__SolidsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SolidsType() { ns2__SolidsType::soap_default(NULL); }
	virtual ~ns2__SolidsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MaterialCompositionType
#define SOAP_TYPE_ns2__MaterialCompositionType (134)
/* ns2:MaterialCompositionType */
class SOAP_CMAC ns2__MaterialCompositionType : public ns2__PrimaryType
{
public:
	std::vector<ns2__MaterialComponentType * >Component;	/* required element of type ns2:MaterialComponentType */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE_ns2__MaterialCompositionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MaterialCompositionType() { ns2__MaterialCompositionType::soap_default(NULL); }
	virtual ~ns2__MaterialCompositionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RadiativeType
#define SOAP_TYPE_ns2__RadiativeType (135)
/* ns2:RadiativeType */
class SOAP_CMAC ns2__RadiativeType : public ns2__PrimaryType
{
public:
	std::vector<class ns2__RadiativeTransitionType * >RadiativeTransition;	/* required element of type ns2:RadiativeTransitionType */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE_ns2__RadiativeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RadiativeType() { ns2__RadiativeType::soap_default(NULL); }
	virtual ~ns2__RadiativeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RadiativeTransitionType
#define SOAP_TYPE_ns2__RadiativeTransitionType (136)
/* ns2:RadiativeTransitionType */
class SOAP_CMAC ns2__RadiativeTransitionType : public ns2__PrimaryType
{
public:
	class ns2__EnergyWavelengthType *EnergyWavelength;	/* required element of type ns2:EnergyWavelengthType */
	std::string *InitialStateRef;	/* optional element of type ns2:StateRef */
	std::string *FinalStateRef;	/* optional element of type ns2:StateRef */
	std::vector<class ns2__RadiativeTransitionProbabilityType * >Probability;	/* optional element of type ns2:RadiativeTransitionProbabilityType */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE_ns2__RadiativeTransitionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RadiativeTransitionType() { ns2__RadiativeTransitionType::soap_default(NULL); }
	virtual ~ns2__RadiativeTransitionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RadiativeTransitionProbabilityType
#define SOAP_TYPE_ns2__RadiativeTransitionProbabilityType (137)
/* ns2:RadiativeTransitionProbabilityType */
class SOAP_CMAC ns2__RadiativeTransitionProbabilityType : public ns2__PrimaryType
{
public:
	ns2__DataType *TransitionProbabilityA;	/* optional element of type ns2:DataType */
	ns2__DataType *OscillatorStrength;	/* optional element of type ns2:DataType */
	ns2__DataType *LineStrength;	/* optional element of type ns2:DataType */
	ns2__DataType *WeightedOscillatorStrength;	/* optional element of type ns2:DataType */
	ns2__DataType *Log10WeightedOscillatorStrength;	/* optional element of type ns2:DataType */
	ns2__DataType *IdealisedIntensity;	/* optional element of type ns2:DataType */
	std::string *Multipole;	/* optional element of type ns2:MultipoleType */
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE_ns2__RadiativeTransitionProbabilityType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RadiativeTransitionProbabilityType() { ns2__RadiativeTransitionProbabilityType::soap_default(NULL); }
	virtual ~ns2__RadiativeTransitionProbabilityType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WavelengthWavenumberType
#define SOAP_TYPE_ns2__WavelengthWavenumberType (138)
/* ns2:WavelengthWavenumberType */
class SOAP_CMAC ns2__WavelengthWavenumberType : public ns2__PrimaryType
{
public:
	ns2__DataType *Ritz;	/* optional element of type ns2:DataType */
	ns2__DataType *Experimental;	/* optional element of type ns2:DataType */
	ns2__DataType *Theoretical;	/* optional element of type ns2:DataType */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE_ns2__WavelengthWavenumberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WavelengthWavenumberType() { ns2__WavelengthWavenumberType::soap_default(NULL); }
	virtual ~ns2__WavelengthWavenumberType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EnergyWavelengthType
#define SOAP_TYPE_ns2__EnergyWavelengthType (139)
/* ns2:EnergyWavelengthType */
class SOAP_CMAC ns2__EnergyWavelengthType : public ns2__PrimaryType
{
public:
	ns2__WavelengthWavenumberType *Wavenumber;	/* optional element of type ns2:WavelengthWavenumberType */
	ns2__WavelengthWavenumberType *Wavelength;	/* optional element of type ns2:WavelengthWavenumberType */
	ns2__WavelengthWavenumberType *Energy;	/* optional element of type ns2:WavelengthWavenumberType */
	ns2__WavelengthWavenumberType *Frequency;	/* optional element of type ns2:WavelengthWavenumberType */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE_ns2__EnergyWavelengthType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EnergyWavelengthType() { ns2__EnergyWavelengthType::soap_default(NULL); }
	virtual ~ns2__EnergyWavelengthType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonRadiativeType
#define SOAP_TYPE_ns2__NonRadiativeType (140)
/* ns2:NonRadiativeType */
class SOAP_CMAC ns2__NonRadiativeType : public ns2__PrimaryType
{
public:
	std::vector<class ns2__NonRadiativeTransitionType * >NonRadiativeTransition;	/* required element of type ns2:NonRadiativeTransitionType */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_ns2__NonRadiativeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonRadiativeType() { ns2__NonRadiativeType::soap_default(NULL); }
	virtual ~ns2__NonRadiativeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NonRadiativeTransitionType
#define SOAP_TYPE_ns2__NonRadiativeTransitionType (141)
/* ns2:NonRadiativeTransitionType */
class SOAP_CMAC ns2__NonRadiativeTransitionType : public ns2__PrimaryType
{
public:
	std::string InitialStateRef;	/* required element of type ns2:StateRef */
	std::string *FinalStateRef;	/* optional element of type ns2:StateRef */
	ns2__DataType *Probability;	/* required element of type ns2:DataType */
	ns2__DataType *NonRadiativeWidth;	/* optional element of type ns2:DataType */
	ns2__DataType *TransitionEnergy;	/* optional element of type ns2:DataType */
	std::string *Type;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE_ns2__NonRadiativeTransitionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NonRadiativeTransitionType() { ns2__NonRadiativeTransitionType::soap_default(NULL); }
	virtual ~ns2__NonRadiativeTransitionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CollisionsType
#define SOAP_TYPE_ns2__CollisionsType (142)
/* ns2:CollisionsType */
class SOAP_CMAC ns2__CollisionsType : public ns2__PrimaryType
{
public:
	std::vector<class ns2__CollisionalTransitionType * >CollisionalTransition;	/* required element of type ns2:CollisionalTransitionType */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_ns2__CollisionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CollisionsType() { ns2__CollisionsType::soap_default(NULL); }
	virtual ~ns2__CollisionsType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CollisionalTransitionType
#define SOAP_TYPE_ns2__CollisionalTransitionType (143)
/* ns2:CollisionalTransitionType */
class SOAP_CMAC ns2__CollisionalTransitionType : public ns2__PrimaryType
{
public:
	ns2__CollisionalProcessClassType *ProcessClass;	/* required element of type ns2:CollisionalProcessClassType */
	ns2__ReactantsType *Reactants;	/* required element of type ns2:ReactantsType */
	ns2__ProductsType *IntermediateStates;	/* optional element of type ns2:ProductsType */
	ns2__ProductsType *Products;	/* optional element of type ns2:ProductsType */
	ns2__DataType *Threshold;	/* optional element of type ns2:DataType */
	ns2__DataSetsType *DataSets;	/* required element of type ns2:DataSetsType */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE_ns2__CollisionalTransitionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CollisionalTransitionType() { ns2__CollisionalTransitionType::soap_default(NULL); }
	virtual ~ns2__CollisionalTransitionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__StateEnergyType
#define SOAP_TYPE_ns2__StateEnergyType (103)
/* ns2:StateEnergyType */
class SOAP_CMAC ns2__StateEnergyType : public ns2__DataType
{
public:
	std::string energyOrigin;	/* required attribute */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns2__StateEnergyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__StateEnergyType() { ns2__StateEnergyType::soap_default(NULL); }
	virtual ~ns2__StateEnergyType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TotalSpinMomentumSType
#define SOAP_TYPE_ns2__TotalSpinMomentumSType (105)
/* Primitive ns2:TotalSpinMomentumSType schema type: */
class SOAP_CMAC ns2__TotalSpinMomentumSType
{
public:
	std::string __item;
	std::string *electronicSpinId;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns2__TotalSpinMomentumSType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TotalSpinMomentumSType() { ns2__TotalSpinMomentumSType::soap_default(NULL); }
	virtual ~ns2__TotalSpinMomentumSType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__getSResponse
#define SOAP_TYPE_ns2__getSResponse (398)
/* ns2:getSResponse */
struct ns2__getSResponse
{
public:
	double dat;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:double */
};
#endif

#ifndef SOAP_TYPE_ns2__getS
#define SOAP_TYPE_ns2__getS (399)
/* ns2:getS */
struct ns2__getS
{
public:
	std::string species1;	/* required element of type xsd:string */
	std::string species2;	/* required element of type xsd:string */
	unsigned int s;	/* required element of type xsd:unsignedInt */
	double x0;	/* required element of type xsd:double */
	double Tmin;	/* required element of type xsd:double */
	double Tmax;	/* required element of type xsd:double */
	double Npoints;	/* required element of type xsd:double */
	bool logaritmic;	/* required element of type xsd:boolean */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (400)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (401)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (403)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (406)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (407)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (10)
typedef std::string xsd__IDREF;
#endif

#ifndef SOAP_TYPE_xsd__IDREFS
#define SOAP_TYPE_xsd__IDREFS (11)
typedef std::string xsd__IDREFS;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (12)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (13)
typedef std::string xsd__date;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (14)
typedef std::string xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__gYear
#define SOAP_TYPE_xsd__gYear (15)
typedef std::string xsd__gYear;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (16)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (17)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (18)
typedef std::string xsd__positiveInteger;
#endif

#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (19)
typedef std::string xsd__token;
#endif

#ifndef SOAP_TYPE_ns2__DataListType
#define SOAP_TYPE_ns2__DataListType (148)
typedef std::string ns2__DataListType;
#endif

#ifndef SOAP_TYPE_ns2__AngularMomentumProjectionType
#define SOAP_TYPE_ns2__AngularMomentumProjectionType (151)
typedef std::string ns2__AngularMomentumProjectionType;
#endif

#ifndef SOAP_TYPE_ns2__AngularMomentumType
#define SOAP_TYPE_ns2__AngularMomentumType (152)
typedef std::string ns2__AngularMomentumType;
#endif

#ifndef SOAP_TYPE_ns2__ElementSymbolType
#define SOAP_TYPE_ns2__ElementSymbolType (153)
typedef std::string ns2__ElementSymbolType;
#endif

#ifndef SOAP_TYPE_ns2__PrincipalQuantumNumberType
#define SOAP_TYPE_ns2__PrincipalQuantumNumberType (154)
typedef std::string ns2__PrincipalQuantumNumberType;
#endif

#ifndef SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType
#define SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType (157)
typedef std::string ns2__OrbitalAngularMomentumSymbolType;
#endif

#ifndef SOAP_TYPE_ns2__StateRef
#define SOAP_TYPE_ns2__StateRef (158)
typedef std::string ns2__StateRef;
#endif

#ifndef SOAP_TYPE_ns2__MultipoleType
#define SOAP_TYPE_ns2__MultipoleType (167)
typedef std::string ns2__MultipoleType;
#endif

#ifndef SOAP_TYPE__ns2__sourceRef
#define SOAP_TYPE__ns2__sourceRef (170)
typedef std::string _ns2__sourceRef;
#endif

#ifndef SOAP_TYPE__ns2__methodRef
#define SOAP_TYPE__ns2__methodRef (171)
typedef std::string _ns2__methodRef;
#endif

#ifndef SOAP_TYPE__ns2__functionRef
#define SOAP_TYPE__ns2__functionRef (172)
typedef std::string _ns2__functionRef;
#endif

#ifndef SOAP_TYPE__ns2__stateID
#define SOAP_TYPE__ns2__stateID (174)
typedef std::string _ns2__stateID;
#endif

#ifndef SOAP_TYPE__ns2__sourceID
#define SOAP_TYPE__ns2__sourceID (175)
typedef std::string _ns2__sourceID;
#endif

#ifndef SOAP_TYPE__ns2__methodID
#define SOAP_TYPE__ns2__methodID (176)
typedef std::string _ns2__methodID;
#endif

#ifndef SOAP_TYPE__ns2__functionID
#define SOAP_TYPE__ns2__functionID (177)
typedef std::string _ns2__functionID;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
