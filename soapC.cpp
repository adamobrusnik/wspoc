/* soapC.cpp
   Generated by gSOAP 2.8.7 from test.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.7 2013-09-24 13:40:34 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__ns2__units:
		return soap_in__ns2__units(soap, NULL, NULL, "ns2:units");
	case SOAP_TYPE_ns2__CodeType:
		return soap_in_ns2__CodeType(soap, NULL, NULL, "ns2:CodeType");
	case SOAP_TYPE_ns2__IAEACodeType:
		return soap_in_ns2__IAEACodeType(soap, NULL, NULL, "ns2:IAEACodeType");
	case SOAP_TYPE_ns2__ParticleNameType:
		return soap_in_ns2__ParticleNameType(soap, NULL, NULL, "ns2:ParticleNameType");
	case SOAP_TYPE_ns2__PermutationSymmetryType:
		return soap_in_ns2__PermutationSymmetryType(soap, NULL, NULL, "ns2:PermutationSymmetryType");
	case SOAP_TYPE_ns2__ModesListType:
		return soap_in_ns2__ModesListType(soap, NULL, NULL, "ns2:ModesListType");
	case SOAP_TYPE_ns2__EfSymmetryType:
		return soap_in_ns2__EfSymmetryType(soap, NULL, NULL, "ns2:EfSymmetryType");
	case SOAP_TYPE_ns2__CouplingListType:
		return soap_in_ns2__CouplingListType(soap, NULL, NULL, "ns2:CouplingListType");
	case SOAP_TYPE_ns2__C2SymmetryType:
		return soap_in_ns2__C2SymmetryType(soap, NULL, NULL, "ns2:C2SymmetryType");
	case SOAP_TYPE_ns2__MethodCategoryType:
		return soap_in_ns2__MethodCategoryType(soap, NULL, NULL, "ns2:MethodCategoryType");
	case SOAP_TYPE_ns2__CategoryType:
		return soap_in_ns2__CategoryType(soap, NULL, NULL, "ns2:CategoryType");
	case SOAP_TYPE_ns2__MixingClassType:
		return soap_in_ns2__MixingClassType(soap, NULL, NULL, "ns2:MixingClassType");
	case SOAP_TYPE_ns2__ParityType:
		return soap_in_ns2__ParityType(soap, NULL, NULL, "ns2:ParityType");
	case SOAP_TYPE_ns2__ReferenceFrameType:
		return soap_in_ns2__ReferenceFrameType(soap, NULL, NULL, "ns2:ReferenceFrameType");
	case SOAP_TYPE_ns2__DataDescriptionType:
		return soap_in_ns2__DataDescriptionType(soap, NULL, NULL, "ns2:DataDescriptionType");
	case SOAP_TYPE_ns2__MultipoleType:
		return soap_in_ns2__MultipoleType(soap, NULL, NULL, "ns2:MultipoleType");
	case SOAP_TYPE_ns2__StateRef:
		return soap_in_ns2__StateRef(soap, NULL, NULL, "ns2:StateRef");
	case SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType:
		return soap_in_ns2__OrbitalAngularMomentumSymbolType(soap, NULL, NULL, "ns2:OrbitalAngularMomentumSymbolType");
	case SOAP_TYPE_ns2__PrincipalQuantumNumberType:
		return soap_in_ns2__PrincipalQuantumNumberType(soap, NULL, NULL, "ns2:PrincipalQuantumNumberType");
	case SOAP_TYPE_ns2__ElementSymbolType:
		return soap_in_ns2__ElementSymbolType(soap, NULL, NULL, "ns2:ElementSymbolType");
	case SOAP_TYPE_ns2__AngularMomentumType:
		return soap_in_ns2__AngularMomentumType(soap, NULL, NULL, "ns2:AngularMomentumType");
	case SOAP_TYPE_ns2__AngularMomentumProjectionType:
		return soap_in_ns2__AngularMomentumProjectionType(soap, NULL, NULL, "ns2:AngularMomentumProjectionType");
	case SOAP_TYPE_ns2__DataListType:
		return soap_in_ns2__DataListType(soap, NULL, NULL, "ns2:DataListType");
	case SOAP_TYPE_ns2__StatesType:
		return soap_in_ns2__StatesType(soap, NULL, NULL, "ns2:StatesType");
	case SOAP_TYPE_ns2__ProcessesType:
		return soap_in_ns2__ProcessesType(soap, NULL, NULL, "ns2:ProcessesType");
	case SOAP_TYPE_ns2__XSAMSDataType:
		return soap_in_ns2__XSAMSDataType(soap, NULL, NULL, "ns2:XSAMSDataType");
	case SOAP_TYPE_ns2__CollisionalProcessClassType:
		return soap_in_ns2__CollisionalProcessClassType(soap, NULL, NULL, "ns2:CollisionalProcessClassType");
	case SOAP_TYPE_ns2__CollisionalTransitionType:
		return soap_in_ns2__CollisionalTransitionType(soap, NULL, NULL, "ns2:CollisionalTransitionType");
	case SOAP_TYPE_ns2__CollisionsType:
		return soap_in_ns2__CollisionsType(soap, NULL, NULL, "ns2:CollisionsType");
	case SOAP_TYPE_ns2__NonRadiativeTransitionType:
		return soap_in_ns2__NonRadiativeTransitionType(soap, NULL, NULL, "ns2:NonRadiativeTransitionType");
	case SOAP_TYPE_ns2__NonRadiativeType:
		return soap_in_ns2__NonRadiativeType(soap, NULL, NULL, "ns2:NonRadiativeType");
	case SOAP_TYPE_ns2__EnergyWavelengthType:
		return soap_in_ns2__EnergyWavelengthType(soap, NULL, NULL, "ns2:EnergyWavelengthType");
	case SOAP_TYPE_ns2__WavelengthWavenumberType:
		return soap_in_ns2__WavelengthWavenumberType(soap, NULL, NULL, "ns2:WavelengthWavenumberType");
	case SOAP_TYPE_ns2__RadiativeTransitionProbabilityType:
		return soap_in_ns2__RadiativeTransitionProbabilityType(soap, NULL, NULL, "ns2:RadiativeTransitionProbabilityType");
	case SOAP_TYPE_ns2__RadiativeTransitionType:
		return soap_in_ns2__RadiativeTransitionType(soap, NULL, NULL, "ns2:RadiativeTransitionType");
	case SOAP_TYPE_ns2__RadiativeType:
		return soap_in_ns2__RadiativeType(soap, NULL, NULL, "ns2:RadiativeType");
	case SOAP_TYPE_ns2__MaterialCompositionType:
		return soap_in_ns2__MaterialCompositionType(soap, NULL, NULL, "ns2:MaterialCompositionType");
	case SOAP_TYPE_ns2__MaterialType:
		return soap_in_ns2__MaterialType(soap, NULL, NULL, "ns2:MaterialType");
	case SOAP_TYPE_ns2__MaterialComponentType:
		return soap_in_ns2__MaterialComponentType(soap, NULL, NULL, "ns2:MaterialComponentType");
	case SOAP_TYPE_ns2__SolidsType:
		return soap_in_ns2__SolidsType(soap, NULL, NULL, "ns2:SolidsType");
	case SOAP_TYPE_ns2__SolidType:
		return soap_in_ns2__SolidType(soap, NULL, NULL, "ns2:SolidType");
	case SOAP_TYPE_ns2__ParticlePropertiesType:
		return soap_in_ns2__ParticlePropertiesType(soap, NULL, NULL, "ns2:ParticlePropertiesType");
	case SOAP_TYPE_ns2__ParticleType:
		return soap_in_ns2__ParticleType(soap, NULL, NULL, "ns2:ParticleType");
	case SOAP_TYPE_ns2__ParticlesType:
		return soap_in_ns2__ParticlesType(soap, NULL, NULL, "ns2:ParticlesType");
	case SOAP_TYPE_ns2__CharacterisationType:
		return soap_in_ns2__CharacterisationType(soap, NULL, NULL, "ns2:CharacterisationType");
	case SOAP_TYPE_ns2__ReferencedTextType:
		return soap_in_ns2__ReferencedTextType(soap, NULL, NULL, "ns2:ReferencedTextType");
	case SOAP_TYPE_ns2__HyperfineQuantumNumbersType:
		return soap_in_ns2__HyperfineQuantumNumbersType(soap, NULL, NULL, "ns2:HyperfineQuantumNumbersType");
	case SOAP_TYPE_ns2__NonLinearNoElecHyperFType:
		return soap_in_ns2__NonLinearNoElecHyperFType(soap, NULL, NULL, "ns2:NonLinearNoElecHyperFType");
	case SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType:
		return soap_in_ns2__NonLinearNoElecNoHyperFType(soap, NULL, NULL, "ns2:NonLinearNoElecNoHyperFType");
	case SOAP_TYPE_ns2__NonLinearNoElecType:
		return soap_in_ns2__NonLinearNoElecType(soap, NULL, NULL, "ns2:NonLinearNoElecType");
	case SOAP_TYPE_ns2__NonLinearElecNoHyperFType:
		return soap_in_ns2__NonLinearElecNoHyperFType(soap, NULL, NULL, "ns2:NonLinearElecNoHyperFType");
	case SOAP_TYPE_ns2__NonLinearElecHyperFType:
		return soap_in_ns2__NonLinearElecHyperFType(soap, NULL, NULL, "ns2:NonLinearElecHyperFType");
	case SOAP_TYPE_ns2__NonLinearElecCouplingType:
		return soap_in_ns2__NonLinearElecCouplingType(soap, NULL, NULL, "ns2:NonLinearElecCouplingType");
	case SOAP_TYPE_ns2__HyperfineCouplingBType:
		return soap_in_ns2__HyperfineCouplingBType(soap, NULL, NULL, "ns2:HyperfineCouplingBType");
	case SOAP_TYPE_ns2__HyperfineCaseABetaType:
		return soap_in_ns2__HyperfineCaseABetaType(soap, NULL, NULL, "ns2:HyperfineCaseABetaType");
	case SOAP_TYPE_ns2__HyperfineCaseAAlphaType:
		return soap_in_ns2__HyperfineCaseAAlphaType(soap, NULL, NULL, "ns2:HyperfineCaseAAlphaType");
	case SOAP_TYPE_ns2__HundCaseBType:
		return soap_in_ns2__HundCaseBType(soap, NULL, NULL, "ns2:HundCaseBType");
	case SOAP_TYPE_ns2__HundCaseAType:
		return soap_in_ns2__HundCaseAType(soap, NULL, NULL, "ns2:HundCaseAType");
	case SOAP_TYPE_ns2__LinearElecCouplingType:
		return soap_in_ns2__LinearElecCouplingType(soap, NULL, NULL, "ns2:LinearElecCouplingType");
	case SOAP_TYPE_ns2__LinearNoElecHyperFType:
		return soap_in_ns2__LinearNoElecHyperFType(soap, NULL, NULL, "ns2:LinearNoElecHyperFType");
	case SOAP_TYPE_ns2__LinearNoElecNoHyperFType:
		return soap_in_ns2__LinearNoElecNoHyperFType(soap, NULL, NULL, "ns2:LinearNoElecNoHyperFType");
	case SOAP_TYPE_ns2__VibrationalQuantumNumbersType:
		return soap_in_ns2__VibrationalQuantumNumbersType(soap, NULL, NULL, "ns2:VibrationalQuantumNumbersType");
	case SOAP_TYPE_ns2__VibrationalHomeType:
		return soap_in_ns2__VibrationalHomeType(soap, NULL, NULL, "ns2:VibrationalHomeType");
	case SOAP_TYPE_ns2__VibrationalCharacterisationType:
		return soap_in_ns2__VibrationalCharacterisationType(soap, NULL, NULL, "ns2:VibrationalCharacterisationType");
	case SOAP_TYPE_ns2__VibrationalComponentType:
		return soap_in_ns2__VibrationalComponentType(soap, NULL, NULL, "ns2:VibrationalComponentType");
	case SOAP_TYPE_ns2__TotalSpinMomentumSType:
		return soap_in_ns2__TotalSpinMomentumSType(soap, NULL, NULL, "ns2:TotalSpinMomentumSType");
	case SOAP_TYPE_ns2__SymbolType:
		return soap_in_ns2__SymbolType(soap, NULL, NULL, "ns2:SymbolType");
	case SOAP_TYPE_ns2__StateEnergyType:
		return soap_in_ns2__StateEnergyType(soap, NULL, NULL, "ns2:StateEnergyType");
	case SOAP_TYPE_ns2__SimpleSymbolType:
		return soap_in_ns2__SimpleSymbolType(soap, NULL, NULL, "ns2:SimpleSymbolType");
	case SOAP_TYPE_ns2__MagneticQuantumNumberType:
		return soap_in_ns2__MagneticQuantumNumberType(soap, NULL, NULL, "ns2:MagneticQuantumNumberType");
	case SOAP_TYPE_ns2__MolecularQuantumNumberType:
		return soap_in_ns2__MolecularQuantumNumberType(soap, NULL, NULL, "ns2:MolecularQuantumNumberType");
	case SOAP_TYPE_ns2__RoVibronicSplittingType:
		return soap_in_ns2__RoVibronicSplittingType(soap, NULL, NULL, "ns2:RoVibronicSplittingType");
	case SOAP_TYPE_ns2__PseudoStatisticalWeightType:
		return soap_in_ns2__PseudoStatisticalWeightType(soap, NULL, NULL, "ns2:PseudoStatisticalWeightType");
	case SOAP_TYPE_ns2__RotationalHomeType:
		return soap_in_ns2__RotationalHomeType(soap, NULL, NULL, "ns2:RotationalHomeType");
	case SOAP_TYPE_ns2__RotationalComponentType:
		return soap_in_ns2__RotationalComponentType(soap, NULL, NULL, "ns2:RotationalComponentType");
	case SOAP_TYPE_ns2__RotationalCharacterisationType:
		return soap_in_ns2__RotationalCharacterisationType(soap, NULL, NULL, "ns2:RotationalCharacterisationType");
	case SOAP_TYPE_ns2__NonLinearPolyatomicType:
		return soap_in_ns2__NonLinearPolyatomicType(soap, NULL, NULL, "ns2:NonLinearPolyatomicType");
	case SOAP_TYPE_ns2__MoleculesType:
		return soap_in_ns2__MoleculesType(soap, NULL, NULL, "ns2:MoleculesType");
	case SOAP_TYPE_ns2__MoleculeNuclearSpinsType:
		return soap_in_ns2__MoleculeNuclearSpinsType(soap, NULL, NULL, "ns2:MoleculeNuclearSpinsType");
	case SOAP_TYPE_ns2__MoleculeType:
		return soap_in_ns2__MoleculeType(soap, NULL, NULL, "ns2:MoleculeType");
	case SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType:
		return soap_in_ns2__MolecularStateCharacterisation_oldType(soap, NULL, NULL, "ns2:MolecularStateCharacterisation-oldType");
	case SOAP_TYPE_ns2__MolecularStateCharacterisationType:
		return soap_in_ns2__MolecularStateCharacterisationType(soap, NULL, NULL, "ns2:MolecularStateCharacterisationType");
	case SOAP_TYPE_ns2__MolecularStateType:
		return soap_in_ns2__MolecularStateType(soap, NULL, NULL, "ns2:MolecularStateType");
	case SOAP_TYPE_ns2__MolecularPropertiesType:
		return soap_in_ns2__MolecularPropertiesType(soap, NULL, NULL, "ns2:MolecularPropertiesType");
	case SOAP_TYPE_ns2__MolecularProjectionType:
		return soap_in_ns2__MolecularProjectionType(soap, NULL, NULL, "ns2:MolecularProjectionType");
	case SOAP_TYPE_ns2__MolecularChemicalSpeciesType:
		return soap_in_ns2__MolecularChemicalSpeciesType(soap, NULL, NULL, "ns2:MolecularChemicalSpeciesType");
	case SOAP_TYPE_ns2__ElectronicHomeType:
		return soap_in_ns2__ElectronicHomeType(soap, NULL, NULL, "ns2:ElectronicHomeType");
	case SOAP_TYPE_ns2__ElectronicComponentType:
		return soap_in_ns2__ElectronicComponentType(soap, NULL, NULL, "ns2:ElectronicComponentType");
	case SOAP_TYPE_ns2__ElectronicCharacterisationType:
		return soap_in_ns2__ElectronicCharacterisationType(soap, NULL, NULL, "ns2:ElectronicCharacterisationType");
	case SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType:
		return soap_in_ns2__DiatomAndLinearPolyatomicType(soap, NULL, NULL, "ns2:DiatomAndLinearPolyatomicType");
	case SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType:
		return soap_in_ns2__ComplexMolecularQuantumNumberType(soap, NULL, NULL, "ns2:ComplexMolecularQuantumNumberType");
	case SOAP_TYPE_ns2__CentralSymbolType:
		return soap_in_ns2__CentralSymbolType(soap, NULL, NULL, "ns2:CentralSymbolType");
	case SOAP_TYPE_ns2__C2SymmetriesType:
		return soap_in_ns2__C2SymmetriesType(soap, NULL, NULL, "ns2:C2SymmetriesType");
	case SOAP_TYPE_ns2__BondArrayType:
		return soap_in_ns2__BondArrayType(soap, NULL, NULL, "ns2:BondArrayType");
	case SOAP_TYPE_ns2__BondType:
		return soap_in_ns2__BondType(soap, NULL, NULL, "ns2:BondType");
	case SOAP_TYPE_ns2__AtomNType:
		return soap_in_ns2__AtomNType(soap, NULL, NULL, "ns2:AtomNType");
	case SOAP_TYPE_ns2__AtomArrayType:
		return soap_in_ns2__AtomArrayType(soap, NULL, NULL, "ns2:AtomArrayType");
	case SOAP_TYPE_ns2__HinderedMotionType:
		return soap_in_ns2__HinderedMotionType(soap, NULL, NULL, "ns2:HinderedMotionType");
	case SOAP_TYPE_ns2__AsymmetricProjectionType:
		return soap_in_ns2__AsymmetricProjectionType(soap, NULL, NULL, "ns2:AsymmetricProjectionType");
	case SOAP_TYPE_ns2__SuperShellType:
		return soap_in_ns2__SuperShellType(soap, NULL, NULL, "ns2:SuperShellType");
	case SOAP_TYPE_ns2__SuperConfigurationType:
		return soap_in_ns2__SuperConfigurationType(soap, NULL, NULL, "ns2:SuperConfigurationType");
	case SOAP_TYPE_ns2__ShellType:
		return soap_in_ns2__ShellType(soap, NULL, NULL, "ns2:ShellType");
	case SOAP_TYPE_ns2__ShellPairType:
		return soap_in_ns2__ShellPairType(soap, NULL, NULL, "ns2:ShellPairType");
	case SOAP_TYPE_ns2__ShellsType:
		return soap_in_ns2__ShellsType(soap, NULL, NULL, "ns2:ShellsType");
	case SOAP_TYPE_ns2__ConfigurationType:
		return soap_in_ns2__ConfigurationType(soap, NULL, NULL, "ns2:ConfigurationType");
	case SOAP_TYPE_ns2__AtomicQuantumNumbersType:
		return soap_in_ns2__AtomicQuantumNumbersType(soap, NULL, NULL, "ns2:AtomicQuantumNumbersType");
	case SOAP_TYPE_ns2__AtomicComponentType:
		return soap_in_ns2__AtomicComponentType(soap, NULL, NULL, "ns2:AtomicComponentType");
	case SOAP_TYPE_ns2__AtomicCoreType:
		return soap_in_ns2__AtomicCoreType(soap, NULL, NULL, "ns2:AtomicCoreType");
	case SOAP_TYPE_ns2__AtomicCompositionType:
		return soap_in_ns2__AtomicCompositionType(soap, NULL, NULL, "ns2:AtomicCompositionType");
	case SOAP_TYPE_ns2__AtomicNumericalDataType:
		return soap_in_ns2__AtomicNumericalDataType(soap, NULL, NULL, "ns2:AtomicNumericalDataType");
	case SOAP_TYPE_ns2__AtomicStateType:
		return soap_in_ns2__AtomicStateType(soap, NULL, NULL, "ns2:AtomicStateType");
	case SOAP_TYPE_ns2__IonStateType:
		return soap_in_ns2__IonStateType(soap, NULL, NULL, "ns2:IonStateType");
	case SOAP_TYPE_ns2__IsotopeParametersType:
		return soap_in_ns2__IsotopeParametersType(soap, NULL, NULL, "ns2:IsotopeParametersType");
	case SOAP_TYPE_ns2__IsotopeType:
		return soap_in_ns2__IsotopeType(soap, NULL, NULL, "ns2:IsotopeType");
	case SOAP_TYPE_ns2__AtomType:
		return soap_in_ns2__AtomType(soap, NULL, NULL, "ns2:AtomType");
	case SOAP_TYPE_ns2__AtomsType:
		return soap_in_ns2__AtomsType(soap, NULL, NULL, "ns2:AtomsType");
	case SOAP_TYPE_ns2__FunctionType:
		return soap_in_ns2__FunctionType(soap, NULL, NULL, "ns2:FunctionType");
	case SOAP_TYPE_ns2__FunctionsType:
		return soap_in_ns2__FunctionsType(soap, NULL, NULL, "ns2:FunctionsType");
	case SOAP_TYPE_ns2__MethodType:
		return soap_in_ns2__MethodType(soap, NULL, NULL, "ns2:MethodType");
	case SOAP_TYPE_ns2__MethodsType:
		return soap_in_ns2__MethodsType(soap, NULL, NULL, "ns2:MethodsType");
	case SOAP_TYPE_ns2__EditorsType:
		return soap_in_ns2__EditorsType(soap, NULL, NULL, "ns2:EditorsType");
	case SOAP_TYPE_ns2__AuthorsType:
		return soap_in_ns2__AuthorsType(soap, NULL, NULL, "ns2:AuthorsType");
	case SOAP_TYPE_ns2__SourceType:
		return soap_in_ns2__SourceType(soap, NULL, NULL, "ns2:SourceType");
	case SOAP_TYPE_ns2__SourcesType:
		return soap_in_ns2__SourcesType(soap, NULL, NULL, "ns2:SourcesType");
	case SOAP_TYPE_ns2__AuthorType:
		return soap_in_ns2__AuthorType(soap, NULL, NULL, "ns2:AuthorType");
	case SOAP_TYPE_ns2__ProductsType:
		return soap_in_ns2__ProductsType(soap, NULL, NULL, "ns2:ProductsType");
	case SOAP_TYPE_ns2__ReactantsType:
		return soap_in_ns2__ReactantsType(soap, NULL, NULL, "ns2:ReactantsType");
	case SOAP_TYPE_ns2__TermType:
		return soap_in_ns2__TermType(soap, NULL, NULL, "ns2:TermType");
	case SOAP_TYPE_ns2__OrbitalAngularMomentumType:
		return soap_in_ns2__OrbitalAngularMomentumType(soap, NULL, NULL, "ns2:OrbitalAngularMomentumType");
	case SOAP_TYPE_ns2__MixingCoefficientType:
		return soap_in_ns2__MixingCoefficientType(soap, NULL, NULL, "ns2:MixingCoefficientType");
	case SOAP_TYPE_ns2__LSCouplingType:
		return soap_in_ns2__LSCouplingType(soap, NULL, NULL, "ns2:LSCouplingType");
	case SOAP_TYPE_ns2__LKCouplingType:
		return soap_in_ns2__LKCouplingType(soap, NULL, NULL, "ns2:LKCouplingType");
	case SOAP_TYPE_ns2__jKCouplingType:
		return soap_in_ns2__jKCouplingType(soap, NULL, NULL, "ns2:jKCouplingType");
	case SOAP_TYPE_ns2__jjCouplingType:
		return soap_in_ns2__jjCouplingType(soap, NULL, NULL, "ns2:jjCouplingType");
	case SOAP_TYPE_ns2__ValueType:
		return soap_in_ns2__ValueType(soap, NULL, NULL, "ns2:ValueType");
	case SOAP_TYPE_ns2__ParameterType:
		return soap_in_ns2__ParameterType(soap, NULL, NULL, "ns2:ParameterType");
	case SOAP_TYPE_ns2__ParametersType:
		return soap_in_ns2__ParametersType(soap, NULL, NULL, "ns2:ParametersType");
	case SOAP_TYPE_ns2__ArgumentType:
		return soap_in_ns2__ArgumentType(soap, NULL, NULL, "ns2:ArgumentType");
	case SOAP_TYPE_ns2__ArgumentsType:
		return soap_in_ns2__ArgumentsType(soap, NULL, NULL, "ns2:ArgumentsType");
	case SOAP_TYPE_ns2__ExpressionType:
		return soap_in_ns2__ExpressionType(soap, NULL, NULL, "ns2:ExpressionType");
	case SOAP_TYPE_ns2__FitValidityLimitsType:
		return soap_in_ns2__FitValidityLimitsType(soap, NULL, NULL, "ns2:FitValidityLimitsType");
	case SOAP_TYPE_ns2__FitParametersType:
		return soap_in_ns2__FitParametersType(soap, NULL, NULL, "ns2:FitParametersType");
	case SOAP_TYPE_ns2__FitDataType:
		return soap_in_ns2__FitDataType(soap, NULL, NULL, "ns2:FitDataType");
	case SOAP_TYPE_ns2__TabulatedDataType:
		return soap_in_ns2__TabulatedDataType(soap, NULL, NULL, "ns2:TabulatedDataType");
	case SOAP_TYPE_ns2__DataXYType:
		return soap_in_ns2__DataXYType(soap, NULL, NULL, "ns2:DataXYType");
	case SOAP_TYPE_ns2__DataTableType:
		return soap_in_ns2__DataTableType(soap, NULL, NULL, "ns2:DataTableType");
	case SOAP_TYPE_ns2__DataSetsType:
		return soap_in_ns2__DataSetsType(soap, NULL, NULL, "ns2:DataSetsType");
	case SOAP_TYPE_ns2__DataSetType:
		return soap_in_ns2__DataSetType(soap, NULL, NULL, "ns2:DataSetType");
	case SOAP_TYPE_ns2__DataType:
		return soap_in_ns2__DataType(soap, NULL, NULL, "ns2:DataType");
	case SOAP_TYPE_ns2__ChemicalElementType:
		return soap_in_ns2__ChemicalElementType(soap, NULL, NULL, "ns2:ChemicalElementType");
	case SOAP_TYPE_ns2__PrimaryType:
		return soap_in_ns2__PrimaryType(soap, NULL, NULL, "ns2:PrimaryType");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__gYear:
		return soap_in_xsd__gYear(soap, NULL, NULL, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__IDREFS:
		return soap_in_xsd__IDREFS(soap, NULL, NULL, "xsd:IDREFS");
	case SOAP_TYPE_xsd__IDREF:
		return soap_in_xsd__IDREF(soap, NULL, NULL, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_xsd__DataTableType:
		return soap_in_xsd__DataTableType(soap, NULL, NULL, "xsd:DataTableType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns2__getS:
		return soap_in_ns2__getS(soap, NULL, NULL, "ns2:getS");
	case SOAP_TYPE_ns2__getSResponse:
		return soap_in_ns2__getSResponse(soap, NULL, NULL, "ns2:getSResponse");
	case SOAP_TYPE_PointerTons2__DataSetsType:
		return soap_in_PointerTons2__DataSetsType(soap, NULL, NULL, "ns2:DataSetsType");
	case SOAP_TYPE_PointerTons2__ProductsType:
		return soap_in_PointerTons2__ProductsType(soap, NULL, NULL, "ns2:ProductsType");
	case SOAP_TYPE_PointerTons2__ReactantsType:
		return soap_in_PointerTons2__ReactantsType(soap, NULL, NULL, "ns2:ReactantsType");
	case SOAP_TYPE_PointerTons2__CollisionalProcessClassType:
		return soap_in_PointerTons2__CollisionalProcessClassType(soap, NULL, NULL, "ns2:CollisionalProcessClassType");
	case SOAP_TYPE_PointerTons2__CollisionalTransitionType:
		return soap_in_PointerTons2__CollisionalTransitionType(soap, NULL, NULL, "ns2:CollisionalTransitionType");
	case SOAP_TYPE_PointerTons2__NonRadiativeTransitionType:
		return soap_in_PointerTons2__NonRadiativeTransitionType(soap, NULL, NULL, "ns2:NonRadiativeTransitionType");
	case SOAP_TYPE_PointerTons2__WavelengthWavenumberType:
		return soap_in_PointerTons2__WavelengthWavenumberType(soap, NULL, NULL, "ns2:WavelengthWavenumberType");
	case SOAP_TYPE_PointerTons2__MultipoleType:
		return soap_in_PointerTons2__MultipoleType(soap, NULL, NULL, "ns2:MultipoleType");
	case SOAP_TYPE_PointerTons2__RadiativeTransitionProbabilityType:
		return soap_in_PointerTons2__RadiativeTransitionProbabilityType(soap, NULL, NULL, "ns2:RadiativeTransitionProbabilityType");
	case SOAP_TYPE_PointerTons2__StateRef:
		return soap_in_PointerTons2__StateRef(soap, NULL, NULL, "ns2:StateRef");
	case SOAP_TYPE_PointerTons2__EnergyWavelengthType:
		return soap_in_PointerTons2__EnergyWavelengthType(soap, NULL, NULL, "ns2:EnergyWavelengthType");
	case SOAP_TYPE_PointerTons2__RadiativeTransitionType:
		return soap_in_PointerTons2__RadiativeTransitionType(soap, NULL, NULL, "ns2:RadiativeTransitionType");
	case SOAP_TYPE_PointerTons2__MaterialComponentType:
		return soap_in_PointerTons2__MaterialComponentType(soap, NULL, NULL, "ns2:MaterialComponentType");
	case SOAP_TYPE_PointerTons2__SolidType:
		return soap_in_PointerTons2__SolidType(soap, NULL, NULL, "ns2:SolidType");
	case SOAP_TYPE_PointerTons2__MaterialType:
		return soap_in_PointerTons2__MaterialType(soap, NULL, NULL, "ns2:MaterialType");
	case SOAP_TYPE_PointerTons2__SimpleSymbolType:
		return soap_in_PointerTons2__SimpleSymbolType(soap, NULL, NULL, "ns2:SimpleSymbolType");
	case SOAP_TYPE_PointerTons2__MoleculeType:
		return soap_in_PointerTons2__MoleculeType(soap, NULL, NULL, "ns2:MoleculeType");
	case SOAP_TYPE_PointerTons2__MolecularStateType:
		return soap_in_PointerTons2__MolecularStateType(soap, NULL, NULL, "ns2:MolecularStateType");
	case SOAP_TYPE_PointerTons2__MolecularChemicalSpeciesType:
		return soap_in_PointerTons2__MolecularChemicalSpeciesType(soap, NULL, NULL, "ns2:MolecularChemicalSpeciesType");
	case SOAP_TYPE_PointerTons2__ElectronicHomeType:
		return soap_in_PointerTons2__ElectronicHomeType(soap, NULL, NULL, "ns2:ElectronicHomeType");
	case SOAP_TYPE_PointerTons2__MolecularStateCharacterisationType:
		return soap_in_PointerTons2__MolecularStateCharacterisationType(soap, NULL, NULL, "ns2:MolecularStateCharacterisationType");
	case SOAP_TYPE_PointerToxsd__IDREF:
		return soap_in_PointerToxsd__IDREF(soap, NULL, NULL, "xsd:IDREF");
	case SOAP_TYPE_PointerTons2__ModesListType:
		return soap_in_PointerTons2__ModesListType(soap, NULL, NULL, "ns2:ModesListType");
	case SOAP_TYPE_PointerTons2__AtomicComponentType:
		return soap_in_PointerTons2__AtomicComponentType(soap, NULL, NULL, "ns2:AtomicComponentType");
	case SOAP_TYPE_PointerTons2__AtomicCompositionType:
		return soap_in_PointerTons2__AtomicCompositionType(soap, NULL, NULL, "ns2:AtomicCompositionType");
	case SOAP_TYPE_PointerTons2__AtomicQuantumNumbersType:
		return soap_in_PointerTons2__AtomicQuantumNumbersType(soap, NULL, NULL, "ns2:AtomicQuantumNumbersType");
	case SOAP_TYPE_PointerTons2__AtomicNumericalDataType:
		return soap_in_PointerTons2__AtomicNumericalDataType(soap, NULL, NULL, "ns2:AtomicNumericalDataType");
	case SOAP_TYPE_PointerTons2__AtomicStateType:
		return soap_in_PointerTons2__AtomicStateType(soap, NULL, NULL, "ns2:AtomicStateType");
	case SOAP_TYPE_PointerTons2__IsotopeType:
		return soap_in_PointerTons2__IsotopeType(soap, NULL, NULL, "ns2:IsotopeType");
	case SOAP_TYPE_PointerTons2__AtomType:
		return soap_in_PointerTons2__AtomType(soap, NULL, NULL, "ns2:AtomType");
	case SOAP_TYPE_PointerTons2__ParametersType:
		return soap_in_PointerTons2__ParametersType(soap, NULL, NULL, "ns2:ParametersType");
	case SOAP_TYPE_PointerTons2__ArgumentsType:
		return soap_in_PointerTons2__ArgumentsType(soap, NULL, NULL, "ns2:ArgumentsType");
	case SOAP_TYPE_PointerTons2__ExpressionType:
		return soap_in_PointerTons2__ExpressionType(soap, NULL, NULL, "ns2:ExpressionType");
	case SOAP_TYPE_PointerTons2__FitParametersType:
		return soap_in_PointerTons2__FitParametersType(soap, NULL, NULL, "ns2:FitParametersType");
	case SOAP_TYPE_PointerTons2__FitValidityLimitsType:
		return soap_in_PointerTons2__FitValidityLimitsType(soap, NULL, NULL, "ns2:FitValidityLimitsType");
	case SOAP_TYPE_PointerTons2__ReferenceFrameType:
		return soap_in_PointerTons2__ReferenceFrameType(soap, NULL, NULL, "ns2:ReferenceFrameType");
	case SOAP_TYPE_PointerTons2__DataXYType:
		return soap_in_PointerTons2__DataXYType(soap, NULL, NULL, "ns2:DataXYType");
	case SOAP_TYPE_PointerTons2__TabulatedDataType:
		return soap_in_PointerTons2__TabulatedDataType(soap, NULL, NULL, "ns2:TabulatedDataType");
	case SOAP_TYPE_PointerTons2__FitDataType:
		return soap_in_PointerTons2__FitDataType(soap, NULL, NULL, "ns2:FitDataType");
	case SOAP_TYPE_PointerTons2__ValueType:
		return soap_in_PointerTons2__ValueType(soap, NULL, NULL, "ns2:ValueType");
	case SOAP_TYPE_PointerTons2__ParticlesType:
		return soap_in_PointerTons2__ParticlesType(soap, NULL, NULL, "ns2:ParticlesType");
	case SOAP_TYPE_PointerTons2__SolidsType:
		return soap_in_PointerTons2__SolidsType(soap, NULL, NULL, "ns2:SolidsType");
	case SOAP_TYPE_PointerTons2__MoleculesType:
		return soap_in_PointerTons2__MoleculesType(soap, NULL, NULL, "ns2:MoleculesType");
	case SOAP_TYPE_PointerTons2__AtomsType:
		return soap_in_PointerTons2__AtomsType(soap, NULL, NULL, "ns2:AtomsType");
	case SOAP_TYPE_PointerTons2__CollisionsType:
		return soap_in_PointerTons2__CollisionsType(soap, NULL, NULL, "ns2:CollisionsType");
	case SOAP_TYPE_PointerTons2__NonRadiativeType:
		return soap_in_PointerTons2__NonRadiativeType(soap, NULL, NULL, "ns2:NonRadiativeType");
	case SOAP_TYPE_PointerTons2__RadiativeType:
		return soap_in_PointerTons2__RadiativeType(soap, NULL, NULL, "ns2:RadiativeType");
	case SOAP_TYPE_PointerTons2__FunctionsType:
		return soap_in_PointerTons2__FunctionsType(soap, NULL, NULL, "ns2:FunctionsType");
	case SOAP_TYPE_PointerTons2__MethodsType:
		return soap_in_PointerTons2__MethodsType(soap, NULL, NULL, "ns2:MethodsType");
	case SOAP_TYPE_PointerTons2__SourcesType:
		return soap_in_PointerTons2__SourcesType(soap, NULL, NULL, "ns2:SourcesType");
	case SOAP_TYPE_PointerTons2__ProcessesType:
		return soap_in_PointerTons2__ProcessesType(soap, NULL, NULL, "ns2:ProcessesType");
	case SOAP_TYPE_PointerTons2__StatesType:
		return soap_in_PointerTons2__StatesType(soap, NULL, NULL, "ns2:StatesType");
	case SOAP_TYPE_PointerTons2__IAEACodeType:
		return soap_in_PointerTons2__IAEACodeType(soap, NULL, NULL, "ns2:IAEACodeType");
	case SOAP_TYPE_PointerTons2__MaterialCompositionType:
		return soap_in_PointerTons2__MaterialCompositionType(soap, NULL, NULL, "ns2:MaterialCompositionType");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__ChemicalElementType:
		return soap_in_PointerTons2__ChemicalElementType(soap, NULL, NULL, "ns2:ChemicalElementType");
	case SOAP_TYPE_PointerTons2__ParticleNameType:
		return soap_in_PointerTons2__ParticleNameType(soap, NULL, NULL, "ns2:ParticleNameType");
	case SOAP_TYPE_PointerTons2__ParticlePropertiesType:
		return soap_in_PointerTons2__ParticlePropertiesType(soap, NULL, NULL, "ns2:ParticlePropertiesType");
	case SOAP_TYPE_PointerTons2__ParticleType:
		return soap_in_PointerTons2__ParticleType(soap, NULL, NULL, "ns2:ParticleType");
	case SOAP_TYPE_PointerTons2__C2SymmetriesType:
		return soap_in_PointerTons2__C2SymmetriesType(soap, NULL, NULL, "ns2:C2SymmetriesType");
	case SOAP_TYPE_PointerTons2__RoVibronicSplittingType:
		return soap_in_PointerTons2__RoVibronicSplittingType(soap, NULL, NULL, "ns2:RoVibronicSplittingType");
	case SOAP_TYPE_PointerTons2__MolecularProjectionType:
		return soap_in_PointerTons2__MolecularProjectionType(soap, NULL, NULL, "ns2:MolecularProjectionType");
	case SOAP_TYPE_PointerTons2__HyperfineCouplingBType:
		return soap_in_PointerTons2__HyperfineCouplingBType(soap, NULL, NULL, "ns2:HyperfineCouplingBType");
	case SOAP_TYPE_PointerTons2__HundCaseBType:
		return soap_in_PointerTons2__HundCaseBType(soap, NULL, NULL, "ns2:HundCaseBType");
	case SOAP_TYPE_PointerTons2__HyperfineCaseABetaType:
		return soap_in_PointerTons2__HyperfineCaseABetaType(soap, NULL, NULL, "ns2:HyperfineCaseABetaType");
	case SOAP_TYPE_PointerTons2__HyperfineCaseAAlphaType:
		return soap_in_PointerTons2__HyperfineCaseAAlphaType(soap, NULL, NULL, "ns2:HyperfineCaseAAlphaType");
	case SOAP_TYPE_PointerTons2__HundCaseAType:
		return soap_in_PointerTons2__HundCaseAType(soap, NULL, NULL, "ns2:HundCaseAType");
	case SOAP_TYPE_PointerTons2__EfSymmetryType:
		return soap_in_PointerTons2__EfSymmetryType(soap, NULL, NULL, "ns2:EfSymmetryType");
	case SOAP_TYPE_PointerTons2__HyperfineQuantumNumbersType:
		return soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, NULL, NULL, "ns2:HyperfineQuantumNumbersType");
	case SOAP_TYPE_PointerTons2__ComplexMolecularQuantumNumberType:
		return soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, NULL, NULL, "ns2:ComplexMolecularQuantumNumberType");
	case SOAP_TYPE_PointerTons2__VibrationalComponentType:
		return soap_in_PointerTons2__VibrationalComponentType(soap, NULL, NULL, "ns2:VibrationalComponentType");
	case SOAP_TYPE_PointerTons2__RotationalHomeType:
		return soap_in_PointerTons2__RotationalHomeType(soap, NULL, NULL, "ns2:RotationalHomeType");
	case SOAP_TYPE_PointerTons2__VibrationalQuantumNumbersType:
		return soap_in_PointerTons2__VibrationalQuantumNumbersType(soap, NULL, NULL, "ns2:VibrationalQuantumNumbersType");
	case SOAP_TYPE_PointerTons2__VibrationalCharacterisationType:
		return soap_in_PointerTons2__VibrationalCharacterisationType(soap, NULL, NULL, "ns2:VibrationalCharacterisationType");
	case SOAP_TYPE_PointerTons2__CentralSymbolType:
		return soap_in_PointerTons2__CentralSymbolType(soap, NULL, NULL, "ns2:CentralSymbolType");
	case SOAP_TYPE_PointerTons2__RotationalComponentType:
		return soap_in_PointerTons2__RotationalComponentType(soap, NULL, NULL, "ns2:RotationalComponentType");
	case SOAP_TYPE_PointerTons2__RotationalCharacterisationType:
		return soap_in_PointerTons2__RotationalCharacterisationType(soap, NULL, NULL, "ns2:RotationalCharacterisationType");
	case SOAP_TYPE_PointerTons2__NonLinearPolyatomicType:
		return soap_in_PointerTons2__NonLinearPolyatomicType(soap, NULL, NULL, "ns2:NonLinearPolyatomicType");
	case SOAP_TYPE_PointerTons2__DiatomAndLinearPolyatomicType:
		return soap_in_PointerTons2__DiatomAndLinearPolyatomicType(soap, NULL, NULL, "ns2:DiatomAndLinearPolyatomicType");
	case SOAP_TYPE_PointerTons2__PermutationSymmetryType:
		return soap_in_PointerTons2__PermutationSymmetryType(soap, NULL, NULL, "ns2:PermutationSymmetryType");
	case SOAP_TYPE_PointerTons2__NonLinearElecHyperFType:
		return soap_in_PointerTons2__NonLinearElecHyperFType(soap, NULL, NULL, "ns2:NonLinearElecHyperFType");
	case SOAP_TYPE_PointerTons2__NonLinearElecNoHyperFType:
		return soap_in_PointerTons2__NonLinearElecNoHyperFType(soap, NULL, NULL, "ns2:NonLinearElecNoHyperFType");
	case SOAP_TYPE_PointerTons2__NonLinearNoElecHyperFType:
		return soap_in_PointerTons2__NonLinearNoElecHyperFType(soap, NULL, NULL, "ns2:NonLinearNoElecHyperFType");
	case SOAP_TYPE_PointerTons2__NonLinearNoElecNoHyperFType:
		return soap_in_PointerTons2__NonLinearNoElecNoHyperFType(soap, NULL, NULL, "ns2:NonLinearNoElecNoHyperFType");
	case SOAP_TYPE_PointerTons2__BondArrayType:
		return soap_in_PointerTons2__BondArrayType(soap, NULL, NULL, "ns2:BondArrayType");
	case SOAP_TYPE_PointerTons2__AtomArrayType:
		return soap_in_PointerTons2__AtomArrayType(soap, NULL, NULL, "ns2:AtomArrayType");
	case SOAP_TYPE_PointerTons2__PseudoStatisticalWeightType:
		return soap_in_PointerTons2__PseudoStatisticalWeightType(soap, NULL, NULL, "ns2:PseudoStatisticalWeightType");
	case SOAP_TYPE_PointerTons2__StateEnergyType:
		return soap_in_PointerTons2__StateEnergyType(soap, NULL, NULL, "ns2:StateEnergyType");
	case SOAP_TYPE_PointerTons2__CharacterisationType:
		return soap_in_PointerTons2__CharacterisationType(soap, NULL, NULL, "ns2:CharacterisationType");
	case SOAP_TYPE_PointerTons2__DataType:
		return soap_in_PointerTons2__DataType(soap, NULL, NULL, "ns2:DataType");
	case SOAP_TYPE_PointerTons2__HinderedMotionType:
		return soap_in_PointerTons2__HinderedMotionType(soap, NULL, NULL, "ns2:HinderedMotionType");
	case SOAP_TYPE_PointerTons2__AsymmetricProjectionType:
		return soap_in_PointerTons2__AsymmetricProjectionType(soap, NULL, NULL, "ns2:AsymmetricProjectionType");
	case SOAP_TYPE_PointerTons2__MolecularPropertiesType:
		return soap_in_PointerTons2__MolecularPropertiesType(soap, NULL, NULL, "ns2:MolecularPropertiesType");
	case SOAP_TYPE_PointerTons2__MoleculeNuclearSpinsType:
		return soap_in_PointerTons2__MoleculeNuclearSpinsType(soap, NULL, NULL, "ns2:MoleculeNuclearSpinsType");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTons2__ElectronicComponentType:
		return soap_in_PointerTons2__ElectronicComponentType(soap, NULL, NULL, "ns2:ElectronicComponentType");
	case SOAP_TYPE_PointerTons2__VibrationalHomeType:
		return soap_in_PointerTons2__VibrationalHomeType(soap, NULL, NULL, "ns2:VibrationalHomeType");
	case SOAP_TYPE_PointerTons2__ElectronicCharacterisationType:
		return soap_in_PointerTons2__ElectronicCharacterisationType(soap, NULL, NULL, "ns2:ElectronicCharacterisationType");
	case SOAP_TYPE_PointerTons2__ReferencedTextType:
		return soap_in_PointerTons2__ReferencedTextType(soap, NULL, NULL, "ns2:ReferencedTextType");
	case SOAP_TYPE_PointerTons2__SymbolType:
		return soap_in_PointerTons2__SymbolType(soap, NULL, NULL, "ns2:SymbolType");
	case SOAP_TYPE_PointerTons2__LinearElecCouplingType:
		return soap_in_PointerTons2__LinearElecCouplingType(soap, NULL, NULL, "ns2:LinearElecCouplingType");
	case SOAP_TYPE_PointerTons2__LinearNoElecHyperFType:
		return soap_in_PointerTons2__LinearNoElecHyperFType(soap, NULL, NULL, "ns2:LinearNoElecHyperFType");
	case SOAP_TYPE_PointerTons2__LinearNoElecNoHyperFType:
		return soap_in_PointerTons2__LinearNoElecNoHyperFType(soap, NULL, NULL, "ns2:LinearNoElecNoHyperFType");
	case SOAP_TYPE_PointerTons2__BondType:
		return soap_in_PointerTons2__BondType(soap, NULL, NULL, "ns2:BondType");
	case SOAP_TYPE_PointerToxsd__IDREFS:
		return soap_in_PointerToxsd__IDREFS(soap, NULL, NULL, "xsd:IDREFS");
	case SOAP_TYPE_PointerTons2__AtomNType:
		return soap_in_PointerTons2__AtomNType(soap, NULL, NULL, "ns2:AtomNType");
	case SOAP_TYPE_PointerTons2__MolecularQuantumNumberType:
		return soap_in_PointerTons2__MolecularQuantumNumberType(soap, NULL, NULL, "ns2:MolecularQuantumNumberType");
	case SOAP_TYPE_PointerTons2__MagneticQuantumNumberType:
		return soap_in_PointerTons2__MagneticQuantumNumberType(soap, NULL, NULL, "ns2:MagneticQuantumNumberType");
	case SOAP_TYPE_PointerTons2__SuperShellType:
		return soap_in_PointerTons2__SuperShellType(soap, NULL, NULL, "ns2:SuperShellType");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_PointerTons2__ShellPairType:
		return soap_in_PointerTons2__ShellPairType(soap, NULL, NULL, "ns2:ShellPairType");
	case SOAP_TYPE_PointerTons2__ShellType:
		return soap_in_PointerTons2__ShellType(soap, NULL, NULL, "ns2:ShellType");
	case SOAP_TYPE_PointerTons2__ShellsType:
		return soap_in_PointerTons2__ShellsType(soap, NULL, NULL, "ns2:ShellsType");
	case SOAP_TYPE_PointerTons2__AtomicCoreType:
		return soap_in_PointerTons2__AtomicCoreType(soap, NULL, NULL, "ns2:AtomicCoreType");
	case SOAP_TYPE_PointerTons2__AngularMomentumProjectionType:
		return soap_in_PointerTons2__AngularMomentumProjectionType(soap, NULL, NULL, "ns2:AngularMomentumProjectionType");
	case SOAP_TYPE_PointerTons2__ParityType:
		return soap_in_PointerTons2__ParityType(soap, NULL, NULL, "ns2:ParityType");
	case SOAP_TYPE_PointerTons2__MixingCoefficientType:
		return soap_in_PointerTons2__MixingCoefficientType(soap, NULL, NULL, "ns2:MixingCoefficientType");
	case SOAP_TYPE_PointerTons2__SuperConfigurationType:
		return soap_in_PointerTons2__SuperConfigurationType(soap, NULL, NULL, "ns2:SuperConfigurationType");
	case SOAP_TYPE_PointerTons2__TermType:
		return soap_in_PointerTons2__TermType(soap, NULL, NULL, "ns2:TermType");
	case SOAP_TYPE_PointerTons2__ConfigurationType:
		return soap_in_PointerTons2__ConfigurationType(soap, NULL, NULL, "ns2:ConfigurationType");
	case SOAP_TYPE_PointerTons2__IonStateType:
		return soap_in_PointerTons2__IonStateType(soap, NULL, NULL, "ns2:IonStateType");
	case SOAP_TYPE_PointerTons2__IsotopeParametersType:
		return soap_in_PointerTons2__IsotopeParametersType(soap, NULL, NULL, "ns2:IsotopeParametersType");
	case SOAP_TYPE_PointerTons2__FunctionType:
		return soap_in_PointerTons2__FunctionType(soap, NULL, NULL, "ns2:FunctionType");
	case SOAP_TYPE_PointerTo_ns2__functionRef:
		return soap_in_PointerTo_ns2__functionRef(soap, NULL, NULL, "ns2:functionRef");
	case SOAP_TYPE_PointerTons2__MethodType:
		return soap_in_PointerTons2__MethodType(soap, NULL, NULL, "ns2:MethodType");
	case SOAP_TYPE_PointerTons2__AuthorType:
		return soap_in_PointerTons2__AuthorType(soap, NULL, NULL, "ns2:AuthorType");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_in_PointerToxsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_PointerTons2__EditorsType:
		return soap_in_PointerTons2__EditorsType(soap, NULL, NULL, "ns2:EditorsType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_in_PointerToxsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_PointerTons2__AuthorsType:
		return soap_in_PointerTons2__AuthorsType(soap, NULL, NULL, "ns2:AuthorsType");
	case SOAP_TYPE_PointerTons2__SourceType:
		return soap_in_PointerTons2__SourceType(soap, NULL, NULL, "ns2:SourceType");
	case SOAP_TYPE_PointerTons2__LKCouplingType:
		return soap_in_PointerTons2__LKCouplingType(soap, NULL, NULL, "ns2:LKCouplingType");
	case SOAP_TYPE_PointerTons2__jKCouplingType:
		return soap_in_PointerTons2__jKCouplingType(soap, NULL, NULL, "ns2:jKCouplingType");
	case SOAP_TYPE_PointerTons2__jjCouplingType:
		return soap_in_PointerTons2__jjCouplingType(soap, NULL, NULL, "ns2:jjCouplingType");
	case SOAP_TYPE_PointerTons2__LSCouplingType:
		return soap_in_PointerTons2__LSCouplingType(soap, NULL, NULL, "ns2:LSCouplingType");
	case SOAP_TYPE_PointerTons2__OrbitalAngularMomentumSymbolType:
		return soap_in_PointerTons2__OrbitalAngularMomentumSymbolType(soap, NULL, NULL, "ns2:OrbitalAngularMomentumSymbolType");
	case SOAP_TYPE_PointerTo_ns2__LSCouplingType_Seniority:
		return soap_in_PointerTo_ns2__LSCouplingType_Seniority(soap, NULL, NULL, "ns2:LSCouplingType-Seniority");
	case SOAP_TYPE_PointerToxsd__positiveInteger:
		return soap_in_PointerToxsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_PointerTons2__OrbitalAngularMomentumType:
		return soap_in_PointerTons2__OrbitalAngularMomentumType(soap, NULL, NULL, "ns2:OrbitalAngularMomentumType");
	case SOAP_TYPE_PointerTons2__AngularMomentumType:
		return soap_in_PointerTons2__AngularMomentumType(soap, NULL, NULL, "ns2:AngularMomentumType");
	case SOAP_TYPE_PointerTons2__ParameterType:
		return soap_in_PointerTons2__ParameterType(soap, NULL, NULL, "ns2:ParameterType");
	case SOAP_TYPE_PointerTons2__ArgumentType:
		return soap_in_PointerTons2__ArgumentType(soap, NULL, NULL, "ns2:ArgumentType");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTons2__DataTableType:
		return soap_in_PointerTons2__DataTableType(soap, NULL, NULL, "ns2:DataTableType");
	case SOAP_TYPE_PointerTons2__DataListType:
		return soap_in_PointerTons2__DataListType(soap, NULL, NULL, "ns2:DataListType");
	case SOAP_TYPE_PointerTons2__DataSetType:
		return soap_in_PointerTons2__DataSetType(soap, NULL, NULL, "ns2:DataSetType");
	case SOAP_TYPE_PointerTons2__ElementSymbolType:
		return soap_in_PointerTons2__ElementSymbolType(soap, NULL, NULL, "ns2:ElementSymbolType");
	case SOAP_TYPE_PointerTo_ns2__methodRef:
		return soap_in_PointerTo_ns2__methodRef(soap, NULL, NULL, "ns2:methodRef");
	case SOAP_TYPE_PointerTo_ns2__sourceRef:
		return soap_in_PointerTo_ns2__sourceRef(soap, NULL, NULL, "ns2:sourceRef");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:MultipoleType"))
		{	*type = SOAP_TYPE_ns2__MultipoleType;
			return soap_in_ns2__MultipoleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StateRef"))
		{	*type = SOAP_TYPE_ns2__StateRef;
			return soap_in_ns2__StateRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OrbitalAngularMomentumSymbolType"))
		{	*type = SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType;
			return soap_in_ns2__OrbitalAngularMomentumSymbolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PrincipalQuantumNumberType"))
		{	*type = SOAP_TYPE_ns2__PrincipalQuantumNumberType;
			return soap_in_ns2__PrincipalQuantumNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ElementSymbolType"))
		{	*type = SOAP_TYPE_ns2__ElementSymbolType;
			return soap_in_ns2__ElementSymbolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AngularMomentumType"))
		{	*type = SOAP_TYPE_ns2__AngularMomentumType;
			return soap_in_ns2__AngularMomentumType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AngularMomentumProjectionType"))
		{	*type = SOAP_TYPE_ns2__AngularMomentumProjectionType;
			return soap_in_ns2__AngularMomentumProjectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataListType"))
		{	*type = SOAP_TYPE_ns2__DataListType;
			return soap_in_ns2__DataListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StatesType"))
		{	*type = SOAP_TYPE_ns2__StatesType;
			return soap_in_ns2__StatesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ProcessesType"))
		{	*type = SOAP_TYPE_ns2__ProcessesType;
			return soap_in_ns2__ProcessesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:XSAMSDataType"))
		{	*type = SOAP_TYPE_ns2__XSAMSDataType;
			return soap_in_ns2__XSAMSDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CollisionalProcessClassType"))
		{	*type = SOAP_TYPE_ns2__CollisionalProcessClassType;
			return soap_in_ns2__CollisionalProcessClassType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CollisionalTransitionType"))
		{	*type = SOAP_TYPE_ns2__CollisionalTransitionType;
			return soap_in_ns2__CollisionalTransitionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CollisionsType"))
		{	*type = SOAP_TYPE_ns2__CollisionsType;
			return soap_in_ns2__CollisionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonRadiativeTransitionType"))
		{	*type = SOAP_TYPE_ns2__NonRadiativeTransitionType;
			return soap_in_ns2__NonRadiativeTransitionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonRadiativeType"))
		{	*type = SOAP_TYPE_ns2__NonRadiativeType;
			return soap_in_ns2__NonRadiativeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EnergyWavelengthType"))
		{	*type = SOAP_TYPE_ns2__EnergyWavelengthType;
			return soap_in_ns2__EnergyWavelengthType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WavelengthWavenumberType"))
		{	*type = SOAP_TYPE_ns2__WavelengthWavenumberType;
			return soap_in_ns2__WavelengthWavenumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RadiativeTransitionProbabilityType"))
		{	*type = SOAP_TYPE_ns2__RadiativeTransitionProbabilityType;
			return soap_in_ns2__RadiativeTransitionProbabilityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RadiativeTransitionType"))
		{	*type = SOAP_TYPE_ns2__RadiativeTransitionType;
			return soap_in_ns2__RadiativeTransitionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RadiativeType"))
		{	*type = SOAP_TYPE_ns2__RadiativeType;
			return soap_in_ns2__RadiativeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MaterialCompositionType"))
		{	*type = SOAP_TYPE_ns2__MaterialCompositionType;
			return soap_in_ns2__MaterialCompositionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MaterialType"))
		{	*type = SOAP_TYPE_ns2__MaterialType;
			return soap_in_ns2__MaterialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MaterialComponentType"))
		{	*type = SOAP_TYPE_ns2__MaterialComponentType;
			return soap_in_ns2__MaterialComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SolidsType"))
		{	*type = SOAP_TYPE_ns2__SolidsType;
			return soap_in_ns2__SolidsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SolidType"))
		{	*type = SOAP_TYPE_ns2__SolidType;
			return soap_in_ns2__SolidType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParticlePropertiesType"))
		{	*type = SOAP_TYPE_ns2__ParticlePropertiesType;
			return soap_in_ns2__ParticlePropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParticleType"))
		{	*type = SOAP_TYPE_ns2__ParticleType;
			return soap_in_ns2__ParticleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParticlesType"))
		{	*type = SOAP_TYPE_ns2__ParticlesType;
			return soap_in_ns2__ParticlesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CharacterisationType"))
		{	*type = SOAP_TYPE_ns2__CharacterisationType;
			return soap_in_ns2__CharacterisationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReferencedTextType"))
		{	*type = SOAP_TYPE_ns2__ReferencedTextType;
			return soap_in_ns2__ReferencedTextType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HyperfineQuantumNumbersType"))
		{	*type = SOAP_TYPE_ns2__HyperfineQuantumNumbersType;
			return soap_in_ns2__HyperfineQuantumNumbersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearNoElecHyperFType"))
		{	*type = SOAP_TYPE_ns2__NonLinearNoElecHyperFType;
			return soap_in_ns2__NonLinearNoElecHyperFType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearNoElecNoHyperFType"))
		{	*type = SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType;
			return soap_in_ns2__NonLinearNoElecNoHyperFType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearNoElecType"))
		{	*type = SOAP_TYPE_ns2__NonLinearNoElecType;
			return soap_in_ns2__NonLinearNoElecType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearElecNoHyperFType"))
		{	*type = SOAP_TYPE_ns2__NonLinearElecNoHyperFType;
			return soap_in_ns2__NonLinearElecNoHyperFType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearElecHyperFType"))
		{	*type = SOAP_TYPE_ns2__NonLinearElecHyperFType;
			return soap_in_ns2__NonLinearElecHyperFType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearElecCouplingType"))
		{	*type = SOAP_TYPE_ns2__NonLinearElecCouplingType;
			return soap_in_ns2__NonLinearElecCouplingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HyperfineCouplingBType"))
		{	*type = SOAP_TYPE_ns2__HyperfineCouplingBType;
			return soap_in_ns2__HyperfineCouplingBType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HyperfineCaseABetaType"))
		{	*type = SOAP_TYPE_ns2__HyperfineCaseABetaType;
			return soap_in_ns2__HyperfineCaseABetaType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HyperfineCaseAAlphaType"))
		{	*type = SOAP_TYPE_ns2__HyperfineCaseAAlphaType;
			return soap_in_ns2__HyperfineCaseAAlphaType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HundCaseBType"))
		{	*type = SOAP_TYPE_ns2__HundCaseBType;
			return soap_in_ns2__HundCaseBType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HundCaseAType"))
		{	*type = SOAP_TYPE_ns2__HundCaseAType;
			return soap_in_ns2__HundCaseAType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LinearElecCouplingType"))
		{	*type = SOAP_TYPE_ns2__LinearElecCouplingType;
			return soap_in_ns2__LinearElecCouplingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LinearNoElecHyperFType"))
		{	*type = SOAP_TYPE_ns2__LinearNoElecHyperFType;
			return soap_in_ns2__LinearNoElecHyperFType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LinearNoElecNoHyperFType"))
		{	*type = SOAP_TYPE_ns2__LinearNoElecNoHyperFType;
			return soap_in_ns2__LinearNoElecNoHyperFType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VibrationalQuantumNumbersType"))
		{	*type = SOAP_TYPE_ns2__VibrationalQuantumNumbersType;
			return soap_in_ns2__VibrationalQuantumNumbersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VibrationalHomeType"))
		{	*type = SOAP_TYPE_ns2__VibrationalHomeType;
			return soap_in_ns2__VibrationalHomeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VibrationalCharacterisationType"))
		{	*type = SOAP_TYPE_ns2__VibrationalCharacterisationType;
			return soap_in_ns2__VibrationalCharacterisationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VibrationalComponentType"))
		{	*type = SOAP_TYPE_ns2__VibrationalComponentType;
			return soap_in_ns2__VibrationalComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TotalSpinMomentumSType"))
		{	*type = SOAP_TYPE_ns2__TotalSpinMomentumSType;
			return soap_in_ns2__TotalSpinMomentumSType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SymbolType"))
		{	*type = SOAP_TYPE_ns2__SymbolType;
			return soap_in_ns2__SymbolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StateEnergyType"))
		{	*type = SOAP_TYPE_ns2__StateEnergyType;
			return soap_in_ns2__StateEnergyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SimpleSymbolType"))
		{	*type = SOAP_TYPE_ns2__SimpleSymbolType;
			return soap_in_ns2__SimpleSymbolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MagneticQuantumNumberType"))
		{	*type = SOAP_TYPE_ns2__MagneticQuantumNumberType;
			return soap_in_ns2__MagneticQuantumNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularQuantumNumberType"))
		{	*type = SOAP_TYPE_ns2__MolecularQuantumNumberType;
			return soap_in_ns2__MolecularQuantumNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RoVibronicSplittingType"))
		{	*type = SOAP_TYPE_ns2__RoVibronicSplittingType;
			return soap_in_ns2__RoVibronicSplittingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PseudoStatisticalWeightType"))
		{	*type = SOAP_TYPE_ns2__PseudoStatisticalWeightType;
			return soap_in_ns2__PseudoStatisticalWeightType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RotationalHomeType"))
		{	*type = SOAP_TYPE_ns2__RotationalHomeType;
			return soap_in_ns2__RotationalHomeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RotationalComponentType"))
		{	*type = SOAP_TYPE_ns2__RotationalComponentType;
			return soap_in_ns2__RotationalComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RotationalCharacterisationType"))
		{	*type = SOAP_TYPE_ns2__RotationalCharacterisationType;
			return soap_in_ns2__RotationalCharacterisationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NonLinearPolyatomicType"))
		{	*type = SOAP_TYPE_ns2__NonLinearPolyatomicType;
			return soap_in_ns2__NonLinearPolyatomicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MoleculesType"))
		{	*type = SOAP_TYPE_ns2__MoleculesType;
			return soap_in_ns2__MoleculesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MoleculeNuclearSpinsType"))
		{	*type = SOAP_TYPE_ns2__MoleculeNuclearSpinsType;
			return soap_in_ns2__MoleculeNuclearSpinsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MoleculeType"))
		{	*type = SOAP_TYPE_ns2__MoleculeType;
			return soap_in_ns2__MoleculeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularStateCharacterisation-oldType"))
		{	*type = SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType;
			return soap_in_ns2__MolecularStateCharacterisation_oldType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularStateCharacterisationType"))
		{	*type = SOAP_TYPE_ns2__MolecularStateCharacterisationType;
			return soap_in_ns2__MolecularStateCharacterisationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularStateType"))
		{	*type = SOAP_TYPE_ns2__MolecularStateType;
			return soap_in_ns2__MolecularStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularPropertiesType"))
		{	*type = SOAP_TYPE_ns2__MolecularPropertiesType;
			return soap_in_ns2__MolecularPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularProjectionType"))
		{	*type = SOAP_TYPE_ns2__MolecularProjectionType;
			return soap_in_ns2__MolecularProjectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MolecularChemicalSpeciesType"))
		{	*type = SOAP_TYPE_ns2__MolecularChemicalSpeciesType;
			return soap_in_ns2__MolecularChemicalSpeciesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ElectronicHomeType"))
		{	*type = SOAP_TYPE_ns2__ElectronicHomeType;
			return soap_in_ns2__ElectronicHomeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ElectronicComponentType"))
		{	*type = SOAP_TYPE_ns2__ElectronicComponentType;
			return soap_in_ns2__ElectronicComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ElectronicCharacterisationType"))
		{	*type = SOAP_TYPE_ns2__ElectronicCharacterisationType;
			return soap_in_ns2__ElectronicCharacterisationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DiatomAndLinearPolyatomicType"))
		{	*type = SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType;
			return soap_in_ns2__DiatomAndLinearPolyatomicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ComplexMolecularQuantumNumberType"))
		{	*type = SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType;
			return soap_in_ns2__ComplexMolecularQuantumNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CentralSymbolType"))
		{	*type = SOAP_TYPE_ns2__CentralSymbolType;
			return soap_in_ns2__CentralSymbolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:C2SymmetriesType"))
		{	*type = SOAP_TYPE_ns2__C2SymmetriesType;
			return soap_in_ns2__C2SymmetriesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BondArrayType"))
		{	*type = SOAP_TYPE_ns2__BondArrayType;
			return soap_in_ns2__BondArrayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BondType"))
		{	*type = SOAP_TYPE_ns2__BondType;
			return soap_in_ns2__BondType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomNType"))
		{	*type = SOAP_TYPE_ns2__AtomNType;
			return soap_in_ns2__AtomNType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomArrayType"))
		{	*type = SOAP_TYPE_ns2__AtomArrayType;
			return soap_in_ns2__AtomArrayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HinderedMotionType"))
		{	*type = SOAP_TYPE_ns2__HinderedMotionType;
			return soap_in_ns2__HinderedMotionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AsymmetricProjectionType"))
		{	*type = SOAP_TYPE_ns2__AsymmetricProjectionType;
			return soap_in_ns2__AsymmetricProjectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SuperShellType"))
		{	*type = SOAP_TYPE_ns2__SuperShellType;
			return soap_in_ns2__SuperShellType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SuperConfigurationType"))
		{	*type = SOAP_TYPE_ns2__SuperConfigurationType;
			return soap_in_ns2__SuperConfigurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShellType"))
		{	*type = SOAP_TYPE_ns2__ShellType;
			return soap_in_ns2__ShellType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShellPairType"))
		{	*type = SOAP_TYPE_ns2__ShellPairType;
			return soap_in_ns2__ShellPairType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShellsType"))
		{	*type = SOAP_TYPE_ns2__ShellsType;
			return soap_in_ns2__ShellsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConfigurationType"))
		{	*type = SOAP_TYPE_ns2__ConfigurationType;
			return soap_in_ns2__ConfigurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomicQuantumNumbersType"))
		{	*type = SOAP_TYPE_ns2__AtomicQuantumNumbersType;
			return soap_in_ns2__AtomicQuantumNumbersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomicComponentType"))
		{	*type = SOAP_TYPE_ns2__AtomicComponentType;
			return soap_in_ns2__AtomicComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomicCoreType"))
		{	*type = SOAP_TYPE_ns2__AtomicCoreType;
			return soap_in_ns2__AtomicCoreType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomicCompositionType"))
		{	*type = SOAP_TYPE_ns2__AtomicCompositionType;
			return soap_in_ns2__AtomicCompositionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomicNumericalDataType"))
		{	*type = SOAP_TYPE_ns2__AtomicNumericalDataType;
			return soap_in_ns2__AtomicNumericalDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomicStateType"))
		{	*type = SOAP_TYPE_ns2__AtomicStateType;
			return soap_in_ns2__AtomicStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IonStateType"))
		{	*type = SOAP_TYPE_ns2__IonStateType;
			return soap_in_ns2__IonStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IsotopeParametersType"))
		{	*type = SOAP_TYPE_ns2__IsotopeParametersType;
			return soap_in_ns2__IsotopeParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IsotopeType"))
		{	*type = SOAP_TYPE_ns2__IsotopeType;
			return soap_in_ns2__IsotopeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomType"))
		{	*type = SOAP_TYPE_ns2__AtomType;
			return soap_in_ns2__AtomType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AtomsType"))
		{	*type = SOAP_TYPE_ns2__AtomsType;
			return soap_in_ns2__AtomsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FunctionType"))
		{	*type = SOAP_TYPE_ns2__FunctionType;
			return soap_in_ns2__FunctionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FunctionsType"))
		{	*type = SOAP_TYPE_ns2__FunctionsType;
			return soap_in_ns2__FunctionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MethodType"))
		{	*type = SOAP_TYPE_ns2__MethodType;
			return soap_in_ns2__MethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MethodsType"))
		{	*type = SOAP_TYPE_ns2__MethodsType;
			return soap_in_ns2__MethodsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EditorsType"))
		{	*type = SOAP_TYPE_ns2__EditorsType;
			return soap_in_ns2__EditorsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AuthorsType"))
		{	*type = SOAP_TYPE_ns2__AuthorsType;
			return soap_in_ns2__AuthorsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SourceType"))
		{	*type = SOAP_TYPE_ns2__SourceType;
			return soap_in_ns2__SourceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SourcesType"))
		{	*type = SOAP_TYPE_ns2__SourcesType;
			return soap_in_ns2__SourcesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AuthorType"))
		{	*type = SOAP_TYPE_ns2__AuthorType;
			return soap_in_ns2__AuthorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ProductsType"))
		{	*type = SOAP_TYPE_ns2__ProductsType;
			return soap_in_ns2__ProductsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReactantsType"))
		{	*type = SOAP_TYPE_ns2__ReactantsType;
			return soap_in_ns2__ReactantsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TermType"))
		{	*type = SOAP_TYPE_ns2__TermType;
			return soap_in_ns2__TermType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OrbitalAngularMomentumType"))
		{	*type = SOAP_TYPE_ns2__OrbitalAngularMomentumType;
			return soap_in_ns2__OrbitalAngularMomentumType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MixingCoefficientType"))
		{	*type = SOAP_TYPE_ns2__MixingCoefficientType;
			return soap_in_ns2__MixingCoefficientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LSCouplingType"))
		{	*type = SOAP_TYPE_ns2__LSCouplingType;
			return soap_in_ns2__LSCouplingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LKCouplingType"))
		{	*type = SOAP_TYPE_ns2__LKCouplingType;
			return soap_in_ns2__LKCouplingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:jKCouplingType"))
		{	*type = SOAP_TYPE_ns2__jKCouplingType;
			return soap_in_ns2__jKCouplingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:jjCouplingType"))
		{	*type = SOAP_TYPE_ns2__jjCouplingType;
			return soap_in_ns2__jjCouplingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueType"))
		{	*type = SOAP_TYPE_ns2__ValueType;
			return soap_in_ns2__ValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParameterType"))
		{	*type = SOAP_TYPE_ns2__ParameterType;
			return soap_in_ns2__ParameterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParametersType"))
		{	*type = SOAP_TYPE_ns2__ParametersType;
			return soap_in_ns2__ParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArgumentType"))
		{	*type = SOAP_TYPE_ns2__ArgumentType;
			return soap_in_ns2__ArgumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArgumentsType"))
		{	*type = SOAP_TYPE_ns2__ArgumentsType;
			return soap_in_ns2__ArgumentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExpressionType"))
		{	*type = SOAP_TYPE_ns2__ExpressionType;
			return soap_in_ns2__ExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FitValidityLimitsType"))
		{	*type = SOAP_TYPE_ns2__FitValidityLimitsType;
			return soap_in_ns2__FitValidityLimitsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FitParametersType"))
		{	*type = SOAP_TYPE_ns2__FitParametersType;
			return soap_in_ns2__FitParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FitDataType"))
		{	*type = SOAP_TYPE_ns2__FitDataType;
			return soap_in_ns2__FitDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TabulatedDataType"))
		{	*type = SOAP_TYPE_ns2__TabulatedDataType;
			return soap_in_ns2__TabulatedDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataXYType"))
		{	*type = SOAP_TYPE_ns2__DataXYType;
			return soap_in_ns2__DataXYType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataTableType"))
		{	*type = SOAP_TYPE_ns2__DataTableType;
			return soap_in_ns2__DataTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataSetsType"))
		{	*type = SOAP_TYPE_ns2__DataSetsType;
			return soap_in_ns2__DataSetsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataSetType"))
		{	*type = SOAP_TYPE_ns2__DataSetType;
			return soap_in_ns2__DataSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataType"))
		{	*type = SOAP_TYPE_ns2__DataType;
			return soap_in_ns2__DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ChemicalElementType"))
		{	*type = SOAP_TYPE_ns2__ChemicalElementType;
			return soap_in_ns2__ChemicalElementType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PrimaryType"))
		{	*type = SOAP_TYPE_ns2__PrimaryType;
			return soap_in_ns2__PrimaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger;
			return soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:gYear"))
		{	*type = SOAP_TYPE_xsd__gYear;
			return soap_in_xsd__gYear(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREFS"))
		{	*type = SOAP_TYPE_xsd__IDREFS;
			return soap_in_xsd__IDREFS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	*type = SOAP_TYPE_xsd__IDREF;
			return soap_in_xsd__IDREF(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:DataTableType"))
		{	*type = SOAP_TYPE_xsd__DataTableType;
			return soap_in_xsd__DataTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:units"))
		{	*type = SOAP_TYPE__ns2__units;
			return soap_in__ns2__units(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CodeType"))
		{	*type = SOAP_TYPE_ns2__CodeType;
			return soap_in_ns2__CodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IAEACodeType"))
		{	*type = SOAP_TYPE_ns2__IAEACodeType;
			return soap_in_ns2__IAEACodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParticleNameType"))
		{	*type = SOAP_TYPE_ns2__ParticleNameType;
			return soap_in_ns2__ParticleNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PermutationSymmetryType"))
		{	*type = SOAP_TYPE_ns2__PermutationSymmetryType;
			return soap_in_ns2__PermutationSymmetryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ModesListType"))
		{	*type = SOAP_TYPE_ns2__ModesListType;
			return soap_in_ns2__ModesListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EfSymmetryType"))
		{	*type = SOAP_TYPE_ns2__EfSymmetryType;
			return soap_in_ns2__EfSymmetryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CouplingListType"))
		{	*type = SOAP_TYPE_ns2__CouplingListType;
			return soap_in_ns2__CouplingListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:C2SymmetryType"))
		{	*type = SOAP_TYPE_ns2__C2SymmetryType;
			return soap_in_ns2__C2SymmetryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MethodCategoryType"))
		{	*type = SOAP_TYPE_ns2__MethodCategoryType;
			return soap_in_ns2__MethodCategoryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CategoryType"))
		{	*type = SOAP_TYPE_ns2__CategoryType;
			return soap_in_ns2__CategoryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MixingClassType"))
		{	*type = SOAP_TYPE_ns2__MixingClassType;
			return soap_in_ns2__MixingClassType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParityType"))
		{	*type = SOAP_TYPE_ns2__ParityType;
			return soap_in_ns2__ParityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReferenceFrameType"))
		{	*type = SOAP_TYPE_ns2__ReferenceFrameType;
			return soap_in_ns2__ReferenceFrameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataDescriptionType"))
		{	*type = SOAP_TYPE_ns2__DataDescriptionType;
			return soap_in_ns2__DataDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getS"))
		{	*type = SOAP_TYPE_ns2__getS;
			return soap_in_ns2__getS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSResponse"))
		{	*type = SOAP_TYPE_ns2__getSResponse;
			return soap_in_ns2__getSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:LSCouplingType-Seniority"))
		{	*type = SOAP_TYPE__ns2__LSCouplingType_Seniority;
			return soap_in__ns2__LSCouplingType_Seniority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:functionID"))
		{	*type = SOAP_TYPE__ns2__functionID;
			return soap_in__ns2__functionID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:methodID"))
		{	*type = SOAP_TYPE__ns2__methodID;
			return soap_in__ns2__methodID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:sourceID"))
		{	*type = SOAP_TYPE__ns2__sourceID;
			return soap_in__ns2__sourceID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:stateID"))
		{	*type = SOAP_TYPE__ns2__stateID;
			return soap_in__ns2__stateID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:functionRef"))
		{	*type = SOAP_TYPE__ns2__functionRef;
			return soap_in__ns2__functionRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:methodRef"))
		{	*type = SOAP_TYPE__ns2__methodRef;
			return soap_in__ns2__methodRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:sourceRef"))
		{	*type = SOAP_TYPE__ns2__sourceRef;
			return soap_in__ns2__sourceRef(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns2__units:
		return soap_out__ns2__units(soap, tag, id, (const enum _ns2__units *)ptr, "ns2:units");
	case SOAP_TYPE_ns2__CodeType:
		return soap_out_ns2__CodeType(soap, tag, id, (const enum ns2__CodeType *)ptr, "ns2:CodeType");
	case SOAP_TYPE_ns2__IAEACodeType:
		return soap_out_ns2__IAEACodeType(soap, tag, id, (const enum ns2__IAEACodeType *)ptr, "ns2:IAEACodeType");
	case SOAP_TYPE_ns2__ParticleNameType:
		return soap_out_ns2__ParticleNameType(soap, tag, id, (const enum ns2__ParticleNameType *)ptr, "ns2:ParticleNameType");
	case SOAP_TYPE_ns2__PermutationSymmetryType:
		return soap_out_ns2__PermutationSymmetryType(soap, tag, id, (const enum ns2__PermutationSymmetryType *)ptr, "ns2:PermutationSymmetryType");
	case SOAP_TYPE_ns2__ModesListType:
		return soap_out_ns2__ModesListType(soap, tag, id, (const enum ns2__ModesListType *)ptr, "ns2:ModesListType");
	case SOAP_TYPE_ns2__EfSymmetryType:
		return soap_out_ns2__EfSymmetryType(soap, tag, id, (const enum ns2__EfSymmetryType *)ptr, "ns2:EfSymmetryType");
	case SOAP_TYPE_ns2__CouplingListType:
		return soap_out_ns2__CouplingListType(soap, tag, id, (const enum ns2__CouplingListType *)ptr, "ns2:CouplingListType");
	case SOAP_TYPE_ns2__C2SymmetryType:
		return soap_out_ns2__C2SymmetryType(soap, tag, id, (const enum ns2__C2SymmetryType *)ptr, "ns2:C2SymmetryType");
	case SOAP_TYPE_ns2__MethodCategoryType:
		return soap_out_ns2__MethodCategoryType(soap, tag, id, (const enum ns2__MethodCategoryType *)ptr, "ns2:MethodCategoryType");
	case SOAP_TYPE_ns2__CategoryType:
		return soap_out_ns2__CategoryType(soap, tag, id, (const enum ns2__CategoryType *)ptr, "ns2:CategoryType");
	case SOAP_TYPE_ns2__MixingClassType:
		return soap_out_ns2__MixingClassType(soap, tag, id, (const enum ns2__MixingClassType *)ptr, "ns2:MixingClassType");
	case SOAP_TYPE_ns2__ParityType:
		return soap_out_ns2__ParityType(soap, tag, id, (const enum ns2__ParityType *)ptr, "ns2:ParityType");
	case SOAP_TYPE_ns2__ReferenceFrameType:
		return soap_out_ns2__ReferenceFrameType(soap, tag, id, (const enum ns2__ReferenceFrameType *)ptr, "ns2:ReferenceFrameType");
	case SOAP_TYPE_ns2__DataDescriptionType:
		return soap_out_ns2__DataDescriptionType(soap, tag, id, (const enum ns2__DataDescriptionType *)ptr, "ns2:DataDescriptionType");
	case SOAP_TYPE__ns2__LSCouplingType_Seniority:
		return ((_ns2__LSCouplingType_Seniority *)ptr)->soap_out(soap, "ns2:LSCouplingType-Seniority", id, NULL);
	case SOAP_TYPE__ns2__functionID:
		return soap_out__ns2__functionID(soap, "ns2:functionID", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns2__methodID:
		return soap_out__ns2__methodID(soap, "ns2:methodID", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns2__sourceID:
		return soap_out__ns2__sourceID(soap, "ns2:sourceID", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns2__stateID:
		return soap_out__ns2__stateID(soap, "ns2:stateID", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns2__functionRef:
		return soap_out__ns2__functionRef(soap, "ns2:functionRef", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns2__methodRef:
		return soap_out__ns2__methodRef(soap, "ns2:methodRef", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns2__sourceRef:
		return soap_out__ns2__sourceRef(soap, "ns2:sourceRef", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE_ns2__MultipoleType:
		return soap_out_ns2__MultipoleType(soap, tag, id, (const std::string *)ptr, "ns2:MultipoleType");
	case SOAP_TYPE_ns2__StateRef:
		return soap_out_ns2__StateRef(soap, tag, id, (const std::string *)ptr, "ns2:StateRef");
	case SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType:
		return soap_out_ns2__OrbitalAngularMomentumSymbolType(soap, tag, id, (const std::string *)ptr, "ns2:OrbitalAngularMomentumSymbolType");
	case SOAP_TYPE_ns2__PrincipalQuantumNumberType:
		return soap_out_ns2__PrincipalQuantumNumberType(soap, tag, id, (const std::string *)ptr, "ns2:PrincipalQuantumNumberType");
	case SOAP_TYPE_ns2__ElementSymbolType:
		return soap_out_ns2__ElementSymbolType(soap, tag, id, (const std::string *)ptr, "ns2:ElementSymbolType");
	case SOAP_TYPE_ns2__AngularMomentumType:
		return soap_out_ns2__AngularMomentumType(soap, tag, id, (const std::string *)ptr, "ns2:AngularMomentumType");
	case SOAP_TYPE_ns2__AngularMomentumProjectionType:
		return soap_out_ns2__AngularMomentumProjectionType(soap, tag, id, (const std::string *)ptr, "ns2:AngularMomentumProjectionType");
	case SOAP_TYPE_ns2__DataListType:
		return soap_out_ns2__DataListType(soap, tag, id, (const std::string *)ptr, "ns2:DataListType");
	case SOAP_TYPE_ns2__StatesType:
		return ((ns2__StatesType *)ptr)->soap_out(soap, tag, id, "ns2:StatesType");
	case SOAP_TYPE_ns2__ProcessesType:
		return ((ns2__ProcessesType *)ptr)->soap_out(soap, tag, id, "ns2:ProcessesType");
	case SOAP_TYPE_ns2__XSAMSDataType:
		return ((ns2__XSAMSDataType *)ptr)->soap_out(soap, tag, id, "ns2:XSAMSDataType");
	case SOAP_TYPE_ns2__CollisionalProcessClassType:
		return ((ns2__CollisionalProcessClassType *)ptr)->soap_out(soap, tag, id, "ns2:CollisionalProcessClassType");
	case SOAP_TYPE_ns2__CollisionalTransitionType:
		return ((ns2__CollisionalTransitionType *)ptr)->soap_out(soap, tag, id, "ns2:CollisionalTransitionType");
	case SOAP_TYPE_ns2__CollisionsType:
		return ((ns2__CollisionsType *)ptr)->soap_out(soap, tag, id, "ns2:CollisionsType");
	case SOAP_TYPE_ns2__NonRadiativeTransitionType:
		return ((ns2__NonRadiativeTransitionType *)ptr)->soap_out(soap, tag, id, "ns2:NonRadiativeTransitionType");
	case SOAP_TYPE_ns2__NonRadiativeType:
		return ((ns2__NonRadiativeType *)ptr)->soap_out(soap, tag, id, "ns2:NonRadiativeType");
	case SOAP_TYPE_ns2__EnergyWavelengthType:
		return ((ns2__EnergyWavelengthType *)ptr)->soap_out(soap, tag, id, "ns2:EnergyWavelengthType");
	case SOAP_TYPE_ns2__WavelengthWavenumberType:
		return ((ns2__WavelengthWavenumberType *)ptr)->soap_out(soap, tag, id, "ns2:WavelengthWavenumberType");
	case SOAP_TYPE_ns2__RadiativeTransitionProbabilityType:
		return ((ns2__RadiativeTransitionProbabilityType *)ptr)->soap_out(soap, tag, id, "ns2:RadiativeTransitionProbabilityType");
	case SOAP_TYPE_ns2__RadiativeTransitionType:
		return ((ns2__RadiativeTransitionType *)ptr)->soap_out(soap, tag, id, "ns2:RadiativeTransitionType");
	case SOAP_TYPE_ns2__RadiativeType:
		return ((ns2__RadiativeType *)ptr)->soap_out(soap, tag, id, "ns2:RadiativeType");
	case SOAP_TYPE_ns2__MaterialCompositionType:
		return ((ns2__MaterialCompositionType *)ptr)->soap_out(soap, tag, id, "ns2:MaterialCompositionType");
	case SOAP_TYPE_ns2__MaterialType:
		return ((ns2__MaterialType *)ptr)->soap_out(soap, tag, id, "ns2:MaterialType");
	case SOAP_TYPE_ns2__MaterialComponentType:
		return ((ns2__MaterialComponentType *)ptr)->soap_out(soap, tag, id, "ns2:MaterialComponentType");
	case SOAP_TYPE_ns2__SolidsType:
		return ((ns2__SolidsType *)ptr)->soap_out(soap, tag, id, "ns2:SolidsType");
	case SOAP_TYPE_ns2__SolidType:
		return ((ns2__SolidType *)ptr)->soap_out(soap, tag, id, "ns2:SolidType");
	case SOAP_TYPE_ns2__ParticlePropertiesType:
		return ((ns2__ParticlePropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:ParticlePropertiesType");
	case SOAP_TYPE_ns2__ParticleType:
		return ((ns2__ParticleType *)ptr)->soap_out(soap, tag, id, "ns2:ParticleType");
	case SOAP_TYPE_ns2__ParticlesType:
		return ((ns2__ParticlesType *)ptr)->soap_out(soap, tag, id, "ns2:ParticlesType");
	case SOAP_TYPE_ns2__CharacterisationType:
		return ((ns2__CharacterisationType *)ptr)->soap_out(soap, tag, id, "ns2:CharacterisationType");
	case SOAP_TYPE_ns2__ReferencedTextType:
		return ((ns2__ReferencedTextType *)ptr)->soap_out(soap, tag, id, "ns2:ReferencedTextType");
	case SOAP_TYPE_ns2__HyperfineQuantumNumbersType:
		return ((ns2__HyperfineQuantumNumbersType *)ptr)->soap_out(soap, tag, id, "ns2:HyperfineQuantumNumbersType");
	case SOAP_TYPE_ns2__NonLinearNoElecHyperFType:
		return ((ns2__NonLinearNoElecHyperFType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearNoElecHyperFType");
	case SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType:
		return ((ns2__NonLinearNoElecNoHyperFType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearNoElecNoHyperFType");
	case SOAP_TYPE_ns2__NonLinearNoElecType:
		return ((ns2__NonLinearNoElecType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearNoElecType");
	case SOAP_TYPE_ns2__NonLinearElecNoHyperFType:
		return ((ns2__NonLinearElecNoHyperFType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearElecNoHyperFType");
	case SOAP_TYPE_ns2__NonLinearElecHyperFType:
		return ((ns2__NonLinearElecHyperFType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearElecHyperFType");
	case SOAP_TYPE_ns2__NonLinearElecCouplingType:
		return ((ns2__NonLinearElecCouplingType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearElecCouplingType");
	case SOAP_TYPE_ns2__HyperfineCouplingBType:
		return ((ns2__HyperfineCouplingBType *)ptr)->soap_out(soap, tag, id, "ns2:HyperfineCouplingBType");
	case SOAP_TYPE_ns2__HyperfineCaseABetaType:
		return ((ns2__HyperfineCaseABetaType *)ptr)->soap_out(soap, tag, id, "ns2:HyperfineCaseABetaType");
	case SOAP_TYPE_ns2__HyperfineCaseAAlphaType:
		return ((ns2__HyperfineCaseAAlphaType *)ptr)->soap_out(soap, tag, id, "ns2:HyperfineCaseAAlphaType");
	case SOAP_TYPE_ns2__HundCaseBType:
		return ((ns2__HundCaseBType *)ptr)->soap_out(soap, tag, id, "ns2:HundCaseBType");
	case SOAP_TYPE_ns2__HundCaseAType:
		return ((ns2__HundCaseAType *)ptr)->soap_out(soap, tag, id, "ns2:HundCaseAType");
	case SOAP_TYPE_ns2__LinearElecCouplingType:
		return ((ns2__LinearElecCouplingType *)ptr)->soap_out(soap, tag, id, "ns2:LinearElecCouplingType");
	case SOAP_TYPE_ns2__LinearNoElecHyperFType:
		return ((ns2__LinearNoElecHyperFType *)ptr)->soap_out(soap, tag, id, "ns2:LinearNoElecHyperFType");
	case SOAP_TYPE_ns2__LinearNoElecNoHyperFType:
		return ((ns2__LinearNoElecNoHyperFType *)ptr)->soap_out(soap, tag, id, "ns2:LinearNoElecNoHyperFType");
	case SOAP_TYPE_ns2__VibrationalQuantumNumbersType:
		return ((ns2__VibrationalQuantumNumbersType *)ptr)->soap_out(soap, tag, id, "ns2:VibrationalQuantumNumbersType");
	case SOAP_TYPE_ns2__VibrationalHomeType:
		return ((ns2__VibrationalHomeType *)ptr)->soap_out(soap, tag, id, "ns2:VibrationalHomeType");
	case SOAP_TYPE_ns2__VibrationalCharacterisationType:
		return ((ns2__VibrationalCharacterisationType *)ptr)->soap_out(soap, tag, id, "ns2:VibrationalCharacterisationType");
	case SOAP_TYPE_ns2__VibrationalComponentType:
		return ((ns2__VibrationalComponentType *)ptr)->soap_out(soap, tag, id, "ns2:VibrationalComponentType");
	case SOAP_TYPE_ns2__TotalSpinMomentumSType:
		return ((ns2__TotalSpinMomentumSType *)ptr)->soap_out(soap, tag, id, "ns2:TotalSpinMomentumSType");
	case SOAP_TYPE_ns2__SymbolType:
		return ((ns2__SymbolType *)ptr)->soap_out(soap, tag, id, "ns2:SymbolType");
	case SOAP_TYPE_ns2__StateEnergyType:
		return ((ns2__StateEnergyType *)ptr)->soap_out(soap, tag, id, "ns2:StateEnergyType");
	case SOAP_TYPE_ns2__SimpleSymbolType:
		return ((ns2__SimpleSymbolType *)ptr)->soap_out(soap, tag, id, "ns2:SimpleSymbolType");
	case SOAP_TYPE_ns2__MagneticQuantumNumberType:
		return ((ns2__MagneticQuantumNumberType *)ptr)->soap_out(soap, tag, id, "ns2:MagneticQuantumNumberType");
	case SOAP_TYPE_ns2__MolecularQuantumNumberType:
		return ((ns2__MolecularQuantumNumberType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularQuantumNumberType");
	case SOAP_TYPE_ns2__RoVibronicSplittingType:
		return ((ns2__RoVibronicSplittingType *)ptr)->soap_out(soap, tag, id, "ns2:RoVibronicSplittingType");
	case SOAP_TYPE_ns2__PseudoStatisticalWeightType:
		return ((ns2__PseudoStatisticalWeightType *)ptr)->soap_out(soap, tag, id, "ns2:PseudoStatisticalWeightType");
	case SOAP_TYPE_ns2__RotationalHomeType:
		return ((ns2__RotationalHomeType *)ptr)->soap_out(soap, tag, id, "ns2:RotationalHomeType");
	case SOAP_TYPE_ns2__RotationalComponentType:
		return ((ns2__RotationalComponentType *)ptr)->soap_out(soap, tag, id, "ns2:RotationalComponentType");
	case SOAP_TYPE_ns2__RotationalCharacterisationType:
		return ((ns2__RotationalCharacterisationType *)ptr)->soap_out(soap, tag, id, "ns2:RotationalCharacterisationType");
	case SOAP_TYPE_ns2__NonLinearPolyatomicType:
		return ((ns2__NonLinearPolyatomicType *)ptr)->soap_out(soap, tag, id, "ns2:NonLinearPolyatomicType");
	case SOAP_TYPE_ns2__MoleculesType:
		return ((ns2__MoleculesType *)ptr)->soap_out(soap, tag, id, "ns2:MoleculesType");
	case SOAP_TYPE_ns2__MoleculeNuclearSpinsType:
		return ((ns2__MoleculeNuclearSpinsType *)ptr)->soap_out(soap, tag, id, "ns2:MoleculeNuclearSpinsType");
	case SOAP_TYPE_ns2__MoleculeType:
		return ((ns2__MoleculeType *)ptr)->soap_out(soap, tag, id, "ns2:MoleculeType");
	case SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType:
		return ((ns2__MolecularStateCharacterisation_oldType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularStateCharacterisation-oldType");
	case SOAP_TYPE_ns2__MolecularStateCharacterisationType:
		return ((ns2__MolecularStateCharacterisationType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularStateCharacterisationType");
	case SOAP_TYPE_ns2__MolecularStateType:
		return ((ns2__MolecularStateType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularStateType");
	case SOAP_TYPE_ns2__MolecularPropertiesType:
		return ((ns2__MolecularPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularPropertiesType");
	case SOAP_TYPE_ns2__MolecularProjectionType:
		return ((ns2__MolecularProjectionType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularProjectionType");
	case SOAP_TYPE_ns2__MolecularChemicalSpeciesType:
		return ((ns2__MolecularChemicalSpeciesType *)ptr)->soap_out(soap, tag, id, "ns2:MolecularChemicalSpeciesType");
	case SOAP_TYPE_ns2__ElectronicHomeType:
		return ((ns2__ElectronicHomeType *)ptr)->soap_out(soap, tag, id, "ns2:ElectronicHomeType");
	case SOAP_TYPE_ns2__ElectronicComponentType:
		return ((ns2__ElectronicComponentType *)ptr)->soap_out(soap, tag, id, "ns2:ElectronicComponentType");
	case SOAP_TYPE_ns2__ElectronicCharacterisationType:
		return ((ns2__ElectronicCharacterisationType *)ptr)->soap_out(soap, tag, id, "ns2:ElectronicCharacterisationType");
	case SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType:
		return ((ns2__DiatomAndLinearPolyatomicType *)ptr)->soap_out(soap, tag, id, "ns2:DiatomAndLinearPolyatomicType");
	case SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType:
		return ((ns2__ComplexMolecularQuantumNumberType *)ptr)->soap_out(soap, tag, id, "ns2:ComplexMolecularQuantumNumberType");
	case SOAP_TYPE_ns2__CentralSymbolType:
		return ((ns2__CentralSymbolType *)ptr)->soap_out(soap, tag, id, "ns2:CentralSymbolType");
	case SOAP_TYPE_ns2__C2SymmetriesType:
		return ((ns2__C2SymmetriesType *)ptr)->soap_out(soap, tag, id, "ns2:C2SymmetriesType");
	case SOAP_TYPE_ns2__BondArrayType:
		return ((ns2__BondArrayType *)ptr)->soap_out(soap, tag, id, "ns2:BondArrayType");
	case SOAP_TYPE_ns2__BondType:
		return ((ns2__BondType *)ptr)->soap_out(soap, tag, id, "ns2:BondType");
	case SOAP_TYPE_ns2__AtomNType:
		return ((ns2__AtomNType *)ptr)->soap_out(soap, tag, id, "ns2:AtomNType");
	case SOAP_TYPE_ns2__AtomArrayType:
		return ((ns2__AtomArrayType *)ptr)->soap_out(soap, tag, id, "ns2:AtomArrayType");
	case SOAP_TYPE_ns2__HinderedMotionType:
		return ((ns2__HinderedMotionType *)ptr)->soap_out(soap, tag, id, "ns2:HinderedMotionType");
	case SOAP_TYPE_ns2__AsymmetricProjectionType:
		return ((ns2__AsymmetricProjectionType *)ptr)->soap_out(soap, tag, id, "ns2:AsymmetricProjectionType");
	case SOAP_TYPE_ns2__SuperShellType:
		return ((ns2__SuperShellType *)ptr)->soap_out(soap, tag, id, "ns2:SuperShellType");
	case SOAP_TYPE_ns2__SuperConfigurationType:
		return ((ns2__SuperConfigurationType *)ptr)->soap_out(soap, tag, id, "ns2:SuperConfigurationType");
	case SOAP_TYPE_ns2__ShellType:
		return ((ns2__ShellType *)ptr)->soap_out(soap, tag, id, "ns2:ShellType");
	case SOAP_TYPE_ns2__ShellPairType:
		return ((ns2__ShellPairType *)ptr)->soap_out(soap, tag, id, "ns2:ShellPairType");
	case SOAP_TYPE_ns2__ShellsType:
		return ((ns2__ShellsType *)ptr)->soap_out(soap, tag, id, "ns2:ShellsType");
	case SOAP_TYPE_ns2__ConfigurationType:
		return ((ns2__ConfigurationType *)ptr)->soap_out(soap, tag, id, "ns2:ConfigurationType");
	case SOAP_TYPE_ns2__AtomicQuantumNumbersType:
		return ((ns2__AtomicQuantumNumbersType *)ptr)->soap_out(soap, tag, id, "ns2:AtomicQuantumNumbersType");
	case SOAP_TYPE_ns2__AtomicComponentType:
		return ((ns2__AtomicComponentType *)ptr)->soap_out(soap, tag, id, "ns2:AtomicComponentType");
	case SOAP_TYPE_ns2__AtomicCoreType:
		return ((ns2__AtomicCoreType *)ptr)->soap_out(soap, tag, id, "ns2:AtomicCoreType");
	case SOAP_TYPE_ns2__AtomicCompositionType:
		return ((ns2__AtomicCompositionType *)ptr)->soap_out(soap, tag, id, "ns2:AtomicCompositionType");
	case SOAP_TYPE_ns2__AtomicNumericalDataType:
		return ((ns2__AtomicNumericalDataType *)ptr)->soap_out(soap, tag, id, "ns2:AtomicNumericalDataType");
	case SOAP_TYPE_ns2__AtomicStateType:
		return ((ns2__AtomicStateType *)ptr)->soap_out(soap, tag, id, "ns2:AtomicStateType");
	case SOAP_TYPE_ns2__IonStateType:
		return ((ns2__IonStateType *)ptr)->soap_out(soap, tag, id, "ns2:IonStateType");
	case SOAP_TYPE_ns2__IsotopeParametersType:
		return ((ns2__IsotopeParametersType *)ptr)->soap_out(soap, tag, id, "ns2:IsotopeParametersType");
	case SOAP_TYPE_ns2__IsotopeType:
		return ((ns2__IsotopeType *)ptr)->soap_out(soap, tag, id, "ns2:IsotopeType");
	case SOAP_TYPE_ns2__AtomType:
		return ((ns2__AtomType *)ptr)->soap_out(soap, tag, id, "ns2:AtomType");
	case SOAP_TYPE_ns2__AtomsType:
		return ((ns2__AtomsType *)ptr)->soap_out(soap, tag, id, "ns2:AtomsType");
	case SOAP_TYPE_ns2__FunctionType:
		return ((ns2__FunctionType *)ptr)->soap_out(soap, tag, id, "ns2:FunctionType");
	case SOAP_TYPE_ns2__FunctionsType:
		return ((ns2__FunctionsType *)ptr)->soap_out(soap, tag, id, "ns2:FunctionsType");
	case SOAP_TYPE_ns2__MethodType:
		return ((ns2__MethodType *)ptr)->soap_out(soap, tag, id, "ns2:MethodType");
	case SOAP_TYPE_ns2__MethodsType:
		return ((ns2__MethodsType *)ptr)->soap_out(soap, tag, id, "ns2:MethodsType");
	case SOAP_TYPE_ns2__EditorsType:
		return ((ns2__EditorsType *)ptr)->soap_out(soap, tag, id, "ns2:EditorsType");
	case SOAP_TYPE_ns2__AuthorsType:
		return ((ns2__AuthorsType *)ptr)->soap_out(soap, tag, id, "ns2:AuthorsType");
	case SOAP_TYPE_ns2__SourceType:
		return ((ns2__SourceType *)ptr)->soap_out(soap, tag, id, "ns2:SourceType");
	case SOAP_TYPE_ns2__SourcesType:
		return ((ns2__SourcesType *)ptr)->soap_out(soap, tag, id, "ns2:SourcesType");
	case SOAP_TYPE_ns2__AuthorType:
		return ((ns2__AuthorType *)ptr)->soap_out(soap, tag, id, "ns2:AuthorType");
	case SOAP_TYPE_ns2__ProductsType:
		return ((ns2__ProductsType *)ptr)->soap_out(soap, tag, id, "ns2:ProductsType");
	case SOAP_TYPE_ns2__ReactantsType:
		return ((ns2__ReactantsType *)ptr)->soap_out(soap, tag, id, "ns2:ReactantsType");
	case SOAP_TYPE_ns2__TermType:
		return ((ns2__TermType *)ptr)->soap_out(soap, tag, id, "ns2:TermType");
	case SOAP_TYPE_ns2__OrbitalAngularMomentumType:
		return ((ns2__OrbitalAngularMomentumType *)ptr)->soap_out(soap, tag, id, "ns2:OrbitalAngularMomentumType");
	case SOAP_TYPE_ns2__MixingCoefficientType:
		return ((ns2__MixingCoefficientType *)ptr)->soap_out(soap, tag, id, "ns2:MixingCoefficientType");
	case SOAP_TYPE_ns2__LSCouplingType:
		return ((ns2__LSCouplingType *)ptr)->soap_out(soap, tag, id, "ns2:LSCouplingType");
	case SOAP_TYPE_ns2__LKCouplingType:
		return ((ns2__LKCouplingType *)ptr)->soap_out(soap, tag, id, "ns2:LKCouplingType");
	case SOAP_TYPE_ns2__jKCouplingType:
		return ((ns2__jKCouplingType *)ptr)->soap_out(soap, tag, id, "ns2:jKCouplingType");
	case SOAP_TYPE_ns2__jjCouplingType:
		return ((ns2__jjCouplingType *)ptr)->soap_out(soap, tag, id, "ns2:jjCouplingType");
	case SOAP_TYPE_ns2__ValueType:
		return ((ns2__ValueType *)ptr)->soap_out(soap, tag, id, "ns2:ValueType");
	case SOAP_TYPE_ns2__ParameterType:
		return ((ns2__ParameterType *)ptr)->soap_out(soap, tag, id, "ns2:ParameterType");
	case SOAP_TYPE_ns2__ParametersType:
		return ((ns2__ParametersType *)ptr)->soap_out(soap, tag, id, "ns2:ParametersType");
	case SOAP_TYPE_ns2__ArgumentType:
		return ((ns2__ArgumentType *)ptr)->soap_out(soap, tag, id, "ns2:ArgumentType");
	case SOAP_TYPE_ns2__ArgumentsType:
		return ((ns2__ArgumentsType *)ptr)->soap_out(soap, tag, id, "ns2:ArgumentsType");
	case SOAP_TYPE_ns2__ExpressionType:
		return ((ns2__ExpressionType *)ptr)->soap_out(soap, tag, id, "ns2:ExpressionType");
	case SOAP_TYPE_ns2__FitValidityLimitsType:
		return ((ns2__FitValidityLimitsType *)ptr)->soap_out(soap, tag, id, "ns2:FitValidityLimitsType");
	case SOAP_TYPE_ns2__FitParametersType:
		return ((ns2__FitParametersType *)ptr)->soap_out(soap, tag, id, "ns2:FitParametersType");
	case SOAP_TYPE_ns2__FitDataType:
		return ((ns2__FitDataType *)ptr)->soap_out(soap, tag, id, "ns2:FitDataType");
	case SOAP_TYPE_ns2__TabulatedDataType:
		return ((ns2__TabulatedDataType *)ptr)->soap_out(soap, tag, id, "ns2:TabulatedDataType");
	case SOAP_TYPE_ns2__DataXYType:
		return ((ns2__DataXYType *)ptr)->soap_out(soap, tag, id, "ns2:DataXYType");
	case SOAP_TYPE_ns2__DataTableType:
		return ((ns2__DataTableType *)ptr)->soap_out(soap, tag, id, "ns2:DataTableType");
	case SOAP_TYPE_ns2__DataSetsType:
		return ((ns2__DataSetsType *)ptr)->soap_out(soap, tag, id, "ns2:DataSetsType");
	case SOAP_TYPE_ns2__DataSetType:
		return ((ns2__DataSetType *)ptr)->soap_out(soap, tag, id, "ns2:DataSetType");
	case SOAP_TYPE_ns2__DataType:
		return ((ns2__DataType *)ptr)->soap_out(soap, tag, id, "ns2:DataType");
	case SOAP_TYPE_ns2__ChemicalElementType:
		return ((ns2__ChemicalElementType *)ptr)->soap_out(soap, tag, id, "ns2:ChemicalElementType");
	case SOAP_TYPE_ns2__PrimaryType:
		return ((ns2__PrimaryType *)ptr)->soap_out(soap, tag, id, "ns2:PrimaryType");
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_xsd__positiveInteger(soap, tag, id, (const std::string *)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__gYear:
		return soap_out_xsd__gYear(soap, tag, id, (const std::string *)ptr, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__IDREFS:
		return soap_out_xsd__IDREFS(soap, tag, id, (const std::string *)ptr, "xsd:IDREFS");
	case SOAP_TYPE_xsd__IDREF:
		return soap_out_xsd__IDREF(soap, tag, id, (const std::string *)ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_xsd__DataTableType:
		return soap_out_xsd__DataTableType(soap, tag, id, (const std::string *)ptr, "xsd:DataTableType");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns2__getS:
		return soap_out_ns2__getS(soap, tag, id, (const struct ns2__getS *)ptr, "ns2:getS");
	case SOAP_TYPE_ns2__getSResponse:
		return soap_out_ns2__getSResponse(soap, tag, id, (const struct ns2__getSResponse *)ptr, "ns2:getSResponse");
	case SOAP_TYPE_PointerTons2__DataSetsType:
		return soap_out_PointerTons2__DataSetsType(soap, tag, id, (ns2__DataSetsType *const*)ptr, "ns2:DataSetsType");
	case SOAP_TYPE_PointerTons2__ProductsType:
		return soap_out_PointerTons2__ProductsType(soap, tag, id, (ns2__ProductsType *const*)ptr, "ns2:ProductsType");
	case SOAP_TYPE_PointerTons2__ReactantsType:
		return soap_out_PointerTons2__ReactantsType(soap, tag, id, (ns2__ReactantsType *const*)ptr, "ns2:ReactantsType");
	case SOAP_TYPE_PointerTons2__CollisionalProcessClassType:
		return soap_out_PointerTons2__CollisionalProcessClassType(soap, tag, id, (ns2__CollisionalProcessClassType *const*)ptr, "ns2:CollisionalProcessClassType");
	case SOAP_TYPE_PointerTons2__CollisionalTransitionType:
		return soap_out_PointerTons2__CollisionalTransitionType(soap, tag, id, (ns2__CollisionalTransitionType *const*)ptr, "ns2:CollisionalTransitionType");
	case SOAP_TYPE_PointerTons2__NonRadiativeTransitionType:
		return soap_out_PointerTons2__NonRadiativeTransitionType(soap, tag, id, (ns2__NonRadiativeTransitionType *const*)ptr, "ns2:NonRadiativeTransitionType");
	case SOAP_TYPE_PointerTons2__WavelengthWavenumberType:
		return soap_out_PointerTons2__WavelengthWavenumberType(soap, tag, id, (ns2__WavelengthWavenumberType *const*)ptr, "ns2:WavelengthWavenumberType");
	case SOAP_TYPE_PointerTons2__MultipoleType:
		return soap_out_PointerTons2__MultipoleType(soap, tag, id, (std::string *const*)ptr, "ns2:MultipoleType");
	case SOAP_TYPE_PointerTons2__RadiativeTransitionProbabilityType:
		return soap_out_PointerTons2__RadiativeTransitionProbabilityType(soap, tag, id, (ns2__RadiativeTransitionProbabilityType *const*)ptr, "ns2:RadiativeTransitionProbabilityType");
	case SOAP_TYPE_PointerTons2__StateRef:
		return soap_out_PointerTons2__StateRef(soap, tag, id, (std::string *const*)ptr, "ns2:StateRef");
	case SOAP_TYPE_PointerTons2__EnergyWavelengthType:
		return soap_out_PointerTons2__EnergyWavelengthType(soap, tag, id, (ns2__EnergyWavelengthType *const*)ptr, "ns2:EnergyWavelengthType");
	case SOAP_TYPE_PointerTons2__RadiativeTransitionType:
		return soap_out_PointerTons2__RadiativeTransitionType(soap, tag, id, (ns2__RadiativeTransitionType *const*)ptr, "ns2:RadiativeTransitionType");
	case SOAP_TYPE_PointerTons2__MaterialComponentType:
		return soap_out_PointerTons2__MaterialComponentType(soap, tag, id, (ns2__MaterialComponentType *const*)ptr, "ns2:MaterialComponentType");
	case SOAP_TYPE_PointerTons2__SolidType:
		return soap_out_PointerTons2__SolidType(soap, tag, id, (ns2__SolidType *const*)ptr, "ns2:SolidType");
	case SOAP_TYPE_PointerTons2__MaterialType:
		return soap_out_PointerTons2__MaterialType(soap, tag, id, (ns2__MaterialType *const*)ptr, "ns2:MaterialType");
	case SOAP_TYPE_PointerTons2__SimpleSymbolType:
		return soap_out_PointerTons2__SimpleSymbolType(soap, tag, id, (ns2__SimpleSymbolType *const*)ptr, "ns2:SimpleSymbolType");
	case SOAP_TYPE_PointerTons2__MoleculeType:
		return soap_out_PointerTons2__MoleculeType(soap, tag, id, (ns2__MoleculeType *const*)ptr, "ns2:MoleculeType");
	case SOAP_TYPE_PointerTons2__MolecularStateType:
		return soap_out_PointerTons2__MolecularStateType(soap, tag, id, (ns2__MolecularStateType *const*)ptr, "ns2:MolecularStateType");
	case SOAP_TYPE_PointerTons2__MolecularChemicalSpeciesType:
		return soap_out_PointerTons2__MolecularChemicalSpeciesType(soap, tag, id, (ns2__MolecularChemicalSpeciesType *const*)ptr, "ns2:MolecularChemicalSpeciesType");
	case SOAP_TYPE_PointerTons2__ElectronicHomeType:
		return soap_out_PointerTons2__ElectronicHomeType(soap, tag, id, (ns2__ElectronicHomeType *const*)ptr, "ns2:ElectronicHomeType");
	case SOAP_TYPE_PointerTons2__MolecularStateCharacterisationType:
		return soap_out_PointerTons2__MolecularStateCharacterisationType(soap, tag, id, (ns2__MolecularStateCharacterisationType *const*)ptr, "ns2:MolecularStateCharacterisationType");
	case SOAP_TYPE_PointerToxsd__IDREF:
		return soap_out_PointerToxsd__IDREF(soap, tag, id, (std::string *const*)ptr, "xsd:IDREF");
	case SOAP_TYPE_PointerTons2__ModesListType:
		return soap_out_PointerTons2__ModesListType(soap, tag, id, (enum ns2__ModesListType *const*)ptr, "ns2:ModesListType");
	case SOAP_TYPE_PointerTons2__AtomicComponentType:
		return soap_out_PointerTons2__AtomicComponentType(soap, tag, id, (ns2__AtomicComponentType *const*)ptr, "ns2:AtomicComponentType");
	case SOAP_TYPE_PointerTons2__AtomicCompositionType:
		return soap_out_PointerTons2__AtomicCompositionType(soap, tag, id, (ns2__AtomicCompositionType *const*)ptr, "ns2:AtomicCompositionType");
	case SOAP_TYPE_PointerTons2__AtomicQuantumNumbersType:
		return soap_out_PointerTons2__AtomicQuantumNumbersType(soap, tag, id, (ns2__AtomicQuantumNumbersType *const*)ptr, "ns2:AtomicQuantumNumbersType");
	case SOAP_TYPE_PointerTons2__AtomicNumericalDataType:
		return soap_out_PointerTons2__AtomicNumericalDataType(soap, tag, id, (ns2__AtomicNumericalDataType *const*)ptr, "ns2:AtomicNumericalDataType");
	case SOAP_TYPE_PointerTons2__AtomicStateType:
		return soap_out_PointerTons2__AtomicStateType(soap, tag, id, (ns2__AtomicStateType *const*)ptr, "ns2:AtomicStateType");
	case SOAP_TYPE_PointerTons2__IsotopeType:
		return soap_out_PointerTons2__IsotopeType(soap, tag, id, (ns2__IsotopeType *const*)ptr, "ns2:IsotopeType");
	case SOAP_TYPE_PointerTons2__AtomType:
		return soap_out_PointerTons2__AtomType(soap, tag, id, (ns2__AtomType *const*)ptr, "ns2:AtomType");
	case SOAP_TYPE_PointerTons2__ParametersType:
		return soap_out_PointerTons2__ParametersType(soap, tag, id, (ns2__ParametersType *const*)ptr, "ns2:ParametersType");
	case SOAP_TYPE_PointerTons2__ArgumentsType:
		return soap_out_PointerTons2__ArgumentsType(soap, tag, id, (ns2__ArgumentsType *const*)ptr, "ns2:ArgumentsType");
	case SOAP_TYPE_PointerTons2__ExpressionType:
		return soap_out_PointerTons2__ExpressionType(soap, tag, id, (ns2__ExpressionType *const*)ptr, "ns2:ExpressionType");
	case SOAP_TYPE_PointerTons2__FitParametersType:
		return soap_out_PointerTons2__FitParametersType(soap, tag, id, (ns2__FitParametersType *const*)ptr, "ns2:FitParametersType");
	case SOAP_TYPE_PointerTons2__FitValidityLimitsType:
		return soap_out_PointerTons2__FitValidityLimitsType(soap, tag, id, (ns2__FitValidityLimitsType *const*)ptr, "ns2:FitValidityLimitsType");
	case SOAP_TYPE_PointerTons2__ReferenceFrameType:
		return soap_out_PointerTons2__ReferenceFrameType(soap, tag, id, (enum ns2__ReferenceFrameType *const*)ptr, "ns2:ReferenceFrameType");
	case SOAP_TYPE_PointerTons2__DataXYType:
		return soap_out_PointerTons2__DataXYType(soap, tag, id, (ns2__DataXYType *const*)ptr, "ns2:DataXYType");
	case SOAP_TYPE_PointerTons2__TabulatedDataType:
		return soap_out_PointerTons2__TabulatedDataType(soap, tag, id, (ns2__TabulatedDataType *const*)ptr, "ns2:TabulatedDataType");
	case SOAP_TYPE_PointerTons2__FitDataType:
		return soap_out_PointerTons2__FitDataType(soap, tag, id, (ns2__FitDataType *const*)ptr, "ns2:FitDataType");
	case SOAP_TYPE_PointerTons2__ValueType:
		return soap_out_PointerTons2__ValueType(soap, tag, id, (ns2__ValueType *const*)ptr, "ns2:ValueType");
	case SOAP_TYPE_PointerTons2__ParticlesType:
		return soap_out_PointerTons2__ParticlesType(soap, tag, id, (ns2__ParticlesType *const*)ptr, "ns2:ParticlesType");
	case SOAP_TYPE_PointerTons2__SolidsType:
		return soap_out_PointerTons2__SolidsType(soap, tag, id, (ns2__SolidsType *const*)ptr, "ns2:SolidsType");
	case SOAP_TYPE_PointerTons2__MoleculesType:
		return soap_out_PointerTons2__MoleculesType(soap, tag, id, (ns2__MoleculesType *const*)ptr, "ns2:MoleculesType");
	case SOAP_TYPE_PointerTons2__AtomsType:
		return soap_out_PointerTons2__AtomsType(soap, tag, id, (ns2__AtomsType *const*)ptr, "ns2:AtomsType");
	case SOAP_TYPE_PointerTons2__CollisionsType:
		return soap_out_PointerTons2__CollisionsType(soap, tag, id, (ns2__CollisionsType *const*)ptr, "ns2:CollisionsType");
	case SOAP_TYPE_PointerTons2__NonRadiativeType:
		return soap_out_PointerTons2__NonRadiativeType(soap, tag, id, (ns2__NonRadiativeType *const*)ptr, "ns2:NonRadiativeType");
	case SOAP_TYPE_PointerTons2__RadiativeType:
		return soap_out_PointerTons2__RadiativeType(soap, tag, id, (ns2__RadiativeType *const*)ptr, "ns2:RadiativeType");
	case SOAP_TYPE_PointerTons2__FunctionsType:
		return soap_out_PointerTons2__FunctionsType(soap, tag, id, (ns2__FunctionsType *const*)ptr, "ns2:FunctionsType");
	case SOAP_TYPE_PointerTons2__MethodsType:
		return soap_out_PointerTons2__MethodsType(soap, tag, id, (ns2__MethodsType *const*)ptr, "ns2:MethodsType");
	case SOAP_TYPE_PointerTons2__SourcesType:
		return soap_out_PointerTons2__SourcesType(soap, tag, id, (ns2__SourcesType *const*)ptr, "ns2:SourcesType");
	case SOAP_TYPE_PointerTons2__ProcessesType:
		return soap_out_PointerTons2__ProcessesType(soap, tag, id, (ns2__ProcessesType *const*)ptr, "ns2:ProcessesType");
	case SOAP_TYPE_PointerTons2__StatesType:
		return soap_out_PointerTons2__StatesType(soap, tag, id, (ns2__StatesType *const*)ptr, "ns2:StatesType");
	case SOAP_TYPE_PointerTons2__IAEACodeType:
		return soap_out_PointerTons2__IAEACodeType(soap, tag, id, (enum ns2__IAEACodeType *const*)ptr, "ns2:IAEACodeType");
	case SOAP_TYPE_PointerTons2__MaterialCompositionType:
		return soap_out_PointerTons2__MaterialCompositionType(soap, tag, id, (ns2__MaterialCompositionType *const*)ptr, "ns2:MaterialCompositionType");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__ChemicalElementType:
		return soap_out_PointerTons2__ChemicalElementType(soap, tag, id, (ns2__ChemicalElementType *const*)ptr, "ns2:ChemicalElementType");
	case SOAP_TYPE_PointerTons2__ParticleNameType:
		return soap_out_PointerTons2__ParticleNameType(soap, tag, id, (enum ns2__ParticleNameType *const*)ptr, "ns2:ParticleNameType");
	case SOAP_TYPE_PointerTons2__ParticlePropertiesType:
		return soap_out_PointerTons2__ParticlePropertiesType(soap, tag, id, (ns2__ParticlePropertiesType *const*)ptr, "ns2:ParticlePropertiesType");
	case SOAP_TYPE_PointerTons2__ParticleType:
		return soap_out_PointerTons2__ParticleType(soap, tag, id, (ns2__ParticleType *const*)ptr, "ns2:ParticleType");
	case SOAP_TYPE_PointerTons2__C2SymmetriesType:
		return soap_out_PointerTons2__C2SymmetriesType(soap, tag, id, (ns2__C2SymmetriesType *const*)ptr, "ns2:C2SymmetriesType");
	case SOAP_TYPE_PointerTons2__RoVibronicSplittingType:
		return soap_out_PointerTons2__RoVibronicSplittingType(soap, tag, id, (ns2__RoVibronicSplittingType *const*)ptr, "ns2:RoVibronicSplittingType");
	case SOAP_TYPE_PointerTons2__MolecularProjectionType:
		return soap_out_PointerTons2__MolecularProjectionType(soap, tag, id, (ns2__MolecularProjectionType *const*)ptr, "ns2:MolecularProjectionType");
	case SOAP_TYPE_PointerTons2__HyperfineCouplingBType:
		return soap_out_PointerTons2__HyperfineCouplingBType(soap, tag, id, (ns2__HyperfineCouplingBType *const*)ptr, "ns2:HyperfineCouplingBType");
	case SOAP_TYPE_PointerTons2__HundCaseBType:
		return soap_out_PointerTons2__HundCaseBType(soap, tag, id, (ns2__HundCaseBType *const*)ptr, "ns2:HundCaseBType");
	case SOAP_TYPE_PointerTons2__HyperfineCaseABetaType:
		return soap_out_PointerTons2__HyperfineCaseABetaType(soap, tag, id, (ns2__HyperfineCaseABetaType *const*)ptr, "ns2:HyperfineCaseABetaType");
	case SOAP_TYPE_PointerTons2__HyperfineCaseAAlphaType:
		return soap_out_PointerTons2__HyperfineCaseAAlphaType(soap, tag, id, (ns2__HyperfineCaseAAlphaType *const*)ptr, "ns2:HyperfineCaseAAlphaType");
	case SOAP_TYPE_PointerTons2__HundCaseAType:
		return soap_out_PointerTons2__HundCaseAType(soap, tag, id, (ns2__HundCaseAType *const*)ptr, "ns2:HundCaseAType");
	case SOAP_TYPE_PointerTons2__EfSymmetryType:
		return soap_out_PointerTons2__EfSymmetryType(soap, tag, id, (enum ns2__EfSymmetryType *const*)ptr, "ns2:EfSymmetryType");
	case SOAP_TYPE_PointerTons2__HyperfineQuantumNumbersType:
		return soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, tag, id, (ns2__HyperfineQuantumNumbersType *const*)ptr, "ns2:HyperfineQuantumNumbersType");
	case SOAP_TYPE_PointerTons2__ComplexMolecularQuantumNumberType:
		return soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, tag, id, (ns2__ComplexMolecularQuantumNumberType *const*)ptr, "ns2:ComplexMolecularQuantumNumberType");
	case SOAP_TYPE_PointerTons2__VibrationalComponentType:
		return soap_out_PointerTons2__VibrationalComponentType(soap, tag, id, (ns2__VibrationalComponentType *const*)ptr, "ns2:VibrationalComponentType");
	case SOAP_TYPE_PointerTons2__RotationalHomeType:
		return soap_out_PointerTons2__RotationalHomeType(soap, tag, id, (ns2__RotationalHomeType *const*)ptr, "ns2:RotationalHomeType");
	case SOAP_TYPE_PointerTons2__VibrationalQuantumNumbersType:
		return soap_out_PointerTons2__VibrationalQuantumNumbersType(soap, tag, id, (ns2__VibrationalQuantumNumbersType *const*)ptr, "ns2:VibrationalQuantumNumbersType");
	case SOAP_TYPE_PointerTons2__VibrationalCharacterisationType:
		return soap_out_PointerTons2__VibrationalCharacterisationType(soap, tag, id, (ns2__VibrationalCharacterisationType *const*)ptr, "ns2:VibrationalCharacterisationType");
	case SOAP_TYPE_PointerTons2__CentralSymbolType:
		return soap_out_PointerTons2__CentralSymbolType(soap, tag, id, (ns2__CentralSymbolType *const*)ptr, "ns2:CentralSymbolType");
	case SOAP_TYPE_PointerTons2__RotationalComponentType:
		return soap_out_PointerTons2__RotationalComponentType(soap, tag, id, (ns2__RotationalComponentType *const*)ptr, "ns2:RotationalComponentType");
	case SOAP_TYPE_PointerTons2__RotationalCharacterisationType:
		return soap_out_PointerTons2__RotationalCharacterisationType(soap, tag, id, (ns2__RotationalCharacterisationType *const*)ptr, "ns2:RotationalCharacterisationType");
	case SOAP_TYPE_PointerTons2__NonLinearPolyatomicType:
		return soap_out_PointerTons2__NonLinearPolyatomicType(soap, tag, id, (ns2__NonLinearPolyatomicType *const*)ptr, "ns2:NonLinearPolyatomicType");
	case SOAP_TYPE_PointerTons2__DiatomAndLinearPolyatomicType:
		return soap_out_PointerTons2__DiatomAndLinearPolyatomicType(soap, tag, id, (ns2__DiatomAndLinearPolyatomicType *const*)ptr, "ns2:DiatomAndLinearPolyatomicType");
	case SOAP_TYPE_PointerTons2__PermutationSymmetryType:
		return soap_out_PointerTons2__PermutationSymmetryType(soap, tag, id, (enum ns2__PermutationSymmetryType *const*)ptr, "ns2:PermutationSymmetryType");
	case SOAP_TYPE_PointerTons2__NonLinearElecHyperFType:
		return soap_out_PointerTons2__NonLinearElecHyperFType(soap, tag, id, (ns2__NonLinearElecHyperFType *const*)ptr, "ns2:NonLinearElecHyperFType");
	case SOAP_TYPE_PointerTons2__NonLinearElecNoHyperFType:
		return soap_out_PointerTons2__NonLinearElecNoHyperFType(soap, tag, id, (ns2__NonLinearElecNoHyperFType *const*)ptr, "ns2:NonLinearElecNoHyperFType");
	case SOAP_TYPE_PointerTons2__NonLinearNoElecHyperFType:
		return soap_out_PointerTons2__NonLinearNoElecHyperFType(soap, tag, id, (ns2__NonLinearNoElecHyperFType *const*)ptr, "ns2:NonLinearNoElecHyperFType");
	case SOAP_TYPE_PointerTons2__NonLinearNoElecNoHyperFType:
		return soap_out_PointerTons2__NonLinearNoElecNoHyperFType(soap, tag, id, (ns2__NonLinearNoElecNoHyperFType *const*)ptr, "ns2:NonLinearNoElecNoHyperFType");
	case SOAP_TYPE_PointerTons2__BondArrayType:
		return soap_out_PointerTons2__BondArrayType(soap, tag, id, (ns2__BondArrayType *const*)ptr, "ns2:BondArrayType");
	case SOAP_TYPE_PointerTons2__AtomArrayType:
		return soap_out_PointerTons2__AtomArrayType(soap, tag, id, (ns2__AtomArrayType *const*)ptr, "ns2:AtomArrayType");
	case SOAP_TYPE_PointerTons2__PseudoStatisticalWeightType:
		return soap_out_PointerTons2__PseudoStatisticalWeightType(soap, tag, id, (ns2__PseudoStatisticalWeightType *const*)ptr, "ns2:PseudoStatisticalWeightType");
	case SOAP_TYPE_PointerTons2__StateEnergyType:
		return soap_out_PointerTons2__StateEnergyType(soap, tag, id, (ns2__StateEnergyType *const*)ptr, "ns2:StateEnergyType");
	case SOAP_TYPE_PointerTons2__CharacterisationType:
		return soap_out_PointerTons2__CharacterisationType(soap, tag, id, (ns2__CharacterisationType *const*)ptr, "ns2:CharacterisationType");
	case SOAP_TYPE_PointerTons2__DataType:
		return soap_out_PointerTons2__DataType(soap, tag, id, (ns2__DataType *const*)ptr, "ns2:DataType");
	case SOAP_TYPE_PointerTons2__HinderedMotionType:
		return soap_out_PointerTons2__HinderedMotionType(soap, tag, id, (ns2__HinderedMotionType *const*)ptr, "ns2:HinderedMotionType");
	case SOAP_TYPE_PointerTons2__AsymmetricProjectionType:
		return soap_out_PointerTons2__AsymmetricProjectionType(soap, tag, id, (ns2__AsymmetricProjectionType *const*)ptr, "ns2:AsymmetricProjectionType");
	case SOAP_TYPE_PointerTons2__MolecularPropertiesType:
		return soap_out_PointerTons2__MolecularPropertiesType(soap, tag, id, (ns2__MolecularPropertiesType *const*)ptr, "ns2:MolecularPropertiesType");
	case SOAP_TYPE_PointerTons2__MoleculeNuclearSpinsType:
		return soap_out_PointerTons2__MoleculeNuclearSpinsType(soap, tag, id, (ns2__MoleculeNuclearSpinsType *const*)ptr, "ns2:MoleculeNuclearSpinsType");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTons2__ElectronicComponentType:
		return soap_out_PointerTons2__ElectronicComponentType(soap, tag, id, (ns2__ElectronicComponentType *const*)ptr, "ns2:ElectronicComponentType");
	case SOAP_TYPE_PointerTons2__VibrationalHomeType:
		return soap_out_PointerTons2__VibrationalHomeType(soap, tag, id, (ns2__VibrationalHomeType *const*)ptr, "ns2:VibrationalHomeType");
	case SOAP_TYPE_PointerTons2__ElectronicCharacterisationType:
		return soap_out_PointerTons2__ElectronicCharacterisationType(soap, tag, id, (ns2__ElectronicCharacterisationType *const*)ptr, "ns2:ElectronicCharacterisationType");
	case SOAP_TYPE_PointerTons2__ReferencedTextType:
		return soap_out_PointerTons2__ReferencedTextType(soap, tag, id, (ns2__ReferencedTextType *const*)ptr, "ns2:ReferencedTextType");
	case SOAP_TYPE_PointerTons2__SymbolType:
		return soap_out_PointerTons2__SymbolType(soap, tag, id, (ns2__SymbolType *const*)ptr, "ns2:SymbolType");
	case SOAP_TYPE_PointerTons2__LinearElecCouplingType:
		return soap_out_PointerTons2__LinearElecCouplingType(soap, tag, id, (ns2__LinearElecCouplingType *const*)ptr, "ns2:LinearElecCouplingType");
	case SOAP_TYPE_PointerTons2__LinearNoElecHyperFType:
		return soap_out_PointerTons2__LinearNoElecHyperFType(soap, tag, id, (ns2__LinearNoElecHyperFType *const*)ptr, "ns2:LinearNoElecHyperFType");
	case SOAP_TYPE_PointerTons2__LinearNoElecNoHyperFType:
		return soap_out_PointerTons2__LinearNoElecNoHyperFType(soap, tag, id, (ns2__LinearNoElecNoHyperFType *const*)ptr, "ns2:LinearNoElecNoHyperFType");
	case SOAP_TYPE_PointerTons2__BondType:
		return soap_out_PointerTons2__BondType(soap, tag, id, (ns2__BondType *const*)ptr, "ns2:BondType");
	case SOAP_TYPE_PointerToxsd__IDREFS:
		return soap_out_PointerToxsd__IDREFS(soap, tag, id, (std::string *const*)ptr, "xsd:IDREFS");
	case SOAP_TYPE_PointerTons2__AtomNType:
		return soap_out_PointerTons2__AtomNType(soap, tag, id, (ns2__AtomNType *const*)ptr, "ns2:AtomNType");
	case SOAP_TYPE_PointerTons2__MolecularQuantumNumberType:
		return soap_out_PointerTons2__MolecularQuantumNumberType(soap, tag, id, (ns2__MolecularQuantumNumberType *const*)ptr, "ns2:MolecularQuantumNumberType");
	case SOAP_TYPE_PointerTons2__MagneticQuantumNumberType:
		return soap_out_PointerTons2__MagneticQuantumNumberType(soap, tag, id, (ns2__MagneticQuantumNumberType *const*)ptr, "ns2:MagneticQuantumNumberType");
	case SOAP_TYPE_PointerTons2__SuperShellType:
		return soap_out_PointerTons2__SuperShellType(soap, tag, id, (ns2__SuperShellType *const*)ptr, "ns2:SuperShellType");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_PointerTons2__ShellPairType:
		return soap_out_PointerTons2__ShellPairType(soap, tag, id, (ns2__ShellPairType *const*)ptr, "ns2:ShellPairType");
	case SOAP_TYPE_PointerTons2__ShellType:
		return soap_out_PointerTons2__ShellType(soap, tag, id, (ns2__ShellType *const*)ptr, "ns2:ShellType");
	case SOAP_TYPE_PointerTons2__ShellsType:
		return soap_out_PointerTons2__ShellsType(soap, tag, id, (ns2__ShellsType *const*)ptr, "ns2:ShellsType");
	case SOAP_TYPE_PointerTons2__AtomicCoreType:
		return soap_out_PointerTons2__AtomicCoreType(soap, tag, id, (ns2__AtomicCoreType *const*)ptr, "ns2:AtomicCoreType");
	case SOAP_TYPE_PointerTons2__AngularMomentumProjectionType:
		return soap_out_PointerTons2__AngularMomentumProjectionType(soap, tag, id, (std::string *const*)ptr, "ns2:AngularMomentumProjectionType");
	case SOAP_TYPE_PointerTons2__ParityType:
		return soap_out_PointerTons2__ParityType(soap, tag, id, (enum ns2__ParityType *const*)ptr, "ns2:ParityType");
	case SOAP_TYPE_PointerTons2__MixingCoefficientType:
		return soap_out_PointerTons2__MixingCoefficientType(soap, tag, id, (ns2__MixingCoefficientType *const*)ptr, "ns2:MixingCoefficientType");
	case SOAP_TYPE_PointerTons2__SuperConfigurationType:
		return soap_out_PointerTons2__SuperConfigurationType(soap, tag, id, (ns2__SuperConfigurationType *const*)ptr, "ns2:SuperConfigurationType");
	case SOAP_TYPE_PointerTons2__TermType:
		return soap_out_PointerTons2__TermType(soap, tag, id, (ns2__TermType *const*)ptr, "ns2:TermType");
	case SOAP_TYPE_PointerTons2__ConfigurationType:
		return soap_out_PointerTons2__ConfigurationType(soap, tag, id, (ns2__ConfigurationType *const*)ptr, "ns2:ConfigurationType");
	case SOAP_TYPE_PointerTons2__IonStateType:
		return soap_out_PointerTons2__IonStateType(soap, tag, id, (ns2__IonStateType *const*)ptr, "ns2:IonStateType");
	case SOAP_TYPE_PointerTons2__IsotopeParametersType:
		return soap_out_PointerTons2__IsotopeParametersType(soap, tag, id, (ns2__IsotopeParametersType *const*)ptr, "ns2:IsotopeParametersType");
	case SOAP_TYPE_PointerTons2__FunctionType:
		return soap_out_PointerTons2__FunctionType(soap, tag, id, (ns2__FunctionType *const*)ptr, "ns2:FunctionType");
	case SOAP_TYPE_PointerTo_ns2__functionRef:
		return soap_out_PointerTo_ns2__functionRef(soap, tag, id, (std::string *const*)ptr, "ns2:functionRef");
	case SOAP_TYPE_PointerTons2__MethodType:
		return soap_out_PointerTons2__MethodType(soap, tag, id, (ns2__MethodType *const*)ptr, "ns2:MethodType");
	case SOAP_TYPE_PointerTons2__AuthorType:
		return soap_out_PointerTons2__AuthorType(soap, tag, id, (ns2__AuthorType *const*)ptr, "ns2:AuthorType");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_out_PointerToxsd__date(soap, tag, id, (std::string *const*)ptr, "xsd:date");
	case SOAP_TYPE_PointerTons2__EditorsType:
		return soap_out_PointerTons2__EditorsType(soap, tag, id, (ns2__EditorsType *const*)ptr, "ns2:EditorsType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_out_PointerToxsd__token(soap, tag, id, (std::string *const*)ptr, "xsd:token");
	case SOAP_TYPE_PointerTons2__AuthorsType:
		return soap_out_PointerTons2__AuthorsType(soap, tag, id, (ns2__AuthorsType *const*)ptr, "ns2:AuthorsType");
	case SOAP_TYPE_PointerTons2__SourceType:
		return soap_out_PointerTons2__SourceType(soap, tag, id, (ns2__SourceType *const*)ptr, "ns2:SourceType");
	case SOAP_TYPE_PointerTons2__LKCouplingType:
		return soap_out_PointerTons2__LKCouplingType(soap, tag, id, (ns2__LKCouplingType *const*)ptr, "ns2:LKCouplingType");
	case SOAP_TYPE_PointerTons2__jKCouplingType:
		return soap_out_PointerTons2__jKCouplingType(soap, tag, id, (ns2__jKCouplingType *const*)ptr, "ns2:jKCouplingType");
	case SOAP_TYPE_PointerTons2__jjCouplingType:
		return soap_out_PointerTons2__jjCouplingType(soap, tag, id, (ns2__jjCouplingType *const*)ptr, "ns2:jjCouplingType");
	case SOAP_TYPE_PointerTons2__LSCouplingType:
		return soap_out_PointerTons2__LSCouplingType(soap, tag, id, (ns2__LSCouplingType *const*)ptr, "ns2:LSCouplingType");
	case SOAP_TYPE_PointerTons2__OrbitalAngularMomentumSymbolType:
		return soap_out_PointerTons2__OrbitalAngularMomentumSymbolType(soap, tag, id, (std::string *const*)ptr, "ns2:OrbitalAngularMomentumSymbolType");
	case SOAP_TYPE_PointerTo_ns2__LSCouplingType_Seniority:
		return soap_out_PointerTo_ns2__LSCouplingType_Seniority(soap, tag, id, (_ns2__LSCouplingType_Seniority *const*)ptr, "ns2:LSCouplingType-Seniority");
	case SOAP_TYPE_PointerToxsd__positiveInteger:
		return soap_out_PointerToxsd__positiveInteger(soap, tag, id, (std::string *const*)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_PointerTons2__OrbitalAngularMomentumType:
		return soap_out_PointerTons2__OrbitalAngularMomentumType(soap, tag, id, (ns2__OrbitalAngularMomentumType *const*)ptr, "ns2:OrbitalAngularMomentumType");
	case SOAP_TYPE_PointerTons2__AngularMomentumType:
		return soap_out_PointerTons2__AngularMomentumType(soap, tag, id, (std::string *const*)ptr, "ns2:AngularMomentumType");
	case SOAP_TYPE_PointerTons2__ParameterType:
		return soap_out_PointerTons2__ParameterType(soap, tag, id, (ns2__ParameterType *const*)ptr, "ns2:ParameterType");
	case SOAP_TYPE_PointerTons2__ArgumentType:
		return soap_out_PointerTons2__ArgumentType(soap, tag, id, (ns2__ArgumentType *const*)ptr, "ns2:ArgumentType");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTons2__DataTableType:
		return soap_out_PointerTons2__DataTableType(soap, tag, id, (ns2__DataTableType *const*)ptr, "ns2:DataTableType");
	case SOAP_TYPE_PointerTons2__DataListType:
		return soap_out_PointerTons2__DataListType(soap, tag, id, (std::string *const*)ptr, "ns2:DataListType");
	case SOAP_TYPE_PointerTons2__DataSetType:
		return soap_out_PointerTons2__DataSetType(soap, tag, id, (ns2__DataSetType *const*)ptr, "ns2:DataSetType");
	case SOAP_TYPE_PointerTons2__ElementSymbolType:
		return soap_out_PointerTons2__ElementSymbolType(soap, tag, id, (std::string *const*)ptr, "ns2:ElementSymbolType");
	case SOAP_TYPE_PointerTo_ns2__methodRef:
		return soap_out_PointerTo_ns2__methodRef(soap, tag, id, (std::string *const*)ptr, "ns2:methodRef");
	case SOAP_TYPE_PointerTo_ns2__sourceRef:
		return soap_out_PointerTo_ns2__sourceRef(soap, tag, id, (std::string *const*)ptr, "ns2:sourceRef");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns2__RoVibronicSplittingType_sequence:
		((__ns2__RoVibronicSplittingType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType:
		((__ns2__union_HyperfineQuantumNumbersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__MolecularPropertiesType_sequence:
		((__ns2__MolecularPropertiesType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__BondArrayType_sequence:
		((__ns2__BondArrayType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__AtomArrayType_sequence:
		((__ns2__AtomArrayType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__ShellsType_sequence:
		((__ns2__ShellsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__ProductsType_sequence:
		((__ns2__ProductsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__ReactantsType_sequence:
		((__ns2__ReactantsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__LSCouplingType_Seniority:
		((_ns2__LSCouplingType_Seniority *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__functionID:
		soap_serialize__ns2__functionID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns2__methodID:
		soap_serialize__ns2__methodID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns2__sourceID:
		soap_serialize__ns2__sourceID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns2__stateID:
		soap_serialize__ns2__stateID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns2__functionRef:
		soap_serialize__ns2__functionRef(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns2__methodRef:
		soap_serialize__ns2__methodRef(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns2__sourceRef:
		soap_serialize__ns2__sourceRef(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__MultipoleType:
		soap_serialize_ns2__MultipoleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__StateRef:
		soap_serialize_ns2__StateRef(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType:
		soap_serialize_ns2__OrbitalAngularMomentumSymbolType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__PrincipalQuantumNumberType:
		soap_serialize_ns2__PrincipalQuantumNumberType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__ElementSymbolType:
		soap_serialize_ns2__ElementSymbolType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__AngularMomentumType:
		soap_serialize_ns2__AngularMomentumType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__AngularMomentumProjectionType:
		soap_serialize_ns2__AngularMomentumProjectionType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__DataListType:
		soap_serialize_ns2__DataListType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__StatesType:
		((ns2__StatesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ProcessesType:
		((ns2__ProcessesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__XSAMSDataType:
		((ns2__XSAMSDataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CollisionalProcessClassType:
		((ns2__CollisionalProcessClassType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CollisionalTransitionType:
		((ns2__CollisionalTransitionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CollisionsType:
		((ns2__CollisionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonRadiativeTransitionType:
		((ns2__NonRadiativeTransitionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonRadiativeType:
		((ns2__NonRadiativeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EnergyWavelengthType:
		((ns2__EnergyWavelengthType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__WavelengthWavenumberType:
		((ns2__WavelengthWavenumberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RadiativeTransitionProbabilityType:
		((ns2__RadiativeTransitionProbabilityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RadiativeTransitionType:
		((ns2__RadiativeTransitionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RadiativeType:
		((ns2__RadiativeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MaterialCompositionType:
		((ns2__MaterialCompositionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MaterialType:
		((ns2__MaterialType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MaterialComponentType:
		((ns2__MaterialComponentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SolidsType:
		((ns2__SolidsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SolidType:
		((ns2__SolidType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParticlePropertiesType:
		((ns2__ParticlePropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParticleType:
		((ns2__ParticleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParticlesType:
		((ns2__ParticlesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CharacterisationType:
		((ns2__CharacterisationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReferencedTextType:
		((ns2__ReferencedTextType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HyperfineQuantumNumbersType:
		((ns2__HyperfineQuantumNumbersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearNoElecHyperFType:
		((ns2__NonLinearNoElecHyperFType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType:
		((ns2__NonLinearNoElecNoHyperFType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearNoElecType:
		((ns2__NonLinearNoElecType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearElecNoHyperFType:
		((ns2__NonLinearElecNoHyperFType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearElecHyperFType:
		((ns2__NonLinearElecHyperFType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearElecCouplingType:
		((ns2__NonLinearElecCouplingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HyperfineCouplingBType:
		((ns2__HyperfineCouplingBType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HyperfineCaseABetaType:
		((ns2__HyperfineCaseABetaType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HyperfineCaseAAlphaType:
		((ns2__HyperfineCaseAAlphaType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HundCaseBType:
		((ns2__HundCaseBType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HundCaseAType:
		((ns2__HundCaseAType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LinearElecCouplingType:
		((ns2__LinearElecCouplingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LinearNoElecHyperFType:
		((ns2__LinearNoElecHyperFType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LinearNoElecNoHyperFType:
		((ns2__LinearNoElecNoHyperFType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VibrationalQuantumNumbersType:
		((ns2__VibrationalQuantumNumbersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VibrationalHomeType:
		((ns2__VibrationalHomeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VibrationalCharacterisationType:
		((ns2__VibrationalCharacterisationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VibrationalComponentType:
		((ns2__VibrationalComponentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TotalSpinMomentumSType:
		((ns2__TotalSpinMomentumSType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SymbolType:
		((ns2__SymbolType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__StateEnergyType:
		((ns2__StateEnergyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SimpleSymbolType:
		((ns2__SimpleSymbolType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MagneticQuantumNumberType:
		((ns2__MagneticQuantumNumberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularQuantumNumberType:
		((ns2__MolecularQuantumNumberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RoVibronicSplittingType:
		((ns2__RoVibronicSplittingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PseudoStatisticalWeightType:
		((ns2__PseudoStatisticalWeightType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RotationalHomeType:
		((ns2__RotationalHomeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RotationalComponentType:
		((ns2__RotationalComponentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RotationalCharacterisationType:
		((ns2__RotationalCharacterisationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NonLinearPolyatomicType:
		((ns2__NonLinearPolyatomicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MoleculesType:
		((ns2__MoleculesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MoleculeNuclearSpinsType:
		((ns2__MoleculeNuclearSpinsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MoleculeType:
		((ns2__MoleculeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType:
		((ns2__MolecularStateCharacterisation_oldType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularStateCharacterisationType:
		((ns2__MolecularStateCharacterisationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularStateType:
		((ns2__MolecularStateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularPropertiesType:
		((ns2__MolecularPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularProjectionType:
		((ns2__MolecularProjectionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MolecularChemicalSpeciesType:
		((ns2__MolecularChemicalSpeciesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ElectronicHomeType:
		((ns2__ElectronicHomeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ElectronicComponentType:
		((ns2__ElectronicComponentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ElectronicCharacterisationType:
		((ns2__ElectronicCharacterisationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType:
		((ns2__DiatomAndLinearPolyatomicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType:
		((ns2__ComplexMolecularQuantumNumberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CentralSymbolType:
		((ns2__CentralSymbolType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__C2SymmetriesType:
		((ns2__C2SymmetriesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BondArrayType:
		((ns2__BondArrayType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BondType:
		((ns2__BondType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomNType:
		((ns2__AtomNType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomArrayType:
		((ns2__AtomArrayType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HinderedMotionType:
		((ns2__HinderedMotionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AsymmetricProjectionType:
		((ns2__AsymmetricProjectionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SuperShellType:
		((ns2__SuperShellType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SuperConfigurationType:
		((ns2__SuperConfigurationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ShellType:
		((ns2__ShellType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ShellPairType:
		((ns2__ShellPairType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ShellsType:
		((ns2__ShellsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ConfigurationType:
		((ns2__ConfigurationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomicQuantumNumbersType:
		((ns2__AtomicQuantumNumbersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomicComponentType:
		((ns2__AtomicComponentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomicCoreType:
		((ns2__AtomicCoreType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomicCompositionType:
		((ns2__AtomicCompositionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomicNumericalDataType:
		((ns2__AtomicNumericalDataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomicStateType:
		((ns2__AtomicStateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__IonStateType:
		((ns2__IonStateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__IsotopeParametersType:
		((ns2__IsotopeParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__IsotopeType:
		((ns2__IsotopeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomType:
		((ns2__AtomType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AtomsType:
		((ns2__AtomsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FunctionType:
		((ns2__FunctionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FunctionsType:
		((ns2__FunctionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MethodType:
		((ns2__MethodType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MethodsType:
		((ns2__MethodsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EditorsType:
		((ns2__EditorsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AuthorsType:
		((ns2__AuthorsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SourceType:
		((ns2__SourceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SourcesType:
		((ns2__SourcesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AuthorType:
		((ns2__AuthorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ProductsType:
		((ns2__ProductsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReactantsType:
		((ns2__ReactantsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TermType:
		((ns2__TermType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OrbitalAngularMomentumType:
		((ns2__OrbitalAngularMomentumType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MixingCoefficientType:
		((ns2__MixingCoefficientType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LSCouplingType:
		((ns2__LSCouplingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LKCouplingType:
		((ns2__LKCouplingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__jKCouplingType:
		((ns2__jKCouplingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__jjCouplingType:
		((ns2__jjCouplingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueType:
		((ns2__ValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParameterType:
		((ns2__ParameterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParametersType:
		((ns2__ParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArgumentType:
		((ns2__ArgumentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArgumentsType:
		((ns2__ArgumentsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ExpressionType:
		((ns2__ExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FitValidityLimitsType:
		((ns2__FitValidityLimitsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FitParametersType:
		((ns2__FitParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FitDataType:
		((ns2__FitDataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TabulatedDataType:
		((ns2__TabulatedDataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataXYType:
		((ns2__DataXYType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataTableType:
		((ns2__DataTableType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataSetsType:
		((ns2__DataSetsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataSetType:
		((ns2__DataSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataType:
		((ns2__DataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ChemicalElementType:
		((ns2__ChemicalElementType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PrimaryType:
		((ns2__PrimaryType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_serialize_xsd__positiveInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__gYear:
		soap_serialize_xsd__gYear(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__IDREFS:
		soap_serialize_xsd__IDREFS(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__IDREF:
		soap_serialize_xsd__IDREF(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__DataTableType:
		soap_serialize_xsd__DataTableType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__getS:
		soap_serialize_ns2__getS(soap, (const struct ns2__getS *)ptr);
		break;
	case SOAP_TYPE_ns2__getSResponse:
		soap_serialize_ns2__getSResponse(soap, (const struct ns2__getSResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataSetsType:
		soap_serialize_PointerTons2__DataSetsType(soap, (ns2__DataSetsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ProductsType:
		soap_serialize_PointerTons2__ProductsType(soap, (ns2__ProductsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReactantsType:
		soap_serialize_PointerTons2__ReactantsType(soap, (ns2__ReactantsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CollisionalProcessClassType:
		soap_serialize_PointerTons2__CollisionalProcessClassType(soap, (ns2__CollisionalProcessClassType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CollisionalTransitionType:
		soap_serialize_PointerTons2__CollisionalTransitionType(soap, (ns2__CollisionalTransitionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonRadiativeTransitionType:
		soap_serialize_PointerTons2__NonRadiativeTransitionType(soap, (ns2__NonRadiativeTransitionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WavelengthWavenumberType:
		soap_serialize_PointerTons2__WavelengthWavenumberType(soap, (ns2__WavelengthWavenumberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MultipoleType:
		soap_serialize_PointerTons2__MultipoleType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RadiativeTransitionProbabilityType:
		soap_serialize_PointerTons2__RadiativeTransitionProbabilityType(soap, (ns2__RadiativeTransitionProbabilityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StateRef:
		soap_serialize_PointerTons2__StateRef(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EnergyWavelengthType:
		soap_serialize_PointerTons2__EnergyWavelengthType(soap, (ns2__EnergyWavelengthType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RadiativeTransitionType:
		soap_serialize_PointerTons2__RadiativeTransitionType(soap, (ns2__RadiativeTransitionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MaterialComponentType:
		soap_serialize_PointerTons2__MaterialComponentType(soap, (ns2__MaterialComponentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SolidType:
		soap_serialize_PointerTons2__SolidType(soap, (ns2__SolidType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MaterialType:
		soap_serialize_PointerTons2__MaterialType(soap, (ns2__MaterialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SimpleSymbolType:
		soap_serialize_PointerTons2__SimpleSymbolType(soap, (ns2__SimpleSymbolType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MoleculeType:
		soap_serialize_PointerTons2__MoleculeType(soap, (ns2__MoleculeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MolecularStateType:
		soap_serialize_PointerTons2__MolecularStateType(soap, (ns2__MolecularStateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MolecularChemicalSpeciesType:
		soap_serialize_PointerTons2__MolecularChemicalSpeciesType(soap, (ns2__MolecularChemicalSpeciesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ElectronicHomeType:
		soap_serialize_PointerTons2__ElectronicHomeType(soap, (ns2__ElectronicHomeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MolecularStateCharacterisationType:
		soap_serialize_PointerTons2__MolecularStateCharacterisationType(soap, (ns2__MolecularStateCharacterisationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__IDREF:
		soap_serialize_PointerToxsd__IDREF(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ModesListType:
		soap_serialize_PointerTons2__ModesListType(soap, (enum ns2__ModesListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomicComponentType:
		soap_serialize_PointerTons2__AtomicComponentType(soap, (ns2__AtomicComponentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomicCompositionType:
		soap_serialize_PointerTons2__AtomicCompositionType(soap, (ns2__AtomicCompositionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomicQuantumNumbersType:
		soap_serialize_PointerTons2__AtomicQuantumNumbersType(soap, (ns2__AtomicQuantumNumbersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomicNumericalDataType:
		soap_serialize_PointerTons2__AtomicNumericalDataType(soap, (ns2__AtomicNumericalDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomicStateType:
		soap_serialize_PointerTons2__AtomicStateType(soap, (ns2__AtomicStateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IsotopeType:
		soap_serialize_PointerTons2__IsotopeType(soap, (ns2__IsotopeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomType:
		soap_serialize_PointerTons2__AtomType(soap, (ns2__AtomType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParametersType:
		soap_serialize_PointerTons2__ParametersType(soap, (ns2__ParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArgumentsType:
		soap_serialize_PointerTons2__ArgumentsType(soap, (ns2__ArgumentsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExpressionType:
		soap_serialize_PointerTons2__ExpressionType(soap, (ns2__ExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FitParametersType:
		soap_serialize_PointerTons2__FitParametersType(soap, (ns2__FitParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FitValidityLimitsType:
		soap_serialize_PointerTons2__FitValidityLimitsType(soap, (ns2__FitValidityLimitsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReferenceFrameType:
		soap_serialize_PointerTons2__ReferenceFrameType(soap, (enum ns2__ReferenceFrameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataXYType:
		soap_serialize_PointerTons2__DataXYType(soap, (ns2__DataXYType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TabulatedDataType:
		soap_serialize_PointerTons2__TabulatedDataType(soap, (ns2__TabulatedDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FitDataType:
		soap_serialize_PointerTons2__FitDataType(soap, (ns2__FitDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueType:
		soap_serialize_PointerTons2__ValueType(soap, (ns2__ValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParticlesType:
		soap_serialize_PointerTons2__ParticlesType(soap, (ns2__ParticlesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SolidsType:
		soap_serialize_PointerTons2__SolidsType(soap, (ns2__SolidsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MoleculesType:
		soap_serialize_PointerTons2__MoleculesType(soap, (ns2__MoleculesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomsType:
		soap_serialize_PointerTons2__AtomsType(soap, (ns2__AtomsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CollisionsType:
		soap_serialize_PointerTons2__CollisionsType(soap, (ns2__CollisionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonRadiativeType:
		soap_serialize_PointerTons2__NonRadiativeType(soap, (ns2__NonRadiativeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RadiativeType:
		soap_serialize_PointerTons2__RadiativeType(soap, (ns2__RadiativeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FunctionsType:
		soap_serialize_PointerTons2__FunctionsType(soap, (ns2__FunctionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MethodsType:
		soap_serialize_PointerTons2__MethodsType(soap, (ns2__MethodsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SourcesType:
		soap_serialize_PointerTons2__SourcesType(soap, (ns2__SourcesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ProcessesType:
		soap_serialize_PointerTons2__ProcessesType(soap, (ns2__ProcessesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StatesType:
		soap_serialize_PointerTons2__StatesType(soap, (ns2__StatesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IAEACodeType:
		soap_serialize_PointerTons2__IAEACodeType(soap, (enum ns2__IAEACodeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MaterialCompositionType:
		soap_serialize_PointerTons2__MaterialCompositionType(soap, (ns2__MaterialCompositionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ChemicalElementType:
		soap_serialize_PointerTons2__ChemicalElementType(soap, (ns2__ChemicalElementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParticleNameType:
		soap_serialize_PointerTons2__ParticleNameType(soap, (enum ns2__ParticleNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParticlePropertiesType:
		soap_serialize_PointerTons2__ParticlePropertiesType(soap, (ns2__ParticlePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParticleType:
		soap_serialize_PointerTons2__ParticleType(soap, (ns2__ParticleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_HyperfineQuantumNumbersType:
		soap_serialize_PointerTo__ns2__union_HyperfineQuantumNumbersType(soap, (__ns2__union_HyperfineQuantumNumbersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__C2SymmetriesType:
		soap_serialize_PointerTons2__C2SymmetriesType(soap, (ns2__C2SymmetriesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RoVibronicSplittingType:
		soap_serialize_PointerTons2__RoVibronicSplittingType(soap, (ns2__RoVibronicSplittingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MolecularProjectionType:
		soap_serialize_PointerTons2__MolecularProjectionType(soap, (ns2__MolecularProjectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HyperfineCouplingBType:
		soap_serialize_PointerTons2__HyperfineCouplingBType(soap, (ns2__HyperfineCouplingBType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HundCaseBType:
		soap_serialize_PointerTons2__HundCaseBType(soap, (ns2__HundCaseBType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HyperfineCaseABetaType:
		soap_serialize_PointerTons2__HyperfineCaseABetaType(soap, (ns2__HyperfineCaseABetaType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HyperfineCaseAAlphaType:
		soap_serialize_PointerTons2__HyperfineCaseAAlphaType(soap, (ns2__HyperfineCaseAAlphaType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HundCaseAType:
		soap_serialize_PointerTons2__HundCaseAType(soap, (ns2__HundCaseAType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EfSymmetryType:
		soap_serialize_PointerTons2__EfSymmetryType(soap, (enum ns2__EfSymmetryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HyperfineQuantumNumbersType:
		soap_serialize_PointerTons2__HyperfineQuantumNumbersType(soap, (ns2__HyperfineQuantumNumbersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ComplexMolecularQuantumNumberType:
		soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, (ns2__ComplexMolecularQuantumNumberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VibrationalComponentType:
		soap_serialize_PointerTons2__VibrationalComponentType(soap, (ns2__VibrationalComponentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RotationalHomeType:
		soap_serialize_PointerTons2__RotationalHomeType(soap, (ns2__RotationalHomeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VibrationalQuantumNumbersType:
		soap_serialize_PointerTons2__VibrationalQuantumNumbersType(soap, (ns2__VibrationalQuantumNumbersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VibrationalCharacterisationType:
		soap_serialize_PointerTons2__VibrationalCharacterisationType(soap, (ns2__VibrationalCharacterisationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CentralSymbolType:
		soap_serialize_PointerTons2__CentralSymbolType(soap, (ns2__CentralSymbolType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RotationalComponentType:
		soap_serialize_PointerTons2__RotationalComponentType(soap, (ns2__RotationalComponentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RotationalCharacterisationType:
		soap_serialize_PointerTons2__RotationalCharacterisationType(soap, (ns2__RotationalCharacterisationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonLinearPolyatomicType:
		soap_serialize_PointerTons2__NonLinearPolyatomicType(soap, (ns2__NonLinearPolyatomicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DiatomAndLinearPolyatomicType:
		soap_serialize_PointerTons2__DiatomAndLinearPolyatomicType(soap, (ns2__DiatomAndLinearPolyatomicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PermutationSymmetryType:
		soap_serialize_PointerTons2__PermutationSymmetryType(soap, (enum ns2__PermutationSymmetryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonLinearElecHyperFType:
		soap_serialize_PointerTons2__NonLinearElecHyperFType(soap, (ns2__NonLinearElecHyperFType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonLinearElecNoHyperFType:
		soap_serialize_PointerTons2__NonLinearElecNoHyperFType(soap, (ns2__NonLinearElecNoHyperFType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonLinearNoElecHyperFType:
		soap_serialize_PointerTons2__NonLinearNoElecHyperFType(soap, (ns2__NonLinearNoElecHyperFType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NonLinearNoElecNoHyperFType:
		soap_serialize_PointerTons2__NonLinearNoElecNoHyperFType(soap, (ns2__NonLinearNoElecNoHyperFType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BondArrayType:
		soap_serialize_PointerTons2__BondArrayType(soap, (ns2__BondArrayType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomArrayType:
		soap_serialize_PointerTons2__AtomArrayType(soap, (ns2__AtomArrayType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PseudoStatisticalWeightType:
		soap_serialize_PointerTons2__PseudoStatisticalWeightType(soap, (ns2__PseudoStatisticalWeightType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StateEnergyType:
		soap_serialize_PointerTons2__StateEnergyType(soap, (ns2__StateEnergyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CharacterisationType:
		soap_serialize_PointerTons2__CharacterisationType(soap, (ns2__CharacterisationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataType:
		soap_serialize_PointerTons2__DataType(soap, (ns2__DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HinderedMotionType:
		soap_serialize_PointerTons2__HinderedMotionType(soap, (ns2__HinderedMotionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AsymmetricProjectionType:
		soap_serialize_PointerTons2__AsymmetricProjectionType(soap, (ns2__AsymmetricProjectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MolecularPropertiesType:
		soap_serialize_PointerTons2__MolecularPropertiesType(soap, (ns2__MolecularPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MoleculeNuclearSpinsType:
		soap_serialize_PointerTons2__MoleculeNuclearSpinsType(soap, (ns2__MoleculeNuclearSpinsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ElectronicComponentType:
		soap_serialize_PointerTons2__ElectronicComponentType(soap, (ns2__ElectronicComponentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VibrationalHomeType:
		soap_serialize_PointerTons2__VibrationalHomeType(soap, (ns2__VibrationalHomeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ElectronicCharacterisationType:
		soap_serialize_PointerTons2__ElectronicCharacterisationType(soap, (ns2__ElectronicCharacterisationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReferencedTextType:
		soap_serialize_PointerTons2__ReferencedTextType(soap, (ns2__ReferencedTextType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SymbolType:
		soap_serialize_PointerTons2__SymbolType(soap, (ns2__SymbolType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LinearElecCouplingType:
		soap_serialize_PointerTons2__LinearElecCouplingType(soap, (ns2__LinearElecCouplingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LinearNoElecHyperFType:
		soap_serialize_PointerTons2__LinearNoElecHyperFType(soap, (ns2__LinearNoElecHyperFType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LinearNoElecNoHyperFType:
		soap_serialize_PointerTons2__LinearNoElecNoHyperFType(soap, (ns2__LinearNoElecNoHyperFType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BondType:
		soap_serialize_PointerTons2__BondType(soap, (ns2__BondType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__IDREFS:
		soap_serialize_PointerToxsd__IDREFS(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomNType:
		soap_serialize_PointerTons2__AtomNType(soap, (ns2__AtomNType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MolecularQuantumNumberType:
		soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, (ns2__MolecularQuantumNumberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MagneticQuantumNumberType:
		soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, (ns2__MagneticQuantumNumberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SuperShellType:
		soap_serialize_PointerTons2__SuperShellType(soap, (ns2__SuperShellType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShellPairType:
		soap_serialize_PointerTons2__ShellPairType(soap, (ns2__ShellPairType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShellType:
		soap_serialize_PointerTons2__ShellType(soap, (ns2__ShellType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShellsType:
		soap_serialize_PointerTons2__ShellsType(soap, (ns2__ShellsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AtomicCoreType:
		soap_serialize_PointerTons2__AtomicCoreType(soap, (ns2__AtomicCoreType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AngularMomentumProjectionType:
		soap_serialize_PointerTons2__AngularMomentumProjectionType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParityType:
		soap_serialize_PointerTons2__ParityType(soap, (enum ns2__ParityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MixingCoefficientType:
		soap_serialize_PointerTons2__MixingCoefficientType(soap, (ns2__MixingCoefficientType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SuperConfigurationType:
		soap_serialize_PointerTons2__SuperConfigurationType(soap, (ns2__SuperConfigurationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TermType:
		soap_serialize_PointerTons2__TermType(soap, (ns2__TermType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConfigurationType:
		soap_serialize_PointerTons2__ConfigurationType(soap, (ns2__ConfigurationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IonStateType:
		soap_serialize_PointerTons2__IonStateType(soap, (ns2__IonStateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IsotopeParametersType:
		soap_serialize_PointerTons2__IsotopeParametersType(soap, (ns2__IsotopeParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FunctionType:
		soap_serialize_PointerTons2__FunctionType(soap, (ns2__FunctionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__functionRef:
		soap_serialize_PointerTo_ns2__functionRef(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MethodType:
		soap_serialize_PointerTons2__MethodType(soap, (ns2__MethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AuthorType:
		soap_serialize_PointerTons2__AuthorType(soap, (ns2__AuthorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__date:
		soap_serialize_PointerToxsd__date(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EditorsType:
		soap_serialize_PointerTons2__EditorsType(soap, (ns2__EditorsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__token:
		soap_serialize_PointerToxsd__token(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AuthorsType:
		soap_serialize_PointerTons2__AuthorsType(soap, (ns2__AuthorsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SourceType:
		soap_serialize_PointerTons2__SourceType(soap, (ns2__SourceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LKCouplingType:
		soap_serialize_PointerTons2__LKCouplingType(soap, (ns2__LKCouplingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__jKCouplingType:
		soap_serialize_PointerTons2__jKCouplingType(soap, (ns2__jKCouplingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__jjCouplingType:
		soap_serialize_PointerTons2__jjCouplingType(soap, (ns2__jjCouplingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LSCouplingType:
		soap_serialize_PointerTons2__LSCouplingType(soap, (ns2__LSCouplingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OrbitalAngularMomentumSymbolType:
		soap_serialize_PointerTons2__OrbitalAngularMomentumSymbolType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__LSCouplingType_Seniority:
		soap_serialize_PointerTo_ns2__LSCouplingType_Seniority(soap, (_ns2__LSCouplingType_Seniority *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__positiveInteger:
		soap_serialize_PointerToxsd__positiveInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OrbitalAngularMomentumType:
		soap_serialize_PointerTons2__OrbitalAngularMomentumType(soap, (ns2__OrbitalAngularMomentumType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AngularMomentumType:
		soap_serialize_PointerTons2__AngularMomentumType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParameterType:
		soap_serialize_PointerTons2__ParameterType(soap, (ns2__ParameterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArgumentType:
		soap_serialize_PointerTons2__ArgumentType(soap, (ns2__ArgumentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataTableType:
		soap_serialize_PointerTons2__DataTableType(soap, (ns2__DataTableType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataListType:
		soap_serialize_PointerTons2__DataListType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataSetType:
		soap_serialize_PointerTons2__DataSetType(soap, (ns2__DataSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ElementSymbolType:
		soap_serialize_PointerTons2__ElementSymbolType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__methodRef:
		soap_serialize_PointerTo_ns2__methodRef(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__sourceRef:
		soap_serialize_PointerTo_ns2__sourceRef(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PrimaryType:
		return (void*)soap_instantiate_ns2__PrimaryType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ChemicalElementType:
		return (void*)soap_instantiate_ns2__ChemicalElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataSetsType:
		return (void*)soap_instantiate_ns2__DataSetsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataTableType:
		return (void*)soap_instantiate_ns2__DataTableType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataXYType:
		return (void*)soap_instantiate_ns2__DataXYType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FitParametersType:
		return (void*)soap_instantiate_ns2__FitParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FitValidityLimitsType:
		return (void*)soap_instantiate_ns2__FitValidityLimitsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArgumentsType:
		return (void*)soap_instantiate_ns2__ArgumentsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArgumentType:
		return (void*)soap_instantiate_ns2__ArgumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParametersType:
		return (void*)soap_instantiate_ns2__ParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParameterType:
		return (void*)soap_instantiate_ns2__ParameterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__jjCouplingType:
		return (void*)soap_instantiate_ns2__jjCouplingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__jKCouplingType:
		return (void*)soap_instantiate_ns2__jKCouplingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LKCouplingType:
		return (void*)soap_instantiate_ns2__LKCouplingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__LSCouplingType_Seniority:
		return (void*)soap_instantiate__ns2__LSCouplingType_Seniority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LSCouplingType:
		return (void*)soap_instantiate_ns2__LSCouplingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OrbitalAngularMomentumType:
		return (void*)soap_instantiate_ns2__OrbitalAngularMomentumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TermType:
		return (void*)soap_instantiate_ns2__TermType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ReactantsType_sequence:
		return (void*)soap_instantiate___ns2__ReactantsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReactantsType:
		return (void*)soap_instantiate_ns2__ReactantsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ProductsType_sequence:
		return (void*)soap_instantiate___ns2__ProductsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ProductsType:
		return (void*)soap_instantiate_ns2__ProductsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AuthorType:
		return (void*)soap_instantiate_ns2__AuthorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SourcesType:
		return (void*)soap_instantiate_ns2__SourcesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SourceType:
		return (void*)soap_instantiate_ns2__SourceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AuthorsType:
		return (void*)soap_instantiate_ns2__AuthorsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EditorsType:
		return (void*)soap_instantiate_ns2__EditorsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MethodsType:
		return (void*)soap_instantiate_ns2__MethodsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MethodType:
		return (void*)soap_instantiate_ns2__MethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FunctionsType:
		return (void*)soap_instantiate_ns2__FunctionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__IsotopeType:
		return (void*)soap_instantiate_ns2__IsotopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomicCoreType:
		return (void*)soap_instantiate_ns2__AtomicCoreType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomicComponentType:
		return (void*)soap_instantiate_ns2__AtomicComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomicQuantumNumbersType:
		return (void*)soap_instantiate_ns2__AtomicQuantumNumbersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConfigurationType:
		return (void*)soap_instantiate_ns2__ConfigurationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ShellsType_sequence:
		return (void*)soap_instantiate___ns2__ShellsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ShellsType:
		return (void*)soap_instantiate_ns2__ShellsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ShellPairType:
		return (void*)soap_instantiate_ns2__ShellPairType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ShellType:
		return (void*)soap_instantiate_ns2__ShellType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SuperConfigurationType:
		return (void*)soap_instantiate_ns2__SuperConfigurationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SuperShellType:
		return (void*)soap_instantiate_ns2__SuperShellType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AsymmetricProjectionType:
		return (void*)soap_instantiate_ns2__AsymmetricProjectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HinderedMotionType:
		return (void*)soap_instantiate_ns2__HinderedMotionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__AtomArrayType_sequence:
		return (void*)soap_instantiate___ns2__AtomArrayType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomArrayType:
		return (void*)soap_instantiate_ns2__AtomArrayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BondType:
		return (void*)soap_instantiate_ns2__BondType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__BondArrayType_sequence:
		return (void*)soap_instantiate___ns2__BondArrayType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BondArrayType:
		return (void*)soap_instantiate_ns2__BondArrayType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__C2SymmetriesType:
		return (void*)soap_instantiate_ns2__C2SymmetriesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType:
		return (void*)soap_instantiate_ns2__DiatomAndLinearPolyatomicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ElectronicCharacterisationType:
		return (void*)soap_instantiate_ns2__ElectronicCharacterisationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ElectronicComponentType:
		return (void*)soap_instantiate_ns2__ElectronicComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ElectronicHomeType:
		return (void*)soap_instantiate_ns2__ElectronicHomeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularChemicalSpeciesType:
		return (void*)soap_instantiate_ns2__MolecularChemicalSpeciesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularProjectionType:
		return (void*)soap_instantiate_ns2__MolecularProjectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__MolecularPropertiesType_sequence:
		return (void*)soap_instantiate___ns2__MolecularPropertiesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularPropertiesType:
		return (void*)soap_instantiate_ns2__MolecularPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularStateCharacterisationType:
		return (void*)soap_instantiate_ns2__MolecularStateCharacterisationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType:
		return (void*)soap_instantiate_ns2__MolecularStateCharacterisation_oldType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MoleculeNuclearSpinsType:
		return (void*)soap_instantiate_ns2__MoleculeNuclearSpinsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearPolyatomicType:
		return (void*)soap_instantiate_ns2__NonLinearPolyatomicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RotationalCharacterisationType:
		return (void*)soap_instantiate_ns2__RotationalCharacterisationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RotationalComponentType:
		return (void*)soap_instantiate_ns2__RotationalComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RotationalHomeType:
		return (void*)soap_instantiate_ns2__RotationalHomeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularQuantumNumberType:
		return (void*)soap_instantiate_ns2__MolecularQuantumNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MagneticQuantumNumberType:
		return (void*)soap_instantiate_ns2__MagneticQuantumNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SimpleSymbolType:
		return (void*)soap_instantiate_ns2__SimpleSymbolType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VibrationalComponentType:
		return (void*)soap_instantiate_ns2__VibrationalComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VibrationalCharacterisationType:
		return (void*)soap_instantiate_ns2__VibrationalCharacterisationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VibrationalHomeType:
		return (void*)soap_instantiate_ns2__VibrationalHomeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VibrationalQuantumNumbersType:
		return (void*)soap_instantiate_ns2__VibrationalQuantumNumbersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LinearNoElecNoHyperFType:
		return (void*)soap_instantiate_ns2__LinearNoElecNoHyperFType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LinearNoElecHyperFType:
		return (void*)soap_instantiate_ns2__LinearNoElecHyperFType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LinearElecCouplingType:
		return (void*)soap_instantiate_ns2__LinearElecCouplingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HundCaseAType:
		return (void*)soap_instantiate_ns2__HundCaseAType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HundCaseBType:
		return (void*)soap_instantiate_ns2__HundCaseBType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HyperfineCaseAAlphaType:
		return (void*)soap_instantiate_ns2__HyperfineCaseAAlphaType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HyperfineCaseABetaType:
		return (void*)soap_instantiate_ns2__HyperfineCaseABetaType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HyperfineCouplingBType:
		return (void*)soap_instantiate_ns2__HyperfineCouplingBType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearElecCouplingType:
		return (void*)soap_instantiate_ns2__NonLinearElecCouplingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearNoElecType:
		return (void*)soap_instantiate_ns2__NonLinearNoElecType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType:
		return (void*)soap_instantiate___ns2__union_HyperfineQuantumNumbersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HyperfineQuantumNumbersType:
		return (void*)soap_instantiate_ns2__HyperfineQuantumNumbersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParticlesType:
		return (void*)soap_instantiate_ns2__ParticlesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParticleType:
		return (void*)soap_instantiate_ns2__ParticleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParticlePropertiesType:
		return (void*)soap_instantiate_ns2__ParticlePropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MaterialComponentType:
		return (void*)soap_instantiate_ns2__MaterialComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MaterialType:
		return (void*)soap_instantiate_ns2__MaterialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CollisionalProcessClassType:
		return (void*)soap_instantiate_ns2__CollisionalProcessClassType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__XSAMSDataType:
		return (void*)soap_instantiate_ns2__XSAMSDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ProcessesType:
		return (void*)soap_instantiate_ns2__ProcessesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StatesType:
		return (void*)soap_instantiate_ns2__StatesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataType:
		return (void*)soap_instantiate_ns2__DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataSetType:
		return (void*)soap_instantiate_ns2__DataSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TabulatedDataType:
		return (void*)soap_instantiate_ns2__TabulatedDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FitDataType:
		return (void*)soap_instantiate_ns2__FitDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ExpressionType:
		return (void*)soap_instantiate_ns2__ExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueType:
		return (void*)soap_instantiate_ns2__ValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MixingCoefficientType:
		return (void*)soap_instantiate_ns2__MixingCoefficientType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FunctionType:
		return (void*)soap_instantiate_ns2__FunctionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomsType:
		return (void*)soap_instantiate_ns2__AtomsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomType:
		return (void*)soap_instantiate_ns2__AtomType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__IsotopeParametersType:
		return (void*)soap_instantiate_ns2__IsotopeParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__IonStateType:
		return (void*)soap_instantiate_ns2__IonStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomicStateType:
		return (void*)soap_instantiate_ns2__AtomicStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomicNumericalDataType:
		return (void*)soap_instantiate_ns2__AtomicNumericalDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomicCompositionType:
		return (void*)soap_instantiate_ns2__AtomicCompositionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AtomNType:
		return (void*)soap_instantiate_ns2__AtomNType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CentralSymbolType:
		return (void*)soap_instantiate_ns2__CentralSymbolType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType:
		return (void*)soap_instantiate_ns2__ComplexMolecularQuantumNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MolecularStateType:
		return (void*)soap_instantiate_ns2__MolecularStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MoleculeType:
		return (void*)soap_instantiate_ns2__MoleculeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MoleculesType:
		return (void*)soap_instantiate_ns2__MoleculesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PseudoStatisticalWeightType:
		return (void*)soap_instantiate_ns2__PseudoStatisticalWeightType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__RoVibronicSplittingType_sequence:
		return (void*)soap_instantiate___ns2__RoVibronicSplittingType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RoVibronicSplittingType:
		return (void*)soap_instantiate_ns2__RoVibronicSplittingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SymbolType:
		return (void*)soap_instantiate_ns2__SymbolType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearElecHyperFType:
		return (void*)soap_instantiate_ns2__NonLinearElecHyperFType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearElecNoHyperFType:
		return (void*)soap_instantiate_ns2__NonLinearElecNoHyperFType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType:
		return (void*)soap_instantiate_ns2__NonLinearNoElecNoHyperFType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonLinearNoElecHyperFType:
		return (void*)soap_instantiate_ns2__NonLinearNoElecHyperFType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReferencedTextType:
		return (void*)soap_instantiate_ns2__ReferencedTextType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CharacterisationType:
		return (void*)soap_instantiate_ns2__CharacterisationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SolidType:
		return (void*)soap_instantiate_ns2__SolidType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SolidsType:
		return (void*)soap_instantiate_ns2__SolidsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MaterialCompositionType:
		return (void*)soap_instantiate_ns2__MaterialCompositionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RadiativeType:
		return (void*)soap_instantiate_ns2__RadiativeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RadiativeTransitionType:
		return (void*)soap_instantiate_ns2__RadiativeTransitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RadiativeTransitionProbabilityType:
		return (void*)soap_instantiate_ns2__RadiativeTransitionProbabilityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__WavelengthWavenumberType:
		return (void*)soap_instantiate_ns2__WavelengthWavenumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EnergyWavelengthType:
		return (void*)soap_instantiate_ns2__EnergyWavelengthType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonRadiativeType:
		return (void*)soap_instantiate_ns2__NonRadiativeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NonRadiativeTransitionType:
		return (void*)soap_instantiate_ns2__NonRadiativeTransitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CollisionsType:
		return (void*)soap_instantiate_ns2__CollisionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CollisionalTransitionType:
		return (void*)soap_instantiate_ns2__CollisionalTransitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StateEnergyType:
		return (void*)soap_instantiate_ns2__StateEnergyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TotalSpinMomentumSType:
		return (void*)soap_instantiate_ns2__TotalSpinMomentumSType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getSResponse:
		return (void*)soap_instantiate_ns2__getSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getS:
		return (void*)soap_instantiate_ns2__getS(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__DataTableType:
		return (void*)soap_instantiate_xsd__DataTableType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__IDREF:
		return (void*)soap_instantiate_xsd__IDREF(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__IDREFS:
		return (void*)soap_instantiate_xsd__IDREFS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__gYear:
		return (void*)soap_instantiate_xsd__gYear(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger:
		return (void*)soap_instantiate_xsd__positiveInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataListType:
		return (void*)soap_instantiate_ns2__DataListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AngularMomentumProjectionType:
		return (void*)soap_instantiate_ns2__AngularMomentumProjectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AngularMomentumType:
		return (void*)soap_instantiate_ns2__AngularMomentumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ElementSymbolType:
		return (void*)soap_instantiate_ns2__ElementSymbolType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PrincipalQuantumNumberType:
		return (void*)soap_instantiate_ns2__PrincipalQuantumNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType:
		return (void*)soap_instantiate_ns2__OrbitalAngularMomentumSymbolType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StateRef:
		return (void*)soap_instantiate_ns2__StateRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MultipoleType:
		return (void*)soap_instantiate_ns2__MultipoleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__sourceRef:
		return (void*)soap_instantiate__ns2__sourceRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__methodRef:
		return (void*)soap_instantiate__ns2__methodRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__functionRef:
		return (void*)soap_instantiate__ns2__functionRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__stateID:
		return (void*)soap_instantiate__ns2__stateID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__sourceID:
		return (void*)soap_instantiate__ns2__sourceID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__methodID:
		return (void*)soap_instantiate__ns2__methodID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__functionID:
		return (void*)soap_instantiate__ns2__functionID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CollisionalTransitionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialComponentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MaterialComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SolidType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__SolidType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MaterialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SimpleSymbolType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__SimpleSymbolType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MoleculeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MoleculeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MolecularStateType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MolecularStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicComponentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__AtomicComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicStateType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__AtomicStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__IsotopeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__IsotopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__AtomType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitValidityLimitsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TabulatedDataType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__TabulatedDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitDataType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__FitDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__CodeType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__CodeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParticleType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ParticleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VibrationalComponentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__VibrationalComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RotationalComponentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__RotationalComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CharacterisationType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ElectronicComponentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ElectronicComponentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__BondArrayType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__BondArrayType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__AtomArrayType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__AtomArrayType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SuperShellType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__SuperShellType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ShellsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__ShellsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellPairType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ShellPairType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ShellType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__IonStateType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__IonStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FunctionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__FunctionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MethodType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AuthorType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__AuthorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__SourceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ProductsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__ProductsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ReactantsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__ns2__ReactantsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__AngularMomentumType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__AngularMomentumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParameterType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ParameterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ArgumentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ArgumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		return (void*)soap_instantiate_std__vectorTemplateOfdouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataTableType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__DataTableType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataSetType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__DataSetType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PrimaryType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PrimaryType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PrimaryType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ChemicalElementType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ChemicalElementType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ChemicalElementType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataSetsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataSetsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataSetsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataTableType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataTableType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataTableType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataXYType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataXYType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataXYType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FitParametersType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FitParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FitParametersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FitValidityLimitsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FitValidityLimitsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FitValidityLimitsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ArgumentsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ArgumentsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ArgumentsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ArgumentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ArgumentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ArgumentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParametersType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParametersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParameterType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParameterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParameterType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__jjCouplingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__jjCouplingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__jjCouplingType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__jKCouplingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__jKCouplingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__jKCouplingType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LKCouplingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LKCouplingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LKCouplingType*)p->ptr);
		break;
	case SOAP_TYPE__ns2__LSCouplingType_Seniority:
		if (p->size < 0)
			SOAP_DELETE((_ns2__LSCouplingType_Seniority*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__LSCouplingType_Seniority*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LSCouplingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LSCouplingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LSCouplingType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OrbitalAngularMomentumType:
		if (p->size < 0)
			SOAP_DELETE((ns2__OrbitalAngularMomentumType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OrbitalAngularMomentumType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__TermType:
		if (p->size < 0)
			SOAP_DELETE((ns2__TermType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__TermType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ReactantsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__ReactantsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__ReactantsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ReactantsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ReactantsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ReactantsType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ProductsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__ProductsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__ProductsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ProductsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ProductsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ProductsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AuthorType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AuthorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AuthorType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SourcesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SourcesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SourcesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SourceType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SourceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SourceType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AuthorsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AuthorsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AuthorsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__EditorsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__EditorsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EditorsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MethodsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MethodsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MethodsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MethodType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MethodType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FunctionsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FunctionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FunctionsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__IsotopeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__IsotopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__IsotopeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomicCoreType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomicCoreType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomicCoreType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomicComponentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomicComponentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomicComponentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomicQuantumNumbersType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomicQuantumNumbersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomicQuantumNumbersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConfigurationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ConfigurationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ConfigurationType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ShellsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__ShellsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__ShellsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ShellsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ShellsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ShellsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ShellPairType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ShellPairType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ShellPairType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ShellType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ShellType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ShellType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SuperConfigurationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SuperConfigurationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SuperConfigurationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SuperShellType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SuperShellType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SuperShellType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AsymmetricProjectionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AsymmetricProjectionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AsymmetricProjectionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HinderedMotionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HinderedMotionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HinderedMotionType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__AtomArrayType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__AtomArrayType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__AtomArrayType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomArrayType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomArrayType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomArrayType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__BondType:
		if (p->size < 0)
			SOAP_DELETE((ns2__BondType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__BondType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__BondArrayType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__BondArrayType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__BondArrayType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__BondArrayType:
		if (p->size < 0)
			SOAP_DELETE((ns2__BondArrayType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__BondArrayType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__C2SymmetriesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__C2SymmetriesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__C2SymmetriesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DiatomAndLinearPolyatomicType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DiatomAndLinearPolyatomicType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ElectronicCharacterisationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ElectronicCharacterisationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ElectronicCharacterisationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ElectronicComponentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ElectronicComponentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ElectronicComponentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ElectronicHomeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ElectronicHomeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ElectronicHomeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularChemicalSpeciesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularChemicalSpeciesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularChemicalSpeciesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularProjectionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularProjectionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularProjectionType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__MolecularPropertiesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__MolecularPropertiesType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__MolecularPropertiesType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularStateCharacterisationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularStateCharacterisationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularStateCharacterisationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularStateCharacterisation_oldType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularStateCharacterisation_oldType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MoleculeNuclearSpinsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MoleculeNuclearSpinsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MoleculeNuclearSpinsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearPolyatomicType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearPolyatomicType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearPolyatomicType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RotationalCharacterisationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RotationalCharacterisationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RotationalCharacterisationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RotationalComponentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RotationalComponentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RotationalComponentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RotationalHomeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RotationalHomeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RotationalHomeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularQuantumNumberType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularQuantumNumberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularQuantumNumberType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MagneticQuantumNumberType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MagneticQuantumNumberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MagneticQuantumNumberType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SimpleSymbolType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SimpleSymbolType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SimpleSymbolType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__VibrationalComponentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__VibrationalComponentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__VibrationalComponentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__VibrationalCharacterisationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__VibrationalCharacterisationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__VibrationalCharacterisationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__VibrationalHomeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__VibrationalHomeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__VibrationalHomeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__VibrationalQuantumNumbersType:
		if (p->size < 0)
			SOAP_DELETE((ns2__VibrationalQuantumNumbersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__VibrationalQuantumNumbersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LinearNoElecNoHyperFType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LinearNoElecNoHyperFType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LinearNoElecNoHyperFType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LinearNoElecHyperFType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LinearNoElecHyperFType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LinearNoElecHyperFType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LinearElecCouplingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LinearElecCouplingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LinearElecCouplingType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HundCaseAType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HundCaseAType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HundCaseAType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HundCaseBType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HundCaseBType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HundCaseBType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HyperfineCaseAAlphaType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HyperfineCaseAAlphaType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HyperfineCaseAAlphaType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HyperfineCaseABetaType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HyperfineCaseABetaType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HyperfineCaseABetaType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HyperfineCouplingBType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HyperfineCouplingBType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HyperfineCouplingBType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearElecCouplingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearElecCouplingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearElecCouplingType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearNoElecType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearNoElecType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearNoElecType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType:
		if (p->size < 0)
			SOAP_DELETE((__ns2__union_HyperfineQuantumNumbersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__union_HyperfineQuantumNumbersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HyperfineQuantumNumbersType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HyperfineQuantumNumbersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HyperfineQuantumNumbersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParticlesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParticlesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParticlesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParticleType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParticleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParticleType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParticlePropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParticlePropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParticlePropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MaterialComponentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MaterialComponentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MaterialComponentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MaterialType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MaterialType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MaterialType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CollisionalProcessClassType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CollisionalProcessClassType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CollisionalProcessClassType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__XSAMSDataType:
		if (p->size < 0)
			SOAP_DELETE((ns2__XSAMSDataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__XSAMSDataType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ProcessesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ProcessesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ProcessesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__StatesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__StatesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__StatesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataSetType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataSetType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataSetType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__TabulatedDataType:
		if (p->size < 0)
			SOAP_DELETE((ns2__TabulatedDataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__TabulatedDataType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FitDataType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FitDataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FitDataType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ExpressionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ExpressionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ExpressionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MixingCoefficientType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MixingCoefficientType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MixingCoefficientType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FunctionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FunctionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FunctionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__IsotopeParametersType:
		if (p->size < 0)
			SOAP_DELETE((ns2__IsotopeParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__IsotopeParametersType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__IonStateType:
		if (p->size < 0)
			SOAP_DELETE((ns2__IonStateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__IonStateType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomicStateType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomicStateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomicStateType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomicNumericalDataType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomicNumericalDataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomicNumericalDataType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomicCompositionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomicCompositionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomicCompositionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AtomNType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AtomNType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AtomNType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CentralSymbolType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CentralSymbolType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CentralSymbolType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ComplexMolecularQuantumNumberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ComplexMolecularQuantumNumberType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MolecularStateType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MolecularStateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MolecularStateType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MoleculeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MoleculeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MoleculeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MoleculesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MoleculesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MoleculesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PseudoStatisticalWeightType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PseudoStatisticalWeightType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PseudoStatisticalWeightType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__RoVibronicSplittingType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__ns2__RoVibronicSplittingType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__RoVibronicSplittingType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RoVibronicSplittingType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RoVibronicSplittingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RoVibronicSplittingType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SymbolType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SymbolType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SymbolType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearElecHyperFType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearElecHyperFType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearElecHyperFType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearElecNoHyperFType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearElecNoHyperFType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearElecNoHyperFType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearNoElecNoHyperFType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearNoElecNoHyperFType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonLinearNoElecHyperFType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonLinearNoElecHyperFType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonLinearNoElecHyperFType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ReferencedTextType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ReferencedTextType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ReferencedTextType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CharacterisationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CharacterisationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CharacterisationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SolidType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SolidType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SolidType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SolidsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SolidsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SolidsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MaterialCompositionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MaterialCompositionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MaterialCompositionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RadiativeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RadiativeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RadiativeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RadiativeTransitionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RadiativeTransitionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RadiativeTransitionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RadiativeTransitionProbabilityType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RadiativeTransitionProbabilityType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RadiativeTransitionProbabilityType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__WavelengthWavenumberType:
		if (p->size < 0)
			SOAP_DELETE((ns2__WavelengthWavenumberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__WavelengthWavenumberType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__EnergyWavelengthType:
		if (p->size < 0)
			SOAP_DELETE((ns2__EnergyWavelengthType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EnergyWavelengthType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonRadiativeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonRadiativeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonRadiativeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NonRadiativeTransitionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NonRadiativeTransitionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NonRadiativeTransitionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CollisionsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CollisionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CollisionsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CollisionalTransitionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CollisionalTransitionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CollisionalTransitionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__StateEnergyType:
		if (p->size < 0)
			SOAP_DELETE((ns2__StateEnergyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__StateEnergyType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__TotalSpinMomentumSType:
		if (p->size < 0)
			SOAP_DELETE((ns2__TotalSpinMomentumSType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__TotalSpinMomentumSType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getSResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__getSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__getSResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__getS:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__getS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__getS*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__DataTableType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__IDREF:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__IDREFS:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__gYear:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataListType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AngularMomentumProjectionType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AngularMomentumType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ElementSymbolType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PrincipalQuantumNumberType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__StateRef:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MultipoleType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__sourceRef:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__methodRef:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__functionRef:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__stateID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__sourceID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__methodID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__functionID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CollisionalTransitionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__CollisionalTransitionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__CollisionalTransitionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__NonRadiativeTransitionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__NonRadiativeTransitionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__RadiativeTransitionProbabilityType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__RadiativeTransitionProbabilityType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__RadiativeTransitionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__RadiativeTransitionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialComponentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MaterialComponentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MaterialComponentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SolidType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__SolidType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__SolidType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MaterialType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MaterialType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SimpleSymbolType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__SimpleSymbolType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__SimpleSymbolType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__RoVibronicSplittingType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__RoVibronicSplittingType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MoleculeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MoleculeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MoleculeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MolecularStateType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MolecularStateType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MolecularStateType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicComponentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__AtomicComponentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__AtomicComponentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicStateType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__AtomicStateType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__AtomicStateType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__IsotopeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__IsotopeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__IsotopeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__AtomType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__AtomType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitValidityLimitsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__FitValidityLimitsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__FitValidityLimitsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TabulatedDataType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__TabulatedDataType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__TabulatedDataType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitDataType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__FitDataType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__FitDataType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__CodeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns2__CodeType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns2__CodeType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParticleType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ParticleType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ParticleType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ComplexMolecularQuantumNumberType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ComplexMolecularQuantumNumberType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VibrationalComponentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__VibrationalComponentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__VibrationalComponentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RotationalComponentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__RotationalComponentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__RotationalComponentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CharacterisationType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__CharacterisationType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__CharacterisationType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__MolecularPropertiesType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__MolecularPropertiesType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ElectronicComponentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ElectronicComponentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ElectronicComponentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__BondArrayType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__BondArrayType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__BondArrayType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__AtomArrayType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__AtomArrayType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__AtomArrayType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SuperShellType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__SuperShellType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__SuperShellType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ShellsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__ShellsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__ShellsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellPairType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ShellPairType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ShellPairType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ShellType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ShellType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__IonStateType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__IonStateType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__IonStateType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FunctionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__FunctionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__FunctionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MethodType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MethodType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MethodType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AuthorType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__AuthorType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__AuthorType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__SourceType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__SourceType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ProductsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__ProductsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__ProductsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ReactantsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__ns2__ReactantsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__ns2__ReactantsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__AngularMomentumType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParameterType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ParameterType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ParameterType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ArgumentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ArgumentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ArgumentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		if (p->size < 0)
			SOAP_DELETE((std::vector<double >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<double >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataTableType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__DataTableType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__DataTableType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataSetType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__DataSetType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__DataSetType * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CollisionalTransitionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__CollisionalTransitionType * >*)p)[len] = *(ns2__CollisionalTransitionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__NonRadiativeTransitionType * >*)p)[len] = *(ns2__NonRadiativeTransitionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__RadiativeTransitionProbabilityType * >*)p)[len] = *(ns2__RadiativeTransitionProbabilityType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__RadiativeTransitionType * >*)p)[len] = *(ns2__RadiativeTransitionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialComponentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MaterialComponentType * >*)p)[len] = *(ns2__MaterialComponentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SolidType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__SolidType * >*)p)[len] = *(ns2__SolidType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MaterialType * >*)p)[len] = *(ns2__MaterialType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SimpleSymbolType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__SimpleSymbolType * >*)p)[len] = *(ns2__SimpleSymbolType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__RoVibronicSplittingType_sequence >*)p)[len] = *(__ns2__RoVibronicSplittingType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MoleculeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MoleculeType * >*)p)[len] = *(ns2__MoleculeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MolecularStateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MolecularStateType * >*)p)[len] = *(ns2__MolecularStateType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicComponentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__AtomicComponentType * >*)p)[len] = *(ns2__AtomicComponentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicStateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__AtomicStateType * >*)p)[len] = *(ns2__AtomicStateType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__IsotopeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__IsotopeType * >*)p)[len] = *(ns2__IsotopeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__AtomType * >*)p)[len] = *(ns2__AtomType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitValidityLimitsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__FitValidityLimitsType * >*)p)[len] = *(ns2__FitValidityLimitsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TabulatedDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__TabulatedDataType * >*)p)[len] = *(ns2__TabulatedDataType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__FitDataType * >*)p)[len] = *(ns2__FitDataType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__CodeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns2__CodeType >*)p)[len] = *(enum ns2__CodeType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParticleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ParticleType * >*)p)[len] = *(ns2__ParticleType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ComplexMolecularQuantumNumberType * >*)p)[len] = *(ns2__ComplexMolecularQuantumNumberType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VibrationalComponentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__VibrationalComponentType * >*)p)[len] = *(ns2__VibrationalComponentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RotationalComponentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__RotationalComponentType * >*)p)[len] = *(ns2__RotationalComponentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CharacterisationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__CharacterisationType * >*)p)[len] = *(ns2__CharacterisationType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__MolecularPropertiesType_sequence >*)p)[len] = *(__ns2__MolecularPropertiesType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ElectronicComponentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ElectronicComponentType * >*)p)[len] = *(ns2__ElectronicComponentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__BondArrayType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__BondArrayType_sequence >*)p)[len] = *(__ns2__BondArrayType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__AtomArrayType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__AtomArrayType_sequence >*)p)[len] = *(__ns2__AtomArrayType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SuperShellType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__SuperShellType * >*)p)[len] = *(ns2__SuperShellType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ShellsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__ShellsType_sequence >*)p)[len] = *(__ns2__ShellsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellPairType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ShellPairType * >*)p)[len] = *(ns2__ShellPairType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ShellType * >*)p)[len] = *(ns2__ShellType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__IonStateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__IonStateType * >*)p)[len] = *(ns2__IonStateType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FunctionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__FunctionType * >*)p)[len] = *(ns2__FunctionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MethodType * >*)p)[len] = *(ns2__MethodType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AuthorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__AuthorType * >*)p)[len] = *(ns2__AuthorType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__SourceType * >*)p)[len] = *(ns2__SourceType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ProductsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__ProductsType_sequence >*)p)[len] = *(__ns2__ProductsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__ns2__ReactantsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__ns2__ReactantsType_sequence >*)p)[len] = *(__ns2__ReactantsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__AngularMomentumType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParameterType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ParameterType * >*)p)[len] = *(ns2__ParameterType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ArgumentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ArgumentType * >*)p)[len] = *(ns2__ArgumentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<double >*)p)[len] = *(double *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataTableType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__DataTableType * >*)p)[len] = *(ns2__DataTableType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataSetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__DataSetType * >*)p)[len] = *(ns2__DataSetType **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__units(struct soap *soap, enum _ns2__units *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__units
	*a = SOAP_DEFAULT__ns2__units;
#else
	*a = (enum _ns2__units)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__units[] =
{	{ (long)_ns2__units__undef, "undef" },
	{ (long)_ns2__units__eV_x002famu, "eV/amu" },
	{ (long)_ns2__units__keV_x002famu, "keV/amu" },
	{ (long)_ns2__units__MeV_x002famu, "MeV/amu" },
	{ (long)_ns2__units__eV, "eV" },
	{ (long)_ns2__units__keV, "keV" },
	{ (long)_ns2__units__MeV, "MeV" },
	{ (long)_ns2__units__au, "au" },
	{ (long)_ns2__units__1_x002fcm, "1/cm" },
	{ (long)_ns2__units__J, "J" },
	{ (long)_ns2__units__Ry, "Ry" },
	{ (long)_ns2__units__unitless, "unitless" },
	{ (long)_ns2__units__kJ_x002fmol, "kJ/mol" },
	{ (long)_ns2__units__kcal_x002fmol, "kcal/mol" },
	{ (long)_ns2__units__K, "K" },
	{ (long)_ns2__units__Hz, "Hz" },
	{ (long)_ns2__units__kHz, "kHz" },
	{ (long)_ns2__units__MHz, "MHz" },
	{ (long)_ns2__units__m, "m" },
	{ (long)_ns2__units__cm, "cm" },
	{ (long)_ns2__units__A, "A" },
	{ (long)_ns2__units__nm, "nm" },
	{ (long)_ns2__units__deg, "deg" },
	{ (long)_ns2__units__rad, "rad" },
	{ (long)_ns2__units__srad, "srad" },
	{ (long)_ns2__units__s, "s" },
	{ (long)_ns2__units__m3_x002fs, "m3/s" },
	{ (long)_ns2__units__cm3_x002fs, "cm3/s" },
	{ (long)_ns2__units__cm6_x002fs, "cm6/s" },
	{ (long)_ns2__units__m2, "m2" },
	{ (long)_ns2__units__cm2, "cm2" },
	{ (long)_ns2__units__b, "b" },
	{ (long)_ns2__units__Mb, "Mb" },
	{ (long)_ns2__units__1_x002fs, "1/s" },
	{ (long)_ns2__units__C_x002em, "C.m" },
	{ (long)_ns2__units__J_x002fT, "J/T" },
	{ (long)_ns2__units__C_x002em2, "C.m2" },
	{ (long)_ns2__units__m_x002fs, "m/s" },
	{ (long)_ns2__units__cm_x002fs, "cm/s" },
	{ (long)_ns2__units__C, "C" },
	{ (long)_ns2__units__electron, "electron" },
	{ (long)_ns2__units__g, "g" },
	{ (long)_ns2__units__amu, "amu" },
	{ (long)_ns2__units__kg, "kg" },
	{ (long)_ns2__units__1_x002fm2_x002fs, "1/m2/s" },
	{ (long)_ns2__units__1_x002fcm2_x002fs, "1/cm2/s" },
	{ (long)_ns2__units__J_x002fm2_x002fs, "J/m2/s" },
	{ (long)_ns2__units__J_x002fcm2_x002fs, "J/cm2/s" },
	{ (long)_ns2__units__1_x002fm2, "1/m2" },
	{ (long)_ns2__units__1_x002fcm2, "1/cm2" },
	{ (long)_ns2__units__J_x002fm2, "J/m2" },
	{ (long)_ns2__units__J_x002fcm2, "J/cm2" },
	{ (long)_ns2__units__W_x002fm2, "W/m2" },
	{ (long)_ns2__units__W_x002fcm2, "W/cm2" },
	{ (long)_ns2__units__W, "W" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__units2s(struct soap *soap, enum _ns2__units n)
{	const char *s = soap_code_str(soap_codes__ns2__units, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__units(struct soap *soap, const char *tag, int id, const enum _ns2__units *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__units), type) || soap_send(soap, soap__ns2__units2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__units(struct soap *soap, const char *s, enum _ns2__units *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__units, s);
	if (map)
		*a = (enum _ns2__units)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 54)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__units)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__units * SOAP_FMAC4 soap_in__ns2__units(struct soap *soap, const char *tag, enum _ns2__units *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__units *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__units, sizeof(enum _ns2__units), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__units(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__units *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__units, 0, sizeof(enum _ns2__units), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__units(struct soap *soap, const enum _ns2__units *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__units);
	if (soap_out__ns2__units(soap, tag?tag:"ns2:units", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__units * SOAP_FMAC4 soap_get__ns2__units(struct soap *soap, enum _ns2__units *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__units(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CodeType(struct soap *soap, enum ns2__CodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CodeType
	*a = SOAP_DEFAULT_ns2__CodeType;
#else
	*a = (enum ns2__CodeType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CodeType[] =
{	{ (long)ns2__CodeType__phem, "phem" },
	{ (long)ns2__CodeType__phab, "phab" },
	{ (long)ns2__CodeType__phsc, "phsc" },
	{ (long)ns2__CodeType__elas, "elas" },
	{ (long)ns2__CodeType__inel, "inel" },
	{ (long)ns2__CodeType__exci, "exci" },
	{ (long)ns2__CodeType__dexc, "dexc" },
	{ (long)ns2__CodeType__ioni, "ioni" },
	{ (long)ns2__CodeType__tran, "tran" },
	{ (long)ns2__CodeType__exch, "exch" },
	{ (long)ns2__CodeType__reco, "reco" },
	{ (long)ns2__CodeType__elat, "elat" },
	{ (long)ns2__CodeType__eldt, "eldt" },
	{ (long)ns2__CodeType__asso, "asso" },
	{ (long)ns2__CodeType__diss, "diss" },
	{ (long)ns2__CodeType__intr, "intr" },
	{ (long)ns2__CodeType__chem, "chem" },
	{ (long)ns2__CodeType__sure, "sure" },
	{ (long)ns2__CodeType__suem, "suem" },
	{ (long)ns2__CodeType__sudp, "sudp" },
	{ (long)ns2__CodeType__such, "such" },
	{ (long)ns2__CodeType__sope, "sope" },
	{ (long)ns2__CodeType___x0000, "" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CodeType2s(struct soap *soap, enum ns2__CodeType n)
{	const char *s = soap_code_str(soap_codes_ns2__CodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CodeType(struct soap *soap, const char *tag, int id, const enum ns2__CodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CodeType), type) || soap_send(soap, soap_ns2__CodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CodeType(struct soap *soap, const char *s, enum ns2__CodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CodeType, s);
	if (map)
		*a = (enum ns2__CodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 22)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CodeType * SOAP_FMAC4 soap_in_ns2__CodeType(struct soap *soap, const char *tag, enum ns2__CodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CodeType, sizeof(enum ns2__CodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CodeType, 0, sizeof(enum ns2__CodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CodeType(struct soap *soap, const enum ns2__CodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CodeType);
	if (soap_out_ns2__CodeType(soap, tag?tag:"ns2:CodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CodeType * SOAP_FMAC4 soap_get_ns2__CodeType(struct soap *soap, enum ns2__CodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IAEACodeType(struct soap *soap, enum ns2__IAEACodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IAEACodeType
	*a = SOAP_DEFAULT_ns2__IAEACodeType;
#else
	*a = (enum ns2__IAEACodeType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IAEACodeType[] =
{	{ (long)ns2__IAEACodeType__EGN, "EGN" },
	{ (long)ns2__IAEACodeType__EAS, "EAS" },
	{ (long)ns2__IAEACodeType__EBS, "EBS" },
	{ (long)ns2__IAEACodeType__EDX, "EDX" },
	{ (long)ns2__IAEACodeType__EEL, "EEL" },
	{ (long)ns2__IAEACodeType__ELB, "ELB" },
	{ (long)ns2__IAEACodeType__ETS, "ETS" },
	{ (long)ns2__IAEACodeType__EDT, "EDT" },
	{ (long)ns2__IAEACodeType__EFL, "EFL" },
	{ (long)ns2__IAEACodeType__EEX, "EEX" },
	{ (long)ns2__IAEACodeType__EIN, "EIN" },
	{ (long)ns2__IAEACodeType__EMI, "EMI" },
	{ (long)ns2__IAEACodeType__ENI, "ENI" },
	{ (long)ns2__IAEACodeType__EMT, "EMT" },
	{ (long)ns2__IAEACodeType__EUP, "EUP" },
	{ (long)ns2__IAEACodeType__EDP, "EDP" },
	{ (long)ns2__IAEACodeType__EIP, "EIP" },
	{ (long)ns2__IAEACodeType__ERC, "ERC" },
	{ (long)ns2__IAEACodeType__ERR, "ERR" },
	{ (long)ns2__IAEACodeType__ERD, "ERD" },
	{ (long)ns2__IAEACodeType__ERT, "ERT" },
	{ (long)ns2__IAEACodeType__ERO, "ERO" },
	{ (long)ns2__IAEACodeType__EDC, "EDC" },
	{ (long)ns2__IAEACodeType__EDS, "EDS" },
	{ (long)ns2__IAEACodeType__EDR, "EDR" },
	{ (long)ns2__IAEACodeType__EDA, "EDA" },
	{ (long)ns2__IAEACodeType__EDE, "EDE" },
	{ (long)ns2__IAEACodeType__EDI, "EDI" },
	{ (long)ns2__IAEACodeType__PGN, "PGN" },
	{ (long)ns2__IAEACodeType__PTS, "PTS" },
	{ (long)ns2__IAEACodeType__PDS, "PDS" },
	{ (long)ns2__IAEACodeType__PES, "PES" },
	{ (long)ns2__IAEACodeType__PMA, "PMA" },
	{ (long)ns2__IAEACodeType__PDT, "PDT" },
	{ (long)ns2__IAEACodeType__PFL, "PFL" },
	{ (long)ns2__IAEACodeType__PEX, "PEX" },
	{ (long)ns2__IAEACodeType__PIN, "PIN" },
	{ (long)ns2__IAEACodeType__PFF, "PFF" },
	{ (long)ns2__IAEACodeType__PEA, "PEA" },
	{ (long)ns2__IAEACodeType__PTA, "PTA" },
	{ (long)ns2__IAEACodeType__PAD, "PAD" },
	{ (long)ns2__IAEACodeType__PED, "PED" },
	{ (long)ns2__IAEACodeType__PNL, "PNL" },
	{ (long)ns2__IAEACodeType__PZE, "PZE" },
	{ (long)ns2__IAEACodeType__PSE, "PSE" },
	{ (long)ns2__IAEACodeType__PGF, "PGF" },
	{ (long)ns2__IAEACodeType__PTF, "PTF" },
	{ (long)ns2__IAEACodeType__HGN, "HGN" },
	{ (long)ns2__IAEACodeType__HAS, "HAS" },
	{ (long)ns2__IAEACodeType__HLB, "HLB" },
	{ (long)ns2__IAEACodeType__HDS, "HDS" },
	{ (long)ns2__IAEACodeType__HDX, "HDX" },
	{ (long)ns2__IAEACodeType__HES, "HES" },
	{ (long)ns2__IAEACodeType__HCX, "HCX" },
	{ (long)ns2__IAEACodeType__HUP, "HUP" },
	{ (long)ns2__IAEACodeType__HIR, "HIR" },
	{ (long)ns2__IAEACodeType__HEL, "HEL" },
	{ (long)ns2__IAEACodeType__HET, "HET" },
	{ (long)ns2__IAEACodeType__HIP, "HIP" },
	{ (long)ns2__IAEACodeType__HRC, "HRC" },
	{ (long)ns2__IAEACodeType__HTS, "HTS" },
	{ (long)ns2__IAEACodeType__HDT, "HDT" },
	{ (long)ns2__IAEACodeType__HFL, "HFL" },
	{ (long)ns2__IAEACodeType__HEX, "HEX" },
	{ (long)ns2__IAEACodeType__HIN, "HIN" },
	{ (long)ns2__IAEACodeType__HPN, "HPN" },
	{ (long)ns2__IAEACodeType__HST, "HST" },
	{ (long)ns2__IAEACodeType__HAT, "HAT" },
	{ (long)ns2__IAEACodeType__HAI, "HAI" },
	{ (long)ns2__IAEACodeType__HDI, "HDI" },
	{ (long)ns2__IAEACodeType__HDC, "HDC" },
	{ (long)ns2__IAEACodeType__HMN, "HMN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IAEACodeType2s(struct soap *soap, enum ns2__IAEACodeType n)
{	const char *s = soap_code_str(soap_codes_ns2__IAEACodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IAEACodeType(struct soap *soap, const char *tag, int id, const enum ns2__IAEACodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IAEACodeType), type) || soap_send(soap, soap_ns2__IAEACodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IAEACodeType(struct soap *soap, const char *s, enum ns2__IAEACodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IAEACodeType, s);
	if (map)
		*a = (enum ns2__IAEACodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 71)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IAEACodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IAEACodeType * SOAP_FMAC4 soap_in_ns2__IAEACodeType(struct soap *soap, const char *tag, enum ns2__IAEACodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IAEACodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IAEACodeType, sizeof(enum ns2__IAEACodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IAEACodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IAEACodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IAEACodeType, 0, sizeof(enum ns2__IAEACodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IAEACodeType(struct soap *soap, const enum ns2__IAEACodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IAEACodeType);
	if (soap_out_ns2__IAEACodeType(soap, tag?tag:"ns2:IAEACodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IAEACodeType * SOAP_FMAC4 soap_get_ns2__IAEACodeType(struct soap *soap, enum ns2__IAEACodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IAEACodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ParticleNameType(struct soap *soap, enum ns2__ParticleNameType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ParticleNameType
	*a = SOAP_DEFAULT_ns2__ParticleNameType;
#else
	*a = (enum ns2__ParticleNameType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ParticleNameType[] =
{	{ (long)ns2__ParticleNameType__photon, "photon" },
	{ (long)ns2__ParticleNameType__electron, "electron" },
	{ (long)ns2__ParticleNameType__muon, "muon" },
	{ (long)ns2__ParticleNameType__positron, "positron" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ParticleNameType2s(struct soap *soap, enum ns2__ParticleNameType n)
{	const char *s = soap_code_str(soap_codes_ns2__ParticleNameType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParticleNameType(struct soap *soap, const char *tag, int id, const enum ns2__ParticleNameType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParticleNameType), type) || soap_send(soap, soap_ns2__ParticleNameType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ParticleNameType(struct soap *soap, const char *s, enum ns2__ParticleNameType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ParticleNameType, s);
	if (map)
		*a = (enum ns2__ParticleNameType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ParticleNameType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ParticleNameType * SOAP_FMAC4 soap_in_ns2__ParticleNameType(struct soap *soap, const char *tag, enum ns2__ParticleNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ParticleNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParticleNameType, sizeof(enum ns2__ParticleNameType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ParticleNameType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ParticleNameType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParticleNameType, 0, sizeof(enum ns2__ParticleNameType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ParticleNameType(struct soap *soap, const enum ns2__ParticleNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ParticleNameType);
	if (soap_out_ns2__ParticleNameType(soap, tag?tag:"ns2:ParticleNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ParticleNameType * SOAP_FMAC4 soap_get_ns2__ParticleNameType(struct soap *soap, enum ns2__ParticleNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParticleNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PermutationSymmetryType(struct soap *soap, enum ns2__PermutationSymmetryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PermutationSymmetryType
	*a = SOAP_DEFAULT_ns2__PermutationSymmetryType;
#else
	*a = (enum ns2__PermutationSymmetryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PermutationSymmetryType[] =
{	{ (long)ns2__PermutationSymmetryType__a, "a" },
	{ (long)ns2__PermutationSymmetryType__s, "s" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PermutationSymmetryType2s(struct soap *soap, enum ns2__PermutationSymmetryType n)
{	const char *s = soap_code_str(soap_codes_ns2__PermutationSymmetryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PermutationSymmetryType(struct soap *soap, const char *tag, int id, const enum ns2__PermutationSymmetryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PermutationSymmetryType), type) || soap_send(soap, soap_ns2__PermutationSymmetryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PermutationSymmetryType(struct soap *soap, const char *s, enum ns2__PermutationSymmetryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PermutationSymmetryType, s);
	if (map)
		*a = (enum ns2__PermutationSymmetryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PermutationSymmetryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PermutationSymmetryType * SOAP_FMAC4 soap_in_ns2__PermutationSymmetryType(struct soap *soap, const char *tag, enum ns2__PermutationSymmetryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PermutationSymmetryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PermutationSymmetryType, sizeof(enum ns2__PermutationSymmetryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PermutationSymmetryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PermutationSymmetryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PermutationSymmetryType, 0, sizeof(enum ns2__PermutationSymmetryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PermutationSymmetryType(struct soap *soap, const enum ns2__PermutationSymmetryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PermutationSymmetryType);
	if (soap_out_ns2__PermutationSymmetryType(soap, tag?tag:"ns2:PermutationSymmetryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PermutationSymmetryType * SOAP_FMAC4 soap_get_ns2__PermutationSymmetryType(struct soap *soap, enum ns2__PermutationSymmetryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PermutationSymmetryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ModesListType(struct soap *soap, enum ns2__ModesListType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ModesListType
	*a = SOAP_DEFAULT_ns2__ModesListType;
#else
	*a = (enum ns2__ModesListType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ModesListType[] =
{	{ (long)ns2__ModesListType__normalMode, "normalMode" },
	{ (long)ns2__ModesListType__stretchingMode, "stretchingMode" },
	{ (long)ns2__ModesListType__bendingMode, "bendingMode" },
	{ (long)ns2__ModesListType__torsionalMode, "torsionalMode" },
	{ (long)ns2__ModesListType__localMode, "localMode" },
	{ (long)ns2__ModesListType__inversionMode, "inversionMode" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ModesListType2s(struct soap *soap, enum ns2__ModesListType n)
{	const char *s = soap_code_str(soap_codes_ns2__ModesListType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ModesListType(struct soap *soap, const char *tag, int id, const enum ns2__ModesListType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ModesListType), type) || soap_send(soap, soap_ns2__ModesListType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ModesListType(struct soap *soap, const char *s, enum ns2__ModesListType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ModesListType, s);
	if (map)
		*a = (enum ns2__ModesListType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ModesListType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ModesListType * SOAP_FMAC4 soap_in_ns2__ModesListType(struct soap *soap, const char *tag, enum ns2__ModesListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ModesListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ModesListType, sizeof(enum ns2__ModesListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ModesListType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ModesListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ModesListType, 0, sizeof(enum ns2__ModesListType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ModesListType(struct soap *soap, const enum ns2__ModesListType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ModesListType);
	if (soap_out_ns2__ModesListType(soap, tag?tag:"ns2:ModesListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ModesListType * SOAP_FMAC4 soap_get_ns2__ModesListType(struct soap *soap, enum ns2__ModesListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ModesListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EfSymmetryType(struct soap *soap, enum ns2__EfSymmetryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__EfSymmetryType
	*a = SOAP_DEFAULT_ns2__EfSymmetryType;
#else
	*a = (enum ns2__EfSymmetryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__EfSymmetryType[] =
{	{ (long)ns2__EfSymmetryType__e, "e" },
	{ (long)ns2__EfSymmetryType__f, "f" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__EfSymmetryType2s(struct soap *soap, enum ns2__EfSymmetryType n)
{	const char *s = soap_code_str(soap_codes_ns2__EfSymmetryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EfSymmetryType(struct soap *soap, const char *tag, int id, const enum ns2__EfSymmetryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EfSymmetryType), type) || soap_send(soap, soap_ns2__EfSymmetryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__EfSymmetryType(struct soap *soap, const char *s, enum ns2__EfSymmetryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__EfSymmetryType, s);
	if (map)
		*a = (enum ns2__EfSymmetryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__EfSymmetryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__EfSymmetryType * SOAP_FMAC4 soap_in_ns2__EfSymmetryType(struct soap *soap, const char *tag, enum ns2__EfSymmetryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__EfSymmetryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EfSymmetryType, sizeof(enum ns2__EfSymmetryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__EfSymmetryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__EfSymmetryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EfSymmetryType, 0, sizeof(enum ns2__EfSymmetryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EfSymmetryType(struct soap *soap, const enum ns2__EfSymmetryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EfSymmetryType);
	if (soap_out_ns2__EfSymmetryType(soap, tag?tag:"ns2:EfSymmetryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EfSymmetryType * SOAP_FMAC4 soap_get_ns2__EfSymmetryType(struct soap *soap, enum ns2__EfSymmetryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EfSymmetryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CouplingListType(struct soap *soap, enum ns2__CouplingListType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CouplingListType
	*a = SOAP_DEFAULT_ns2__CouplingListType;
#else
	*a = (enum ns2__CouplingListType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CouplingListType[] =
{	{ (long)ns2__CouplingListType__bBetaOther, "bBetaOther" },
	{ (long)ns2__CouplingListType__bBetaJ, "bBetaJ" },
	{ (long)ns2__CouplingListType__bBetaS, "bBetaS" },
	{ (long)ns2__CouplingListType__bBetaN, "bBetaN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CouplingListType2s(struct soap *soap, enum ns2__CouplingListType n)
{	const char *s = soap_code_str(soap_codes_ns2__CouplingListType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CouplingListType(struct soap *soap, const char *tag, int id, const enum ns2__CouplingListType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CouplingListType), type) || soap_send(soap, soap_ns2__CouplingListType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CouplingListType(struct soap *soap, const char *s, enum ns2__CouplingListType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CouplingListType, s);
	if (map)
		*a = (enum ns2__CouplingListType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CouplingListType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CouplingListType * SOAP_FMAC4 soap_in_ns2__CouplingListType(struct soap *soap, const char *tag, enum ns2__CouplingListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CouplingListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CouplingListType, sizeof(enum ns2__CouplingListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CouplingListType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CouplingListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CouplingListType, 0, sizeof(enum ns2__CouplingListType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CouplingListType(struct soap *soap, const enum ns2__CouplingListType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CouplingListType);
	if (soap_out_ns2__CouplingListType(soap, tag?tag:"ns2:CouplingListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CouplingListType * SOAP_FMAC4 soap_get_ns2__CouplingListType(struct soap *soap, enum ns2__CouplingListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CouplingListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__C2SymmetryType(struct soap *soap, enum ns2__C2SymmetryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__C2SymmetryType
	*a = SOAP_DEFAULT_ns2__C2SymmetryType;
#else
	*a = (enum ns2__C2SymmetryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__C2SymmetryType[] =
{	{ (long)ns2__C2SymmetryType___x002b, "+" },
	{ (long)ns2__C2SymmetryType___x002d, "-" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__C2SymmetryType2s(struct soap *soap, enum ns2__C2SymmetryType n)
{	const char *s = soap_code_str(soap_codes_ns2__C2SymmetryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__C2SymmetryType(struct soap *soap, const char *tag, int id, const enum ns2__C2SymmetryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__C2SymmetryType), type) || soap_send(soap, soap_ns2__C2SymmetryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__C2SymmetryType(struct soap *soap, const char *s, enum ns2__C2SymmetryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__C2SymmetryType, s);
	if (map)
		*a = (enum ns2__C2SymmetryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__C2SymmetryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__C2SymmetryType * SOAP_FMAC4 soap_in_ns2__C2SymmetryType(struct soap *soap, const char *tag, enum ns2__C2SymmetryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__C2SymmetryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__C2SymmetryType, sizeof(enum ns2__C2SymmetryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__C2SymmetryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__C2SymmetryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__C2SymmetryType, 0, sizeof(enum ns2__C2SymmetryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__C2SymmetryType(struct soap *soap, const enum ns2__C2SymmetryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__C2SymmetryType);
	if (soap_out_ns2__C2SymmetryType(soap, tag?tag:"ns2:C2SymmetryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__C2SymmetryType * SOAP_FMAC4 soap_get_ns2__C2SymmetryType(struct soap *soap, enum ns2__C2SymmetryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__C2SymmetryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MethodCategoryType(struct soap *soap, enum ns2__MethodCategoryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MethodCategoryType
	*a = SOAP_DEFAULT_ns2__MethodCategoryType;
#else
	*a = (enum ns2__MethodCategoryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MethodCategoryType[] =
{	{ (long)ns2__MethodCategoryType__experiment, "experiment" },
	{ (long)ns2__MethodCategoryType__theory, "theory" },
	{ (long)ns2__MethodCategoryType__recommended, "recommended" },
	{ (long)ns2__MethodCategoryType__evaluated, "evaluated" },
	{ (long)ns2__MethodCategoryType__empirical, "empirical" },
	{ (long)ns2__MethodCategoryType__scalingLaw, "scalingLaw" },
	{ (long)ns2__MethodCategoryType__semiempirical, "semiempirical" },
	{ (long)ns2__MethodCategoryType__compilation, "compilation" },
	{ (long)ns2__MethodCategoryType__derived, "derived" },
	{ (long)ns2__MethodCategoryType__observed, "observed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MethodCategoryType2s(struct soap *soap, enum ns2__MethodCategoryType n)
{	const char *s = soap_code_str(soap_codes_ns2__MethodCategoryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MethodCategoryType(struct soap *soap, const char *tag, int id, const enum ns2__MethodCategoryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MethodCategoryType), type) || soap_send(soap, soap_ns2__MethodCategoryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MethodCategoryType(struct soap *soap, const char *s, enum ns2__MethodCategoryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MethodCategoryType, s);
	if (map)
		*a = (enum ns2__MethodCategoryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MethodCategoryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MethodCategoryType * SOAP_FMAC4 soap_in_ns2__MethodCategoryType(struct soap *soap, const char *tag, enum ns2__MethodCategoryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MethodCategoryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MethodCategoryType, sizeof(enum ns2__MethodCategoryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MethodCategoryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MethodCategoryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MethodCategoryType, 0, sizeof(enum ns2__MethodCategoryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MethodCategoryType(struct soap *soap, const enum ns2__MethodCategoryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MethodCategoryType);
	if (soap_out_ns2__MethodCategoryType(soap, tag?tag:"ns2:MethodCategoryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MethodCategoryType * SOAP_FMAC4 soap_get_ns2__MethodCategoryType(struct soap *soap, enum ns2__MethodCategoryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MethodCategoryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CategoryType(struct soap *soap, enum ns2__CategoryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CategoryType
	*a = SOAP_DEFAULT_ns2__CategoryType;
#else
	*a = (enum ns2__CategoryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CategoryType[] =
{	{ (long)ns2__CategoryType__book, "book" },
	{ (long)ns2__CategoryType__database, "database" },
	{ (long)ns2__CategoryType__journal, "journal" },
	{ (long)ns2__CategoryType__preprint, "preprint" },
	{ (long)ns2__CategoryType__private_x0020communication, "private communication" },
	{ (long)ns2__CategoryType__proceedings, "proceedings" },
	{ (long)ns2__CategoryType__report, "report" },
	{ (long)ns2__CategoryType__theses, "theses" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CategoryType2s(struct soap *soap, enum ns2__CategoryType n)
{	const char *s = soap_code_str(soap_codes_ns2__CategoryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CategoryType(struct soap *soap, const char *tag, int id, const enum ns2__CategoryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CategoryType), type) || soap_send(soap, soap_ns2__CategoryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CategoryType(struct soap *soap, const char *s, enum ns2__CategoryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CategoryType, s);
	if (map)
		*a = (enum ns2__CategoryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CategoryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CategoryType * SOAP_FMAC4 soap_in_ns2__CategoryType(struct soap *soap, const char *tag, enum ns2__CategoryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CategoryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CategoryType, sizeof(enum ns2__CategoryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CategoryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CategoryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CategoryType, 0, sizeof(enum ns2__CategoryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CategoryType(struct soap *soap, const enum ns2__CategoryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CategoryType);
	if (soap_out_ns2__CategoryType(soap, tag?tag:"ns2:CategoryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CategoryType * SOAP_FMAC4 soap_get_ns2__CategoryType(struct soap *soap, enum ns2__CategoryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CategoryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MixingClassType(struct soap *soap, enum ns2__MixingClassType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MixingClassType
	*a = SOAP_DEFAULT_ns2__MixingClassType;
#else
	*a = (enum ns2__MixingClassType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MixingClassType[] =
{	{ (long)ns2__MixingClassType__squared, "squared" },
	{ (long)ns2__MixingClassType__signed_, "signed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MixingClassType2s(struct soap *soap, enum ns2__MixingClassType n)
{	const char *s = soap_code_str(soap_codes_ns2__MixingClassType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MixingClassType(struct soap *soap, const char *tag, int id, const enum ns2__MixingClassType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MixingClassType), type) || soap_send(soap, soap_ns2__MixingClassType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MixingClassType(struct soap *soap, const char *s, enum ns2__MixingClassType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MixingClassType, s);
	if (map)
		*a = (enum ns2__MixingClassType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MixingClassType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MixingClassType * SOAP_FMAC4 soap_in_ns2__MixingClassType(struct soap *soap, const char *tag, enum ns2__MixingClassType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MixingClassType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MixingClassType, sizeof(enum ns2__MixingClassType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MixingClassType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MixingClassType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MixingClassType, 0, sizeof(enum ns2__MixingClassType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MixingClassType(struct soap *soap, const enum ns2__MixingClassType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MixingClassType);
	if (soap_out_ns2__MixingClassType(soap, tag?tag:"ns2:MixingClassType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MixingClassType * SOAP_FMAC4 soap_get_ns2__MixingClassType(struct soap *soap, enum ns2__MixingClassType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MixingClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ParityType(struct soap *soap, enum ns2__ParityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ParityType
	*a = SOAP_DEFAULT_ns2__ParityType;
#else
	*a = (enum ns2__ParityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ParityType[] =
{	{ (long)ns2__ParityType__even, "even" },
	{ (long)ns2__ParityType__odd, "odd" },
	{ (long)ns2__ParityType__undefined, "undefined" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ParityType2s(struct soap *soap, enum ns2__ParityType n)
{	const char *s = soap_code_str(soap_codes_ns2__ParityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParityType(struct soap *soap, const char *tag, int id, const enum ns2__ParityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParityType), type) || soap_send(soap, soap_ns2__ParityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ParityType(struct soap *soap, const char *s, enum ns2__ParityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ParityType, s);
	if (map)
		*a = (enum ns2__ParityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ParityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ParityType * SOAP_FMAC4 soap_in_ns2__ParityType(struct soap *soap, const char *tag, enum ns2__ParityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ParityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParityType, sizeof(enum ns2__ParityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ParityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ParityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParityType, 0, sizeof(enum ns2__ParityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ParityType(struct soap *soap, const enum ns2__ParityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ParityType);
	if (soap_out_ns2__ParityType(soap, tag?tag:"ns2:ParityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ParityType * SOAP_FMAC4 soap_get_ns2__ParityType(struct soap *soap, enum ns2__ParityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ReferenceFrameType(struct soap *soap, enum ns2__ReferenceFrameType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ReferenceFrameType
	*a = SOAP_DEFAULT_ns2__ReferenceFrameType;
#else
	*a = (enum ns2__ReferenceFrameType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ReferenceFrameType[] =
{	{ (long)ns2__ReferenceFrameType__CenterOfMass, "CenterOfMass" },
	{ (long)ns2__ReferenceFrameType__LaboratoryFrame, "LaboratoryFrame" },
	{ (long)ns2__ReferenceFrameType__TargetFrame, "TargetFrame" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ReferenceFrameType2s(struct soap *soap, enum ns2__ReferenceFrameType n)
{	const char *s = soap_code_str(soap_codes_ns2__ReferenceFrameType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReferenceFrameType(struct soap *soap, const char *tag, int id, const enum ns2__ReferenceFrameType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReferenceFrameType), type) || soap_send(soap, soap_ns2__ReferenceFrameType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ReferenceFrameType(struct soap *soap, const char *s, enum ns2__ReferenceFrameType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ReferenceFrameType, s);
	if (map)
		*a = (enum ns2__ReferenceFrameType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ReferenceFrameType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ReferenceFrameType * SOAP_FMAC4 soap_in_ns2__ReferenceFrameType(struct soap *soap, const char *tag, enum ns2__ReferenceFrameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ReferenceFrameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReferenceFrameType, sizeof(enum ns2__ReferenceFrameType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ReferenceFrameType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ReferenceFrameType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReferenceFrameType, 0, sizeof(enum ns2__ReferenceFrameType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReferenceFrameType(struct soap *soap, const enum ns2__ReferenceFrameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ReferenceFrameType);
	if (soap_out_ns2__ReferenceFrameType(soap, tag?tag:"ns2:ReferenceFrameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReferenceFrameType * SOAP_FMAC4 soap_get_ns2__ReferenceFrameType(struct soap *soap, enum ns2__ReferenceFrameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReferenceFrameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DataDescriptionType(struct soap *soap, enum ns2__DataDescriptionType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DataDescriptionType
	*a = SOAP_DEFAULT_ns2__DataDescriptionType;
#else
	*a = (enum ns2__DataDescriptionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DataDescriptionType[] =
{	{ (long)ns2__DataDescriptionType__crossSection, "crossSection" },
	{ (long)ns2__DataDescriptionType__collisionStrength, "collisionStrength" },
	{ (long)ns2__DataDescriptionType__rateCoefficient, "rateCoefficient" },
	{ (long)ns2__DataDescriptionType__probability, "probability" },
	{ (long)ns2__DataDescriptionType__effectiveCollisionStrength, "effectiveCollisionStrength" },
	{ (long)ns2__DataDescriptionType__sputteringYield, "sputteringYield" },
	{ (long)ns2__DataDescriptionType__sputteredEnergyCoefficient, "sputteredEnergyCoefficient" },
	{ (long)ns2__DataDescriptionType__particleReflectionCoefficient, "particleReflectionCoefficient" },
	{ (long)ns2__DataDescriptionType__energyReflectionCoefficient, "energyReflectionCoefficient" },
	{ (long)ns2__DataDescriptionType__meanPenetrationDepth, "meanPenetrationDepth" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DataDescriptionType2s(struct soap *soap, enum ns2__DataDescriptionType n)
{	const char *s = soap_code_str(soap_codes_ns2__DataDescriptionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataDescriptionType(struct soap *soap, const char *tag, int id, const enum ns2__DataDescriptionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataDescriptionType), type) || soap_send(soap, soap_ns2__DataDescriptionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DataDescriptionType(struct soap *soap, const char *s, enum ns2__DataDescriptionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DataDescriptionType, s);
	if (map)
		*a = (enum ns2__DataDescriptionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DataDescriptionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DataDescriptionType * SOAP_FMAC4 soap_in_ns2__DataDescriptionType(struct soap *soap, const char *tag, enum ns2__DataDescriptionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DataDescriptionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataDescriptionType, sizeof(enum ns2__DataDescriptionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DataDescriptionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DataDescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataDescriptionType, 0, sizeof(enum ns2__DataDescriptionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DataDescriptionType(struct soap *soap, const enum ns2__DataDescriptionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DataDescriptionType);
	if (soap_out_ns2__DataDescriptionType(soap, tag?tag:"ns2:DataDescriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DataDescriptionType * SOAP_FMAC4 soap_get_ns2__DataDescriptionType(struct soap *soap, enum ns2__DataDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void __ns2__RoVibronicSplittingType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->__ns2__RoVibronicSplittingType_sequence::Label);
	soap_default_std__string(soap, &this->__ns2__RoVibronicSplittingType_sequence::Type);
}

void __ns2__RoVibronicSplittingType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->__ns2__RoVibronicSplittingType_sequence::Label, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->__ns2__RoVibronicSplittingType_sequence::Label);
	soap_embedded(soap, &this->__ns2__RoVibronicSplittingType_sequence::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->__ns2__RoVibronicSplittingType_sequence::Type);
}

int __ns2__RoVibronicSplittingType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__RoVibronicSplittingType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__RoVibronicSplittingType_sequence(struct soap *soap, const char *tag, int id, const __ns2__RoVibronicSplittingType_sequence *a, const char *type)
{
	if (soap_out_std__string(soap, "ns2:Label", -1, &(a->__ns2__RoVibronicSplittingType_sequence::Label), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Type", -1, &(a->__ns2__RoVibronicSplittingType_sequence::Type), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__RoVibronicSplittingType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__RoVibronicSplittingType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__RoVibronicSplittingType_sequence * SOAP_FMAC4 soap_in___ns2__RoVibronicSplittingType_sequence(struct soap *soap, const char *tag, __ns2__RoVibronicSplittingType_sequence *a, const char *type)
{
	a = (__ns2__RoVibronicSplittingType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__RoVibronicSplittingType_sequence, sizeof(__ns2__RoVibronicSplittingType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_Label1 = 1;
	size_t soap_flag_Type1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Label", &(a->__ns2__RoVibronicSplittingType_sequence::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Type", &(a->__ns2__RoVibronicSplittingType_sequence::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Label1 > 0 || soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns2__RoVibronicSplittingType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:RoVibronicSplittingType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__RoVibronicSplittingType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__RoVibronicSplittingType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__RoVibronicSplittingType_sequence * SOAP_FMAC4 soap_get___ns2__RoVibronicSplittingType_sequence(struct soap *soap, __ns2__RoVibronicSplittingType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__RoVibronicSplittingType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__RoVibronicSplittingType_sequence * SOAP_FMAC2 soap_instantiate___ns2__RoVibronicSplittingType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__RoVibronicSplittingType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__RoVibronicSplittingType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__RoVibronicSplittingType_sequence);
		if (size)
			*size = sizeof(__ns2__RoVibronicSplittingType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__RoVibronicSplittingType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__RoVibronicSplittingType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__RoVibronicSplittingType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__RoVibronicSplittingType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__RoVibronicSplittingType_sequence %p -> %p\n", q, p));
	*(__ns2__RoVibronicSplittingType_sequence*)p = *(__ns2__RoVibronicSplittingType_sequence*)q;
}

void __ns2__union_HyperfineQuantumNumbersType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType = 0;
}

void __ns2__union_HyperfineQuantumNumbersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_HyperfineQuantumNumbersType(soap, this->__ns2__union_HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType, &this->__ns2__union_HyperfineQuantumNumbersType::union_HyperfineQuantumNumbersType);
}

int __ns2__union_HyperfineQuantumNumbersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_HyperfineQuantumNumbersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_HyperfineQuantumNumbersType(struct soap *soap, const char *tag, int id, const __ns2__union_HyperfineQuantumNumbersType *a, const char *type)
{
	if (soap_out__ns2__union_HyperfineQuantumNumbersType(soap, a->__ns2__union_HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType, &a->__ns2__union_HyperfineQuantumNumbersType::union_HyperfineQuantumNumbersType))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_HyperfineQuantumNumbersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_HyperfineQuantumNumbersType(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_HyperfineQuantumNumbersType * SOAP_FMAC4 soap_in___ns2__union_HyperfineQuantumNumbersType(struct soap *soap, const char *tag, __ns2__union_HyperfineQuantumNumbersType *a, const char *type)
{
	a = (__ns2__union_HyperfineQuantumNumbersType *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType, sizeof(__ns2__union_HyperfineQuantumNumbersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
		if (!soap_in__ns2__union_HyperfineQuantumNumbersType(soap, &a->__union_HyperfineQuantumNumbersType, &a->union_HyperfineQuantumNumbersType))
			return NULL;
	return a;
}

int __ns2__union_HyperfineQuantumNumbersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:union-HyperfineQuantumNumbersType", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_HyperfineQuantumNumbersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_HyperfineQuantumNumbersType(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_HyperfineQuantumNumbersType * SOAP_FMAC4 soap_get___ns2__union_HyperfineQuantumNumbersType(struct soap *soap, __ns2__union_HyperfineQuantumNumbersType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_HyperfineQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__union_HyperfineQuantumNumbersType * SOAP_FMAC2 soap_instantiate___ns2__union_HyperfineQuantumNumbersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_HyperfineQuantumNumbersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_HyperfineQuantumNumbersType);
		if (size)
			*size = sizeof(__ns2__union_HyperfineQuantumNumbersType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_HyperfineQuantumNumbersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__union_HyperfineQuantumNumbersType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__union_HyperfineQuantumNumbersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__union_HyperfineQuantumNumbersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__union_HyperfineQuantumNumbersType %p -> %p\n", q, p));
	*(__ns2__union_HyperfineQuantumNumbersType*)p = *(__ns2__union_HyperfineQuantumNumbersType*)q;
}

void __ns2__MolecularPropertiesType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__MolecularPropertiesType_sequence::OtherProperties = NULL;
}

void __ns2__MolecularPropertiesType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CharacterisationType(soap, &this->__ns2__MolecularPropertiesType_sequence::OtherProperties);
}

int __ns2__MolecularPropertiesType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__MolecularPropertiesType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__MolecularPropertiesType_sequence(struct soap *soap, const char *tag, int id, const __ns2__MolecularPropertiesType_sequence *a, const char *type)
{
	if (soap_out_PointerTons2__CharacterisationType(soap, "ns2:OtherProperties", -1, &(a->__ns2__MolecularPropertiesType_sequence::OtherProperties), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__MolecularPropertiesType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__MolecularPropertiesType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__MolecularPropertiesType_sequence * SOAP_FMAC4 soap_in___ns2__MolecularPropertiesType_sequence(struct soap *soap, const char *tag, __ns2__MolecularPropertiesType_sequence *a, const char *type)
{
	a = (__ns2__MolecularPropertiesType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__MolecularPropertiesType_sequence, sizeof(__ns2__MolecularPropertiesType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_OtherProperties1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OtherProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CharacterisationType(soap, "ns2:OtherProperties", &(a->__ns2__MolecularPropertiesType_sequence::OtherProperties), "ns2:CharacterisationType"))
				{	soap_flag_OtherProperties1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

int __ns2__MolecularPropertiesType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:MolecularPropertiesType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__MolecularPropertiesType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__MolecularPropertiesType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__MolecularPropertiesType_sequence * SOAP_FMAC4 soap_get___ns2__MolecularPropertiesType_sequence(struct soap *soap, __ns2__MolecularPropertiesType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__MolecularPropertiesType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__MolecularPropertiesType_sequence * SOAP_FMAC2 soap_instantiate___ns2__MolecularPropertiesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__MolecularPropertiesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__MolecularPropertiesType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__MolecularPropertiesType_sequence);
		if (size)
			*size = sizeof(__ns2__MolecularPropertiesType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__MolecularPropertiesType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__MolecularPropertiesType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__MolecularPropertiesType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__MolecularPropertiesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__MolecularPropertiesType_sequence %p -> %p\n", q, p));
	*(__ns2__MolecularPropertiesType_sequence*)p = *(__ns2__MolecularPropertiesType_sequence*)q;
}

void __ns2__BondArrayType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__BondArrayType_sequence::Bond = NULL;
}

void __ns2__BondArrayType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__BondType(soap, &this->__ns2__BondArrayType_sequence::Bond);
}

int __ns2__BondArrayType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__BondArrayType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__BondArrayType_sequence(struct soap *soap, const char *tag, int id, const __ns2__BondArrayType_sequence *a, const char *type)
{
	if (a->__ns2__BondArrayType_sequence::Bond)
	{	if (soap_out_PointerTons2__BondType(soap, "ns2:Bond", -1, &a->__ns2__BondArrayType_sequence::Bond, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Bond"))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__BondArrayType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__BondArrayType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__BondArrayType_sequence * SOAP_FMAC4 soap_in___ns2__BondArrayType_sequence(struct soap *soap, const char *tag, __ns2__BondArrayType_sequence *a, const char *type)
{
	a = (__ns2__BondArrayType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__BondArrayType_sequence, sizeof(__ns2__BondArrayType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_Bond1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bond1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BondType(soap, "ns2:Bond", &(a->__ns2__BondArrayType_sequence::Bond), "ns2:BondType"))
				{	soap_flag_Bond1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bond1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns2__BondArrayType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:BondArrayType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__BondArrayType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__BondArrayType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__BondArrayType_sequence * SOAP_FMAC4 soap_get___ns2__BondArrayType_sequence(struct soap *soap, __ns2__BondArrayType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__BondArrayType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__BondArrayType_sequence * SOAP_FMAC2 soap_instantiate___ns2__BondArrayType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__BondArrayType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__BondArrayType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__BondArrayType_sequence);
		if (size)
			*size = sizeof(__ns2__BondArrayType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__BondArrayType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__BondArrayType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__BondArrayType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__BondArrayType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__BondArrayType_sequence %p -> %p\n", q, p));
	*(__ns2__BondArrayType_sequence*)p = *(__ns2__BondArrayType_sequence*)q;
}

void __ns2__AtomArrayType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__AtomArrayType_sequence::AtomN = NULL;
}

void __ns2__AtomArrayType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AtomNType(soap, &this->__ns2__AtomArrayType_sequence::AtomN);
}

int __ns2__AtomArrayType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__AtomArrayType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__AtomArrayType_sequence(struct soap *soap, const char *tag, int id, const __ns2__AtomArrayType_sequence *a, const char *type)
{
	if (a->__ns2__AtomArrayType_sequence::AtomN)
	{	if (soap_out_PointerTons2__AtomNType(soap, "ns2:AtomN", -1, &a->__ns2__AtomArrayType_sequence::AtomN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:AtomN"))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__AtomArrayType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__AtomArrayType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__AtomArrayType_sequence * SOAP_FMAC4 soap_in___ns2__AtomArrayType_sequence(struct soap *soap, const char *tag, __ns2__AtomArrayType_sequence *a, const char *type)
{
	a = (__ns2__AtomArrayType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__AtomArrayType_sequence, sizeof(__ns2__AtomArrayType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_AtomN1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AtomN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomNType(soap, "ns2:AtomN", &(a->__ns2__AtomArrayType_sequence::AtomN), "ns2:AtomNType"))
				{	soap_flag_AtomN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AtomN1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns2__AtomArrayType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:AtomArrayType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__AtomArrayType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__AtomArrayType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__AtomArrayType_sequence * SOAP_FMAC4 soap_get___ns2__AtomArrayType_sequence(struct soap *soap, __ns2__AtomArrayType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__AtomArrayType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__AtomArrayType_sequence * SOAP_FMAC2 soap_instantiate___ns2__AtomArrayType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__AtomArrayType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__AtomArrayType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__AtomArrayType_sequence);
		if (size)
			*size = sizeof(__ns2__AtomArrayType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__AtomArrayType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__AtomArrayType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__AtomArrayType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__AtomArrayType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__AtomArrayType_sequence %p -> %p\n", q, p));
	*(__ns2__AtomArrayType_sequence*)p = *(__ns2__AtomArrayType_sequence*)q;
}

void __ns2__ShellsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons2__ShellPairType(soap, &this->__ns2__ShellsType_sequence::ShellPair);
}

void __ns2__ShellsType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ShellPairType(soap, &this->__ns2__ShellsType_sequence::ShellPair);
}

int __ns2__ShellsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__ShellsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ShellsType_sequence(struct soap *soap, const char *tag, int id, const __ns2__ShellsType_sequence *a, const char *type)
{
	if (soap_out_std__vectorTemplateOfPointerTons2__ShellPairType(soap, "ns2:ShellPair", -1, &(a->__ns2__ShellsType_sequence::ShellPair), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__ShellsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__ShellsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__ShellsType_sequence * SOAP_FMAC4 soap_in___ns2__ShellsType_sequence(struct soap *soap, const char *tag, __ns2__ShellsType_sequence *a, const char *type)
{
	a = (__ns2__ShellsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__ShellsType_sequence, sizeof(__ns2__ShellsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ShellPairType(soap, "ns2:ShellPair", &(a->__ns2__ShellsType_sequence::ShellPair), "ns2:ShellPairType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__ns2__ShellsType_sequence::ShellPair.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns2__ShellsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:ShellsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__ShellsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__ShellsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__ShellsType_sequence * SOAP_FMAC4 soap_get___ns2__ShellsType_sequence(struct soap *soap, __ns2__ShellsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ShellsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__ShellsType_sequence * SOAP_FMAC2 soap_instantiate___ns2__ShellsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ShellsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ShellsType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__ShellsType_sequence);
		if (size)
			*size = sizeof(__ns2__ShellsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__ShellsType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__ShellsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__ShellsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ShellsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__ShellsType_sequence %p -> %p\n", q, p));
	*(__ns2__ShellsType_sequence*)p = *(__ns2__ShellsType_sequence*)q;
}

void __ns2__ProductsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns2__StateRef(soap, &this->__ns2__ProductsType_sequence::StateRef);
}

void __ns2__ProductsType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->__ns2__ProductsType_sequence::StateRef, SOAP_TYPE_ns2__StateRef);
	soap_serialize_ns2__StateRef(soap, &this->__ns2__ProductsType_sequence::StateRef);
}

int __ns2__ProductsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__ProductsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ProductsType_sequence(struct soap *soap, const char *tag, int id, const __ns2__ProductsType_sequence *a, const char *type)
{
	if (soap_out_ns2__StateRef(soap, "ns2:StateRef", -1, &(a->__ns2__ProductsType_sequence::StateRef), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__ProductsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__ProductsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__ProductsType_sequence * SOAP_FMAC4 soap_in___ns2__ProductsType_sequence(struct soap *soap, const char *tag, __ns2__ProductsType_sequence *a, const char *type)
{
	a = (__ns2__ProductsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__ProductsType_sequence, sizeof(__ns2__ProductsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_StateRef1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StateRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__StateRef(soap, "ns2:StateRef", &(a->__ns2__ProductsType_sequence::StateRef), "ns2:StateRef"))
				{	soap_flag_StateRef1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StateRef1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns2__ProductsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:ProductsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__ProductsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__ProductsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__ProductsType_sequence * SOAP_FMAC4 soap_get___ns2__ProductsType_sequence(struct soap *soap, __ns2__ProductsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ProductsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__ProductsType_sequence * SOAP_FMAC2 soap_instantiate___ns2__ProductsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ProductsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ProductsType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__ProductsType_sequence);
		if (size)
			*size = sizeof(__ns2__ProductsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__ProductsType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__ProductsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__ProductsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ProductsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__ProductsType_sequence %p -> %p\n", q, p));
	*(__ns2__ProductsType_sequence*)p = *(__ns2__ProductsType_sequence*)q;
}

void __ns2__ReactantsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns2__StateRef(soap, &this->__ns2__ReactantsType_sequence::StateRef);
}

void __ns2__ReactantsType_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->__ns2__ReactantsType_sequence::StateRef, SOAP_TYPE_ns2__StateRef);
	soap_serialize_ns2__StateRef(soap, &this->__ns2__ReactantsType_sequence::StateRef);
}

int __ns2__ReactantsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__ReactantsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ReactantsType_sequence(struct soap *soap, const char *tag, int id, const __ns2__ReactantsType_sequence *a, const char *type)
{
	if (soap_out_ns2__StateRef(soap, "ns2:StateRef", -1, &(a->__ns2__ReactantsType_sequence::StateRef), ""))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__ReactantsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__ReactantsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__ReactantsType_sequence * SOAP_FMAC4 soap_in___ns2__ReactantsType_sequence(struct soap *soap, const char *tag, __ns2__ReactantsType_sequence *a, const char *type)
{
	a = (__ns2__ReactantsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__ReactantsType_sequence, sizeof(__ns2__ReactantsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_StateRef1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StateRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__StateRef(soap, "ns2:StateRef", &(a->__ns2__ReactantsType_sequence::StateRef), "ns2:StateRef"))
				{	soap_flag_StateRef1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StateRef1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __ns2__ReactantsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:ReactantsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__ReactantsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__ReactantsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__ReactantsType_sequence * SOAP_FMAC4 soap_get___ns2__ReactantsType_sequence(struct soap *soap, __ns2__ReactantsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ReactantsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__ReactantsType_sequence * SOAP_FMAC2 soap_instantiate___ns2__ReactantsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ReactantsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ReactantsType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__ReactantsType_sequence);
		if (size)
			*size = sizeof(__ns2__ReactantsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__ReactantsType_sequence[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__ReactantsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__ReactantsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ReactantsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__ReactantsType_sequence %p -> %p\n", q, p));
	*(__ns2__ReactantsType_sequence*)p = *(__ns2__ReactantsType_sequence*)q;
}

void _ns2__LSCouplingType_Seniority::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &this->_ns2__LSCouplingType_Seniority::__item);
	this->_ns2__LSCouplingType_Seniority::ns2__sourceRef = NULL;
}

void _ns2__LSCouplingType_Seniority::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->_ns2__LSCouplingType_Seniority::__item);
}

int _ns2__LSCouplingType_Seniority::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__LSCouplingType_Seniority(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__LSCouplingType_Seniority(struct soap *soap, const char *tag, int id, const _ns2__LSCouplingType_Seniority *a, const char *type)
{
	if (((_ns2__LSCouplingType_Seniority*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((_ns2__LSCouplingType_Seniority*)a)->ns2__sourceRef->c_str(), 1);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->_ns2__LSCouplingType_Seniority::__item, "");
}

void *_ns2__LSCouplingType_Seniority::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__LSCouplingType_Seniority(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__LSCouplingType_Seniority * SOAP_FMAC4 soap_in__ns2__LSCouplingType_Seniority(struct soap *soap, const char *tag, _ns2__LSCouplingType_Seniority *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns2__LSCouplingType_Seniority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__LSCouplingType_Seniority, sizeof(_ns2__LSCouplingType_Seniority), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__LSCouplingType_Seniority)
			return (_ns2__LSCouplingType_Seniority *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__LSCouplingType_Seniority*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((_ns2__LSCouplingType_Seniority*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->_ns2__LSCouplingType_Seniority::__item), ""))
		return NULL;
	return a;
}

int _ns2__LSCouplingType_Seniority::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__LSCouplingType_Seniority);
	if (this->soap_out(soap, tag?tag:"ns2:LSCouplingType-Seniority", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__LSCouplingType_Seniority::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__LSCouplingType_Seniority(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__LSCouplingType_Seniority * SOAP_FMAC4 soap_get__ns2__LSCouplingType_Seniority(struct soap *soap, _ns2__LSCouplingType_Seniority *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__LSCouplingType_Seniority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__LSCouplingType_Seniority * SOAP_FMAC2 soap_instantiate__ns2__LSCouplingType_Seniority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__LSCouplingType_Seniority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__LSCouplingType_Seniority, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__LSCouplingType_Seniority);
		if (size)
			*size = sizeof(_ns2__LSCouplingType_Seniority);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns2__LSCouplingType_Seniority[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__LSCouplingType_Seniority);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__LSCouplingType_Seniority*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__LSCouplingType_Seniority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__LSCouplingType_Seniority %p -> %p\n", q, p));
	*(_ns2__LSCouplingType_Seniority*)p = *(_ns2__LSCouplingType_Seniority*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MultipoleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__MultipoleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__MultipoleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__MultipoleType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__MultipoleType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__MultipoleType, 0, sizeof(std::string), 0, soap_copy_ns2__MultipoleType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MultipoleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MultipoleType);
	if (soap_out_ns2__MultipoleType(soap, tag?tag:"ns2:MultipoleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__MultipoleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MultipoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StateRef(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__StateRef), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__StateRef(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__StateRef, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__StateRef, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__StateRef, 0, sizeof(std::string), 0, soap_copy_ns2__StateRef);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StateRef(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StateRef);
	if (soap_out_ns2__StateRef(soap, tag?tag:"ns2:StateRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__StateRef(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StateRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OrbitalAngularMomentumSymbolType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__OrbitalAngularMomentumSymbolType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType, 0, sizeof(std::string), 0, soap_copy_ns2__OrbitalAngularMomentumSymbolType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OrbitalAngularMomentumSymbolType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType);
	if (soap_out_ns2__OrbitalAngularMomentumSymbolType(soap, tag?tag:"ns2:OrbitalAngularMomentumSymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__OrbitalAngularMomentumSymbolType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OrbitalAngularMomentumSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PrincipalQuantumNumberType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__PrincipalQuantumNumberType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__PrincipalQuantumNumberType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__PrincipalQuantumNumberType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__PrincipalQuantumNumberType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__PrincipalQuantumNumberType, 0, sizeof(std::string), 0, soap_copy_ns2__PrincipalQuantumNumberType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PrincipalQuantumNumberType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PrincipalQuantumNumberType);
	if (soap_out_ns2__PrincipalQuantumNumberType(soap, tag?tag:"ns2:PrincipalQuantumNumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__PrincipalQuantumNumberType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PrincipalQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ElementSymbolType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__ElementSymbolType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__ElementSymbolType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ElementSymbolType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ElementSymbolType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__ElementSymbolType, 0, sizeof(std::string), 0, soap_copy_ns2__ElementSymbolType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ElementSymbolType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ElementSymbolType);
	if (soap_out_ns2__ElementSymbolType(soap, tag?tag:"ns2:ElementSymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__ElementSymbolType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ElementSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AngularMomentumType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__AngularMomentumType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__AngularMomentumType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__AngularMomentumType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__AngularMomentumType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__AngularMomentumType, 0, sizeof(std::string), 0, soap_copy_ns2__AngularMomentumType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AngularMomentumType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AngularMomentumType);
	if (soap_out_ns2__AngularMomentumType(soap, tag?tag:"ns2:AngularMomentumType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__AngularMomentumType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AngularMomentumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AngularMomentumProjectionType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__AngularMomentumProjectionType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__AngularMomentumProjectionType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__AngularMomentumProjectionType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__AngularMomentumProjectionType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__AngularMomentumProjectionType, 0, sizeof(std::string), 0, soap_copy_ns2__AngularMomentumProjectionType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AngularMomentumProjectionType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AngularMomentumProjectionType);
	if (soap_out_ns2__AngularMomentumProjectionType(soap, tag?tag:"ns2:AngularMomentumProjectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__AngularMomentumProjectionType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AngularMomentumProjectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataListType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__DataListType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__DataListType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__DataListType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__DataListType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__DataListType, 0, sizeof(std::string), 0, soap_copy_ns2__DataListType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DataListType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DataListType);
	if (soap_out_ns2__DataListType(soap, tag?tag:"ns2:DataListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__DataListType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__StatesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__StatesType::Atoms = NULL;
	this->ns2__StatesType::Molecules = NULL;
	this->ns2__StatesType::Solids = NULL;
	this->ns2__StatesType::Particles = NULL;
	/* transient soap skipped */
}

void ns2__StatesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AtomsType(soap, &this->ns2__StatesType::Atoms);
	soap_serialize_PointerTons2__MoleculesType(soap, &this->ns2__StatesType::Molecules);
	soap_serialize_PointerTons2__SolidsType(soap, &this->ns2__StatesType::Solids);
	soap_serialize_PointerTons2__ParticlesType(soap, &this->ns2__StatesType::Particles);
	/* transient soap skipped */
}

int ns2__StatesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__StatesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StatesType(struct soap *soap, const char *tag, int id, const ns2__StatesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StatesType), type))
		return soap->error;
	if (soap_out_PointerTons2__AtomsType(soap, "ns2:Atoms", -1, &(a->ns2__StatesType::Atoms), ""))
		return soap->error;
	if (soap_out_PointerTons2__MoleculesType(soap, "ns2:Molecules", -1, &(a->ns2__StatesType::Molecules), ""))
		return soap->error;
	if (soap_out_PointerTons2__SolidsType(soap, "ns2:Solids", -1, &(a->ns2__StatesType::Solids), ""))
		return soap->error;
	if (soap_out_PointerTons2__ParticlesType(soap, "ns2:Particles", -1, &(a->ns2__StatesType::Particles), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__StatesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__StatesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__StatesType * SOAP_FMAC4 soap_in_ns2__StatesType(struct soap *soap, const char *tag, ns2__StatesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__StatesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StatesType, sizeof(ns2__StatesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__StatesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__StatesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Atoms1 = 1;
	size_t soap_flag_Molecules1 = 1;
	size_t soap_flag_Solids1 = 1;
	size_t soap_flag_Particles1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Atoms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomsType(soap, "ns2:Atoms", &(a->ns2__StatesType::Atoms), "ns2:AtomsType"))
				{	soap_flag_Atoms1--;
					continue;
				}
			if (soap_flag_Molecules1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MoleculesType(soap, "ns2:Molecules", &(a->ns2__StatesType::Molecules), "ns2:MoleculesType"))
				{	soap_flag_Molecules1--;
					continue;
				}
			if (soap_flag_Solids1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SolidsType(soap, "ns2:Solids", &(a->ns2__StatesType::Solids), "ns2:SolidsType"))
				{	soap_flag_Solids1--;
					continue;
				}
			if (soap_flag_Particles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParticlesType(soap, "ns2:Particles", &(a->ns2__StatesType::Particles), "ns2:ParticlesType"))
				{	soap_flag_Particles1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__StatesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StatesType, 0, sizeof(ns2__StatesType), 0, soap_copy_ns2__StatesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__StatesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__StatesType);
	if (this->soap_out(soap, tag?tag:"ns2:StatesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__StatesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__StatesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__StatesType * SOAP_FMAC4 soap_get_ns2__StatesType(struct soap *soap, ns2__StatesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StatesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__StatesType * SOAP_FMAC2 soap_instantiate_ns2__StatesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__StatesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__StatesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__StatesType);
		if (size)
			*size = sizeof(ns2__StatesType);
		((ns2__StatesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__StatesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__StatesType);
		for (int i = 0; i < n; i++)
			((ns2__StatesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__StatesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__StatesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__StatesType %p -> %p\n", q, p));
	*(ns2__StatesType*)p = *(ns2__StatesType*)q;
}

void ns2__ProcessesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ProcessesType::Radiative = NULL;
	this->ns2__ProcessesType::ns2__NonRadiative = NULL;
	this->ns2__ProcessesType::Collisions = NULL;
	/* transient soap skipped */
}

void ns2__ProcessesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RadiativeType(soap, &this->ns2__ProcessesType::Radiative);
	soap_serialize_PointerTons2__NonRadiativeType(soap, &this->ns2__ProcessesType::ns2__NonRadiative);
	soap_serialize_PointerTons2__CollisionsType(soap, &this->ns2__ProcessesType::Collisions);
	/* transient soap skipped */
}

int ns2__ProcessesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ProcessesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ProcessesType(struct soap *soap, const char *tag, int id, const ns2__ProcessesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ProcessesType), type))
		return soap->error;
	if (soap_out_PointerTons2__RadiativeType(soap, "ns2:Radiative", -1, &(a->ns2__ProcessesType::Radiative), ""))
		return soap->error;
	if (soap_out_PointerTons2__NonRadiativeType(soap, "ns2:NonRadiative", -1, &(a->ns2__ProcessesType::ns2__NonRadiative), ""))
		return soap->error;
	if (soap_out_PointerTons2__CollisionsType(soap, "ns2:Collisions", -1, &(a->ns2__ProcessesType::Collisions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ProcessesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ProcessesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ProcessesType * SOAP_FMAC4 soap_in_ns2__ProcessesType(struct soap *soap, const char *tag, ns2__ProcessesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ProcessesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ProcessesType, sizeof(ns2__ProcessesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ProcessesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ProcessesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Radiative1 = 1;
	size_t soap_flag_ns2__NonRadiative1 = 1;
	size_t soap_flag_Collisions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Radiative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RadiativeType(soap, "ns2:Radiative", &(a->ns2__ProcessesType::Radiative), "ns2:RadiativeType"))
				{	soap_flag_Radiative1--;
					continue;
				}
			if (soap_flag_ns2__NonRadiative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NonRadiativeType(soap, "ns2:NonRadiative", &(a->ns2__ProcessesType::ns2__NonRadiative), "ns2:NonRadiativeType"))
				{	soap_flag_ns2__NonRadiative1--;
					continue;
				}
			if (soap_flag_Collisions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CollisionsType(soap, "ns2:Collisions", &(a->ns2__ProcessesType::Collisions), "ns2:CollisionsType"))
				{	soap_flag_Collisions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ProcessesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ProcessesType, 0, sizeof(ns2__ProcessesType), 0, soap_copy_ns2__ProcessesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ProcessesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ProcessesType);
	if (this->soap_out(soap, tag?tag:"ns2:ProcessesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ProcessesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ProcessesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ProcessesType * SOAP_FMAC4 soap_get_ns2__ProcessesType(struct soap *soap, ns2__ProcessesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ProcessesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ProcessesType * SOAP_FMAC2 soap_instantiate_ns2__ProcessesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ProcessesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ProcessesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ProcessesType);
		if (size)
			*size = sizeof(ns2__ProcessesType);
		((ns2__ProcessesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ProcessesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ProcessesType);
		for (int i = 0; i < n; i++)
			((ns2__ProcessesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ProcessesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ProcessesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ProcessesType %p -> %p\n", q, p));
	*(ns2__ProcessesType*)p = *(ns2__ProcessesType*)q;
}

void ns2__XSAMSDataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__XSAMSDataType::States = NULL;
	this->ns2__XSAMSDataType::Processes = NULL;
	this->ns2__XSAMSDataType::ns2__Sources = NULL;
	this->ns2__XSAMSDataType::ns2__Methods = NULL;
	this->ns2__XSAMSDataType::ns2__Functions = NULL;
	this->ns2__XSAMSDataType::Comments = NULL;
	/* transient soap skipped */
}

void ns2__XSAMSDataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__StatesType(soap, &this->ns2__XSAMSDataType::States);
	soap_serialize_PointerTons2__ProcessesType(soap, &this->ns2__XSAMSDataType::Processes);
	soap_serialize_PointerTons2__SourcesType(soap, &this->ns2__XSAMSDataType::ns2__Sources);
	soap_serialize_PointerTons2__MethodsType(soap, &this->ns2__XSAMSDataType::ns2__Methods);
	soap_serialize_PointerTons2__FunctionsType(soap, &this->ns2__XSAMSDataType::ns2__Functions);
	soap_serialize_PointerTostd__string(soap, &this->ns2__XSAMSDataType::Comments);
	/* transient soap skipped */
}

int ns2__XSAMSDataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__XSAMSDataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__XSAMSDataType(struct soap *soap, const char *tag, int id, const ns2__XSAMSDataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__XSAMSDataType), type))
		return soap->error;
	if (a->ns2__XSAMSDataType::States)
	{	if (soap_out_PointerTons2__StatesType(soap, "ns2:States", -1, &a->ns2__XSAMSDataType::States, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:States"))
		return soap->error;
	if (soap_out_PointerTons2__ProcessesType(soap, "ns2:Processes", -1, &(a->ns2__XSAMSDataType::Processes), ""))
		return soap->error;
	if (a->ns2__XSAMSDataType::ns2__Sources)
	{	if (soap_out_PointerTons2__SourcesType(soap, "ns2:Sources", -1, &a->ns2__XSAMSDataType::ns2__Sources, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Sources"))
		return soap->error;
	if (soap_out_PointerTons2__MethodsType(soap, "ns2:Methods", -1, &(a->ns2__XSAMSDataType::ns2__Methods), ""))
		return soap->error;
	if (soap_out_PointerTons2__FunctionsType(soap, "ns2:Functions", -1, &(a->ns2__XSAMSDataType::ns2__Functions), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__XSAMSDataType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__XSAMSDataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__XSAMSDataType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__XSAMSDataType * SOAP_FMAC4 soap_in_ns2__XSAMSDataType(struct soap *soap, const char *tag, ns2__XSAMSDataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__XSAMSDataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__XSAMSDataType, sizeof(ns2__XSAMSDataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__XSAMSDataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__XSAMSDataType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_States1 = 1;
	size_t soap_flag_Processes1 = 1;
	size_t soap_flag_ns2__Sources1 = 1;
	size_t soap_flag_ns2__Methods1 = 1;
	size_t soap_flag_ns2__Functions1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_States1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__StatesType(soap, "ns2:States", &(a->ns2__XSAMSDataType::States), "ns2:StatesType"))
				{	soap_flag_States1--;
					continue;
				}
			if (soap_flag_Processes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ProcessesType(soap, "ns2:Processes", &(a->ns2__XSAMSDataType::Processes), "ns2:ProcessesType"))
				{	soap_flag_Processes1--;
					continue;
				}
			if (soap_flag_ns2__Sources1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SourcesType(soap, "ns2:Sources", &(a->ns2__XSAMSDataType::ns2__Sources), "ns2:SourcesType"))
				{	soap_flag_ns2__Sources1--;
					continue;
				}
			if (soap_flag_ns2__Methods1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MethodsType(soap, "ns2:Methods", &(a->ns2__XSAMSDataType::ns2__Methods), "ns2:MethodsType"))
				{	soap_flag_ns2__Methods1--;
					continue;
				}
			if (soap_flag_ns2__Functions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FunctionsType(soap, "ns2:Functions", &(a->ns2__XSAMSDataType::ns2__Functions), "ns2:FunctionsType"))
				{	soap_flag_ns2__Functions1--;
					continue;
				}
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__XSAMSDataType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__XSAMSDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__XSAMSDataType, 0, sizeof(ns2__XSAMSDataType), 0, soap_copy_ns2__XSAMSDataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_States1 > 0 || soap_flag_ns2__Sources1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__XSAMSDataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__XSAMSDataType);
	if (this->soap_out(soap, tag?tag:"ns2:XSAMSDataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__XSAMSDataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__XSAMSDataType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__XSAMSDataType * SOAP_FMAC4 soap_get_ns2__XSAMSDataType(struct soap *soap, ns2__XSAMSDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__XSAMSDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__XSAMSDataType * SOAP_FMAC2 soap_instantiate_ns2__XSAMSDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__XSAMSDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__XSAMSDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__XSAMSDataType);
		if (size)
			*size = sizeof(ns2__XSAMSDataType);
		((ns2__XSAMSDataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__XSAMSDataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__XSAMSDataType);
		for (int i = 0; i < n; i++)
			((ns2__XSAMSDataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__XSAMSDataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__XSAMSDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__XSAMSDataType %p -> %p\n", q, p));
	*(ns2__XSAMSDataType*)p = *(ns2__XSAMSDataType*)q;
}

void ns2__CollisionalProcessClassType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CollisionalProcessClassType::UserDefinition = NULL;
	soap_default_std__vectorTemplateOfns2__CodeType(soap, &this->ns2__CollisionalProcessClassType::Code);
	this->ns2__CollisionalProcessClassType::IAEACode = NULL;
	/* transient soap skipped */
}

void ns2__CollisionalProcessClassType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns2__CodeType(soap, &this->ns2__CollisionalProcessClassType::Code);
	soap_serialize_PointerTons2__IAEACodeType(soap, &this->ns2__CollisionalProcessClassType::IAEACode);
	/* transient soap skipped */
}

int ns2__CollisionalProcessClassType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CollisionalProcessClassType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CollisionalProcessClassType(struct soap *soap, const char *tag, int id, const ns2__CollisionalProcessClassType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CollisionalProcessClassType), type))
		return soap->error;
	soap_outliteral(soap, "ns2:UserDefinition", &(a->ns2__CollisionalProcessClassType::UserDefinition), NULL);
	if (soap_out_std__vectorTemplateOfns2__CodeType(soap, "ns2:Code", -1, &(a->ns2__CollisionalProcessClassType::Code), ""))
		return soap->error;
	if (soap_out_PointerTons2__IAEACodeType(soap, "ns2:IAEACode", -1, &(a->ns2__CollisionalProcessClassType::IAEACode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CollisionalProcessClassType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CollisionalProcessClassType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CollisionalProcessClassType * SOAP_FMAC4 soap_in_ns2__CollisionalProcessClassType(struct soap *soap, const char *tag, ns2__CollisionalProcessClassType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CollisionalProcessClassType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CollisionalProcessClassType, sizeof(ns2__CollisionalProcessClassType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CollisionalProcessClassType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CollisionalProcessClassType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UserDefinition1 = 1;
	size_t soap_flag_IAEACode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserDefinition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:UserDefinition", &(a->ns2__CollisionalProcessClassType::UserDefinition)))
				{	soap_flag_UserDefinition1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__CodeType(soap, "ns2:Code", &(a->ns2__CollisionalProcessClassType::Code), "ns2:CodeType"))
					continue;
			if (soap_flag_IAEACode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IAEACodeType(soap, "ns2:IAEACode", &(a->ns2__CollisionalProcessClassType::IAEACode), "ns2:IAEACodeType"))
				{	soap_flag_IAEACode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CollisionalProcessClassType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CollisionalProcessClassType, 0, sizeof(ns2__CollisionalProcessClassType), 0, soap_copy_ns2__CollisionalProcessClassType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CollisionalProcessClassType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CollisionalProcessClassType);
	if (this->soap_out(soap, tag?tag:"ns2:CollisionalProcessClassType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CollisionalProcessClassType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CollisionalProcessClassType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CollisionalProcessClassType * SOAP_FMAC4 soap_get_ns2__CollisionalProcessClassType(struct soap *soap, ns2__CollisionalProcessClassType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CollisionalProcessClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CollisionalProcessClassType * SOAP_FMAC2 soap_instantiate_ns2__CollisionalProcessClassType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CollisionalProcessClassType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CollisionalProcessClassType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionalProcessClassType);
		if (size)
			*size = sizeof(ns2__CollisionalProcessClassType);
		((ns2__CollisionalProcessClassType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionalProcessClassType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CollisionalProcessClassType);
		for (int i = 0; i < n; i++)
			((ns2__CollisionalProcessClassType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CollisionalProcessClassType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CollisionalProcessClassType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CollisionalProcessClassType %p -> %p\n", q, p));
	*(ns2__CollisionalProcessClassType*)p = *(ns2__CollisionalProcessClassType*)q;
}

void ns2__CollisionalTransitionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CollisionalTransitionType::ProcessClass = NULL;
	this->ns2__CollisionalTransitionType::Reactants = NULL;
	this->ns2__CollisionalTransitionType::IntermediateStates = NULL;
	this->ns2__CollisionalTransitionType::Products = NULL;
	this->ns2__CollisionalTransitionType::Threshold = NULL;
	this->ns2__CollisionalTransitionType::DataSets = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__CollisionalTransitionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CollisionalProcessClassType(soap, &this->ns2__CollisionalTransitionType::ProcessClass);
	soap_serialize_PointerTons2__ReactantsType(soap, &this->ns2__CollisionalTransitionType::Reactants);
	soap_serialize_PointerTons2__ProductsType(soap, &this->ns2__CollisionalTransitionType::IntermediateStates);
	soap_serialize_PointerTons2__ProductsType(soap, &this->ns2__CollisionalTransitionType::Products);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__CollisionalTransitionType::Threshold);
	soap_serialize_PointerTons2__DataSetsType(soap, &this->ns2__CollisionalTransitionType::DataSets);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__CollisionalTransitionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CollisionalTransitionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CollisionalTransitionType(struct soap *soap, const char *tag, int id, const ns2__CollisionalTransitionType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CollisionalTransitionType), "ns2:CollisionalTransitionType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__CollisionalTransitionType::ProcessClass)
	{	if (soap_out_PointerTons2__CollisionalProcessClassType(soap, "ns2:ProcessClass", -1, &a->ns2__CollisionalTransitionType::ProcessClass, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ProcessClass"))
		return soap->error;
	if (a->ns2__CollisionalTransitionType::Reactants)
	{	if (soap_out_PointerTons2__ReactantsType(soap, "ns2:Reactants", -1, &a->ns2__CollisionalTransitionType::Reactants, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Reactants"))
		return soap->error;
	if (soap_out_PointerTons2__ProductsType(soap, "ns2:IntermediateStates", -1, &(a->ns2__CollisionalTransitionType::IntermediateStates), ""))
		return soap->error;
	if (soap_out_PointerTons2__ProductsType(soap, "ns2:Products", -1, &(a->ns2__CollisionalTransitionType::Products), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:Threshold", -1, &(a->ns2__CollisionalTransitionType::Threshold), ""))
		return soap->error;
	if (a->ns2__CollisionalTransitionType::DataSets)
	{	if (soap_out_PointerTons2__DataSetsType(soap, "ns2:DataSets", -1, &a->ns2__CollisionalTransitionType::DataSets, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:DataSets"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CollisionalTransitionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CollisionalTransitionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CollisionalTransitionType * SOAP_FMAC4 soap_in_ns2__CollisionalTransitionType(struct soap *soap, const char *tag, ns2__CollisionalTransitionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CollisionalTransitionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CollisionalTransitionType, sizeof(ns2__CollisionalTransitionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CollisionalTransitionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CollisionalTransitionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_ProcessClass1 = 1;
	size_t soap_flag_Reactants1 = 1;
	size_t soap_flag_IntermediateStates1 = 1;
	size_t soap_flag_Products1 = 1;
	size_t soap_flag_Threshold1 = 1;
	size_t soap_flag_DataSets1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_ProcessClass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CollisionalProcessClassType(soap, "ns2:ProcessClass", &(a->ns2__CollisionalTransitionType::ProcessClass), "ns2:CollisionalProcessClassType"))
				{	soap_flag_ProcessClass1--;
					continue;
				}
			if (soap_flag_Reactants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReactantsType(soap, "ns2:Reactants", &(a->ns2__CollisionalTransitionType::Reactants), "ns2:ReactantsType"))
				{	soap_flag_Reactants1--;
					continue;
				}
			if (soap_flag_IntermediateStates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ProductsType(soap, "ns2:IntermediateStates", &(a->ns2__CollisionalTransitionType::IntermediateStates), "ns2:ProductsType"))
				{	soap_flag_IntermediateStates1--;
					continue;
				}
			if (soap_flag_Products1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ProductsType(soap, "ns2:Products", &(a->ns2__CollisionalTransitionType::Products), "ns2:ProductsType"))
				{	soap_flag_Products1--;
					continue;
				}
			if (soap_flag_Threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Threshold", &(a->ns2__CollisionalTransitionType::Threshold), "ns2:DataType"))
				{	soap_flag_Threshold1--;
					continue;
				}
			if (soap_flag_DataSets1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataSetsType(soap, "ns2:DataSets", &(a->ns2__CollisionalTransitionType::DataSets), "ns2:DataSetsType"))
				{	soap_flag_DataSets1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CollisionalTransitionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CollisionalTransitionType, 0, sizeof(ns2__CollisionalTransitionType), 0, soap_copy_ns2__CollisionalTransitionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessClass1 > 0 || soap_flag_Reactants1 > 0 || soap_flag_DataSets1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CollisionalTransitionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CollisionalTransitionType);
	if (this->soap_out(soap, tag?tag:"ns2:CollisionalTransitionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CollisionalTransitionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CollisionalTransitionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CollisionalTransitionType * SOAP_FMAC4 soap_get_ns2__CollisionalTransitionType(struct soap *soap, ns2__CollisionalTransitionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CollisionalTransitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CollisionalTransitionType * SOAP_FMAC2 soap_instantiate_ns2__CollisionalTransitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CollisionalTransitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CollisionalTransitionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionalTransitionType);
		if (size)
			*size = sizeof(ns2__CollisionalTransitionType);
		((ns2__CollisionalTransitionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionalTransitionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CollisionalTransitionType);
		for (int i = 0; i < n; i++)
			((ns2__CollisionalTransitionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CollisionalTransitionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CollisionalTransitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CollisionalTransitionType %p -> %p\n", q, p));
	*(ns2__CollisionalTransitionType*)p = *(ns2__CollisionalTransitionType*)q;
}

void ns2__CollisionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(soap, &this->ns2__CollisionsType::CollisionalTransition);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__CollisionsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(soap, &this->ns2__CollisionsType::CollisionalTransition);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__CollisionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CollisionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CollisionsType(struct soap *soap, const char *tag, int id, const ns2__CollisionsType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CollisionsType), "ns2:CollisionsType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(soap, "ns2:CollisionalTransition", -1, &(a->ns2__CollisionsType::CollisionalTransition), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CollisionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CollisionsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CollisionsType * SOAP_FMAC4 soap_in_ns2__CollisionsType(struct soap *soap, const char *tag, ns2__CollisionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CollisionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CollisionsType, sizeof(ns2__CollisionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CollisionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CollisionsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(soap, "ns2:CollisionalTransition", &(a->ns2__CollisionsType::CollisionalTransition), "ns2:CollisionalTransitionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CollisionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CollisionsType, 0, sizeof(ns2__CollisionsType), 0, soap_copy_ns2__CollisionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__CollisionsType::CollisionalTransition.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CollisionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CollisionsType);
	if (this->soap_out(soap, tag?tag:"ns2:CollisionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CollisionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CollisionsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CollisionsType * SOAP_FMAC4 soap_get_ns2__CollisionsType(struct soap *soap, ns2__CollisionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CollisionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CollisionsType * SOAP_FMAC2 soap_instantiate_ns2__CollisionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CollisionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CollisionsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionsType);
		if (size)
			*size = sizeof(ns2__CollisionsType);
		((ns2__CollisionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CollisionsType);
		for (int i = 0; i < n; i++)
			((ns2__CollisionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CollisionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CollisionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CollisionsType %p -> %p\n", q, p));
	*(ns2__CollisionsType*)p = *(ns2__CollisionsType*)q;
}

void ns2__NonRadiativeTransitionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__StateRef(soap, &this->ns2__NonRadiativeTransitionType::InitialStateRef);
	this->ns2__NonRadiativeTransitionType::FinalStateRef = NULL;
	this->ns2__NonRadiativeTransitionType::Probability = NULL;
	this->ns2__NonRadiativeTransitionType::NonRadiativeWidth = NULL;
	this->ns2__NonRadiativeTransitionType::TransitionEnergy = NULL;
	this->ns2__NonRadiativeTransitionType::Type = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__NonRadiativeTransitionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__NonRadiativeTransitionType::InitialStateRef, SOAP_TYPE_ns2__StateRef);
	soap_serialize_ns2__StateRef(soap, &this->ns2__NonRadiativeTransitionType::InitialStateRef);
	soap_serialize_PointerTons2__StateRef(soap, &this->ns2__NonRadiativeTransitionType::FinalStateRef);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__NonRadiativeTransitionType::Probability);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__NonRadiativeTransitionType::NonRadiativeWidth);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__NonRadiativeTransitionType::TransitionEnergy);
	soap_serialize_PointerTostd__string(soap, &this->ns2__NonRadiativeTransitionType::Type);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__NonRadiativeTransitionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonRadiativeTransitionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonRadiativeTransitionType(struct soap *soap, const char *tag, int id, const ns2__NonRadiativeTransitionType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonRadiativeTransitionType), "ns2:NonRadiativeTransitionType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_ns2__StateRef(soap, "ns2:InitialStateRef", -1, &(a->ns2__NonRadiativeTransitionType::InitialStateRef), ""))
		return soap->error;
	if (soap_out_PointerTons2__StateRef(soap, "ns2:FinalStateRef", -1, &(a->ns2__NonRadiativeTransitionType::FinalStateRef), ""))
		return soap->error;
	if (a->ns2__NonRadiativeTransitionType::Probability)
	{	if (soap_out_PointerTons2__DataType(soap, "ns2:Probability", -1, &a->ns2__NonRadiativeTransitionType::Probability, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Probability"))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:NonRadiativeWidth", -1, &(a->ns2__NonRadiativeTransitionType::NonRadiativeWidth), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:TransitionEnergy", -1, &(a->ns2__NonRadiativeTransitionType::TransitionEnergy), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Type", -1, &(a->ns2__NonRadiativeTransitionType::Type), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NonRadiativeTransitionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonRadiativeTransitionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonRadiativeTransitionType * SOAP_FMAC4 soap_in_ns2__NonRadiativeTransitionType(struct soap *soap, const char *tag, ns2__NonRadiativeTransitionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonRadiativeTransitionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonRadiativeTransitionType, sizeof(ns2__NonRadiativeTransitionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonRadiativeTransitionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonRadiativeTransitionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_InitialStateRef1 = 1;
	size_t soap_flag_FinalStateRef1 = 1;
	size_t soap_flag_Probability1 = 1;
	size_t soap_flag_NonRadiativeWidth1 = 1;
	size_t soap_flag_TransitionEnergy1 = 1;
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_InitialStateRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__StateRef(soap, "ns2:InitialStateRef", &(a->ns2__NonRadiativeTransitionType::InitialStateRef), "ns2:StateRef"))
				{	soap_flag_InitialStateRef1--;
					continue;
				}
			if (soap_flag_FinalStateRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__StateRef(soap, "ns2:FinalStateRef", &(a->ns2__NonRadiativeTransitionType::FinalStateRef), "ns2:StateRef"))
				{	soap_flag_FinalStateRef1--;
					continue;
				}
			if (soap_flag_Probability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Probability", &(a->ns2__NonRadiativeTransitionType::Probability), "ns2:DataType"))
				{	soap_flag_Probability1--;
					continue;
				}
			if (soap_flag_NonRadiativeWidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:NonRadiativeWidth", &(a->ns2__NonRadiativeTransitionType::NonRadiativeWidth), "ns2:DataType"))
				{	soap_flag_NonRadiativeWidth1--;
					continue;
				}
			if (soap_flag_TransitionEnergy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:TransitionEnergy", &(a->ns2__NonRadiativeTransitionType::TransitionEnergy), "ns2:DataType"))
				{	soap_flag_TransitionEnergy1--;
					continue;
				}
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Type", &(a->ns2__NonRadiativeTransitionType::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonRadiativeTransitionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonRadiativeTransitionType, 0, sizeof(ns2__NonRadiativeTransitionType), 0, soap_copy_ns2__NonRadiativeTransitionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InitialStateRef1 > 0 || soap_flag_Probability1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonRadiativeTransitionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonRadiativeTransitionType);
	if (this->soap_out(soap, tag?tag:"ns2:NonRadiativeTransitionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonRadiativeTransitionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonRadiativeTransitionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonRadiativeTransitionType * SOAP_FMAC4 soap_get_ns2__NonRadiativeTransitionType(struct soap *soap, ns2__NonRadiativeTransitionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonRadiativeTransitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonRadiativeTransitionType * SOAP_FMAC2 soap_instantiate_ns2__NonRadiativeTransitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonRadiativeTransitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonRadiativeTransitionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeTransitionType);
		if (size)
			*size = sizeof(ns2__NonRadiativeTransitionType);
		((ns2__NonRadiativeTransitionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeTransitionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonRadiativeTransitionType);
		for (int i = 0; i < n; i++)
			((ns2__NonRadiativeTransitionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonRadiativeTransitionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonRadiativeTransitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonRadiativeTransitionType %p -> %p\n", q, p));
	*(ns2__NonRadiativeTransitionType*)p = *(ns2__NonRadiativeTransitionType*)q;
}

void ns2__NonRadiativeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(soap, &this->ns2__NonRadiativeType::NonRadiativeTransition);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__NonRadiativeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(soap, &this->ns2__NonRadiativeType::NonRadiativeTransition);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__NonRadiativeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonRadiativeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonRadiativeType(struct soap *soap, const char *tag, int id, const ns2__NonRadiativeType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonRadiativeType), "ns2:NonRadiativeType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(soap, "ns2:NonRadiativeTransition", -1, &(a->ns2__NonRadiativeType::NonRadiativeTransition), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NonRadiativeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonRadiativeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonRadiativeType * SOAP_FMAC4 soap_in_ns2__NonRadiativeType(struct soap *soap, const char *tag, ns2__NonRadiativeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonRadiativeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonRadiativeType, sizeof(ns2__NonRadiativeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonRadiativeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonRadiativeType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(soap, "ns2:NonRadiativeTransition", &(a->ns2__NonRadiativeType::NonRadiativeTransition), "ns2:NonRadiativeTransitionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonRadiativeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonRadiativeType, 0, sizeof(ns2__NonRadiativeType), 0, soap_copy_ns2__NonRadiativeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__NonRadiativeType::NonRadiativeTransition.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonRadiativeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonRadiativeType);
	if (this->soap_out(soap, tag?tag:"ns2:NonRadiativeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonRadiativeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonRadiativeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonRadiativeType * SOAP_FMAC4 soap_get_ns2__NonRadiativeType(struct soap *soap, ns2__NonRadiativeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonRadiativeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonRadiativeType * SOAP_FMAC2 soap_instantiate_ns2__NonRadiativeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonRadiativeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonRadiativeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeType);
		if (size)
			*size = sizeof(ns2__NonRadiativeType);
		((ns2__NonRadiativeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonRadiativeType);
		for (int i = 0; i < n; i++)
			((ns2__NonRadiativeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonRadiativeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonRadiativeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonRadiativeType %p -> %p\n", q, p));
	*(ns2__NonRadiativeType*)p = *(ns2__NonRadiativeType*)q;
}

void ns2__EnergyWavelengthType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EnergyWavelengthType::Wavenumber = NULL;
	this->ns2__EnergyWavelengthType::Wavelength = NULL;
	this->ns2__EnergyWavelengthType::Energy = NULL;
	this->ns2__EnergyWavelengthType::Frequency = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__EnergyWavelengthType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__WavelengthWavenumberType(soap, &this->ns2__EnergyWavelengthType::Wavenumber);
	soap_serialize_PointerTons2__WavelengthWavenumberType(soap, &this->ns2__EnergyWavelengthType::Wavelength);
	soap_serialize_PointerTons2__WavelengthWavenumberType(soap, &this->ns2__EnergyWavelengthType::Energy);
	soap_serialize_PointerTons2__WavelengthWavenumberType(soap, &this->ns2__EnergyWavelengthType::Frequency);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__EnergyWavelengthType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EnergyWavelengthType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EnergyWavelengthType(struct soap *soap, const char *tag, int id, const ns2__EnergyWavelengthType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EnergyWavelengthType), "ns2:EnergyWavelengthType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__WavelengthWavenumberType(soap, "ns2:Wavenumber", -1, &(a->ns2__EnergyWavelengthType::Wavenumber), ""))
		return soap->error;
	if (soap_out_PointerTons2__WavelengthWavenumberType(soap, "ns2:Wavelength", -1, &(a->ns2__EnergyWavelengthType::Wavelength), ""))
		return soap->error;
	if (soap_out_PointerTons2__WavelengthWavenumberType(soap, "ns2:Energy", -1, &(a->ns2__EnergyWavelengthType::Energy), ""))
		return soap->error;
	if (soap_out_PointerTons2__WavelengthWavenumberType(soap, "ns2:Frequency", -1, &(a->ns2__EnergyWavelengthType::Frequency), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EnergyWavelengthType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EnergyWavelengthType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EnergyWavelengthType * SOAP_FMAC4 soap_in_ns2__EnergyWavelengthType(struct soap *soap, const char *tag, ns2__EnergyWavelengthType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EnergyWavelengthType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EnergyWavelengthType, sizeof(ns2__EnergyWavelengthType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EnergyWavelengthType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EnergyWavelengthType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Wavenumber1 = 1;
	size_t soap_flag_Wavelength1 = 1;
	size_t soap_flag_Energy1 = 1;
	size_t soap_flag_Frequency1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Wavenumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WavelengthWavenumberType(soap, "ns2:Wavenumber", &(a->ns2__EnergyWavelengthType::Wavenumber), "ns2:WavelengthWavenumberType"))
				{	soap_flag_Wavenumber1--;
					continue;
				}
			if (soap_flag_Wavelength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WavelengthWavenumberType(soap, "ns2:Wavelength", &(a->ns2__EnergyWavelengthType::Wavelength), "ns2:WavelengthWavenumberType"))
				{	soap_flag_Wavelength1--;
					continue;
				}
			if (soap_flag_Energy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WavelengthWavenumberType(soap, "ns2:Energy", &(a->ns2__EnergyWavelengthType::Energy), "ns2:WavelengthWavenumberType"))
				{	soap_flag_Energy1--;
					continue;
				}
			if (soap_flag_Frequency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WavelengthWavenumberType(soap, "ns2:Frequency", &(a->ns2__EnergyWavelengthType::Frequency), "ns2:WavelengthWavenumberType"))
				{	soap_flag_Frequency1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EnergyWavelengthType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EnergyWavelengthType, 0, sizeof(ns2__EnergyWavelengthType), 0, soap_copy_ns2__EnergyWavelengthType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__EnergyWavelengthType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EnergyWavelengthType);
	if (this->soap_out(soap, tag?tag:"ns2:EnergyWavelengthType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EnergyWavelengthType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EnergyWavelengthType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EnergyWavelengthType * SOAP_FMAC4 soap_get_ns2__EnergyWavelengthType(struct soap *soap, ns2__EnergyWavelengthType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EnergyWavelengthType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EnergyWavelengthType * SOAP_FMAC2 soap_instantiate_ns2__EnergyWavelengthType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EnergyWavelengthType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EnergyWavelengthType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EnergyWavelengthType);
		if (size)
			*size = sizeof(ns2__EnergyWavelengthType);
		((ns2__EnergyWavelengthType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__EnergyWavelengthType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__EnergyWavelengthType);
		for (int i = 0; i < n; i++)
			((ns2__EnergyWavelengthType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__EnergyWavelengthType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EnergyWavelengthType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EnergyWavelengthType %p -> %p\n", q, p));
	*(ns2__EnergyWavelengthType*)p = *(ns2__EnergyWavelengthType*)q;
}

void ns2__WavelengthWavenumberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__WavelengthWavenumberType::Ritz = NULL;
	this->ns2__WavelengthWavenumberType::Experimental = NULL;
	this->ns2__WavelengthWavenumberType::Theoretical = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__WavelengthWavenumberType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__WavelengthWavenumberType::Ritz);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__WavelengthWavenumberType::Experimental);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__WavelengthWavenumberType::Theoretical);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__WavelengthWavenumberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__WavelengthWavenumberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WavelengthWavenumberType(struct soap *soap, const char *tag, int id, const ns2__WavelengthWavenumberType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WavelengthWavenumberType), "ns2:WavelengthWavenumberType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__DataType(soap, "ns2:Ritz", -1, &(a->ns2__WavelengthWavenumberType::Ritz), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:Experimental", -1, &(a->ns2__WavelengthWavenumberType::Experimental), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:Theoretical", -1, &(a->ns2__WavelengthWavenumberType::Theoretical), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__WavelengthWavenumberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__WavelengthWavenumberType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__WavelengthWavenumberType * SOAP_FMAC4 soap_in_ns2__WavelengthWavenumberType(struct soap *soap, const char *tag, ns2__WavelengthWavenumberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__WavelengthWavenumberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WavelengthWavenumberType, sizeof(ns2__WavelengthWavenumberType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__WavelengthWavenumberType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__WavelengthWavenumberType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Ritz1 = 1;
	size_t soap_flag_Experimental1 = 1;
	size_t soap_flag_Theoretical1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Ritz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Ritz", &(a->ns2__WavelengthWavenumberType::Ritz), "ns2:DataType"))
				{	soap_flag_Ritz1--;
					continue;
				}
			if (soap_flag_Experimental1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Experimental", &(a->ns2__WavelengthWavenumberType::Experimental), "ns2:DataType"))
				{	soap_flag_Experimental1--;
					continue;
				}
			if (soap_flag_Theoretical1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Theoretical", &(a->ns2__WavelengthWavenumberType::Theoretical), "ns2:DataType"))
				{	soap_flag_Theoretical1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__WavelengthWavenumberType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WavelengthWavenumberType, 0, sizeof(ns2__WavelengthWavenumberType), 0, soap_copy_ns2__WavelengthWavenumberType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__WavelengthWavenumberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__WavelengthWavenumberType);
	if (this->soap_out(soap, tag?tag:"ns2:WavelengthWavenumberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__WavelengthWavenumberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__WavelengthWavenumberType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__WavelengthWavenumberType * SOAP_FMAC4 soap_get_ns2__WavelengthWavenumberType(struct soap *soap, ns2__WavelengthWavenumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WavelengthWavenumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__WavelengthWavenumberType * SOAP_FMAC2 soap_instantiate_ns2__WavelengthWavenumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__WavelengthWavenumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__WavelengthWavenumberType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__WavelengthWavenumberType);
		if (size)
			*size = sizeof(ns2__WavelengthWavenumberType);
		((ns2__WavelengthWavenumberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__WavelengthWavenumberType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__WavelengthWavenumberType);
		for (int i = 0; i < n; i++)
			((ns2__WavelengthWavenumberType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__WavelengthWavenumberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__WavelengthWavenumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__WavelengthWavenumberType %p -> %p\n", q, p));
	*(ns2__WavelengthWavenumberType*)p = *(ns2__WavelengthWavenumberType*)q;
}

void ns2__RadiativeTransitionProbabilityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RadiativeTransitionProbabilityType::TransitionProbabilityA = NULL;
	this->ns2__RadiativeTransitionProbabilityType::OscillatorStrength = NULL;
	this->ns2__RadiativeTransitionProbabilityType::LineStrength = NULL;
	this->ns2__RadiativeTransitionProbabilityType::WeightedOscillatorStrength = NULL;
	this->ns2__RadiativeTransitionProbabilityType::Log10WeightedOscillatorStrength = NULL;
	this->ns2__RadiativeTransitionProbabilityType::IdealisedIntensity = NULL;
	this->ns2__RadiativeTransitionProbabilityType::Multipole = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__RadiativeTransitionProbabilityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__RadiativeTransitionProbabilityType::TransitionProbabilityA);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__RadiativeTransitionProbabilityType::OscillatorStrength);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__RadiativeTransitionProbabilityType::LineStrength);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__RadiativeTransitionProbabilityType::WeightedOscillatorStrength);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__RadiativeTransitionProbabilityType::Log10WeightedOscillatorStrength);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__RadiativeTransitionProbabilityType::IdealisedIntensity);
	soap_serialize_PointerTons2__MultipoleType(soap, &this->ns2__RadiativeTransitionProbabilityType::Multipole);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__RadiativeTransitionProbabilityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RadiativeTransitionProbabilityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RadiativeTransitionProbabilityType(struct soap *soap, const char *tag, int id, const ns2__RadiativeTransitionProbabilityType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType), "ns2:RadiativeTransitionProbabilityType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__DataType(soap, "ns2:TransitionProbabilityA", -1, &(a->ns2__RadiativeTransitionProbabilityType::TransitionProbabilityA), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:OscillatorStrength", -1, &(a->ns2__RadiativeTransitionProbabilityType::OscillatorStrength), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:LineStrength", -1, &(a->ns2__RadiativeTransitionProbabilityType::LineStrength), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:WeightedOscillatorStrength", -1, &(a->ns2__RadiativeTransitionProbabilityType::WeightedOscillatorStrength), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:Log10WeightedOscillatorStrength", -1, &(a->ns2__RadiativeTransitionProbabilityType::Log10WeightedOscillatorStrength), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:IdealisedIntensity", -1, &(a->ns2__RadiativeTransitionProbabilityType::IdealisedIntensity), ""))
		return soap->error;
	if (soap_out_PointerTons2__MultipoleType(soap, "ns2:Multipole", -1, &(a->ns2__RadiativeTransitionProbabilityType::Multipole), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RadiativeTransitionProbabilityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RadiativeTransitionProbabilityType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RadiativeTransitionProbabilityType * SOAP_FMAC4 soap_in_ns2__RadiativeTransitionProbabilityType(struct soap *soap, const char *tag, ns2__RadiativeTransitionProbabilityType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RadiativeTransitionProbabilityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType, sizeof(ns2__RadiativeTransitionProbabilityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RadiativeTransitionProbabilityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RadiativeTransitionProbabilityType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_TransitionProbabilityA1 = 1;
	size_t soap_flag_OscillatorStrength1 = 1;
	size_t soap_flag_LineStrength1 = 1;
	size_t soap_flag_WeightedOscillatorStrength1 = 1;
	size_t soap_flag_Log10WeightedOscillatorStrength1 = 1;
	size_t soap_flag_IdealisedIntensity1 = 1;
	size_t soap_flag_Multipole1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_TransitionProbabilityA1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:TransitionProbabilityA", &(a->ns2__RadiativeTransitionProbabilityType::TransitionProbabilityA), "ns2:DataType"))
				{	soap_flag_TransitionProbabilityA1--;
					continue;
				}
			if (soap_flag_OscillatorStrength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:OscillatorStrength", &(a->ns2__RadiativeTransitionProbabilityType::OscillatorStrength), "ns2:DataType"))
				{	soap_flag_OscillatorStrength1--;
					continue;
				}
			if (soap_flag_LineStrength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:LineStrength", &(a->ns2__RadiativeTransitionProbabilityType::LineStrength), "ns2:DataType"))
				{	soap_flag_LineStrength1--;
					continue;
				}
			if (soap_flag_WeightedOscillatorStrength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:WeightedOscillatorStrength", &(a->ns2__RadiativeTransitionProbabilityType::WeightedOscillatorStrength), "ns2:DataType"))
				{	soap_flag_WeightedOscillatorStrength1--;
					continue;
				}
			if (soap_flag_Log10WeightedOscillatorStrength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Log10WeightedOscillatorStrength", &(a->ns2__RadiativeTransitionProbabilityType::Log10WeightedOscillatorStrength), "ns2:DataType"))
				{	soap_flag_Log10WeightedOscillatorStrength1--;
					continue;
				}
			if (soap_flag_IdealisedIntensity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:IdealisedIntensity", &(a->ns2__RadiativeTransitionProbabilityType::IdealisedIntensity), "ns2:DataType"))
				{	soap_flag_IdealisedIntensity1--;
					continue;
				}
			if (soap_flag_Multipole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__MultipoleType(soap, "ns2:Multipole", &(a->ns2__RadiativeTransitionProbabilityType::Multipole), "ns2:MultipoleType"))
				{	soap_flag_Multipole1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RadiativeTransitionProbabilityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType, 0, sizeof(ns2__RadiativeTransitionProbabilityType), 0, soap_copy_ns2__RadiativeTransitionProbabilityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__RadiativeTransitionProbabilityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType);
	if (this->soap_out(soap, tag?tag:"ns2:RadiativeTransitionProbabilityType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RadiativeTransitionProbabilityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RadiativeTransitionProbabilityType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RadiativeTransitionProbabilityType * SOAP_FMAC4 soap_get_ns2__RadiativeTransitionProbabilityType(struct soap *soap, ns2__RadiativeTransitionProbabilityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RadiativeTransitionProbabilityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RadiativeTransitionProbabilityType * SOAP_FMAC2 soap_instantiate_ns2__RadiativeTransitionProbabilityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RadiativeTransitionProbabilityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionProbabilityType);
		if (size)
			*size = sizeof(ns2__RadiativeTransitionProbabilityType);
		((ns2__RadiativeTransitionProbabilityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionProbabilityType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RadiativeTransitionProbabilityType);
		for (int i = 0; i < n; i++)
			((ns2__RadiativeTransitionProbabilityType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RadiativeTransitionProbabilityType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RadiativeTransitionProbabilityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RadiativeTransitionProbabilityType %p -> %p\n", q, p));
	*(ns2__RadiativeTransitionProbabilityType*)p = *(ns2__RadiativeTransitionProbabilityType*)q;
}

void ns2__RadiativeTransitionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RadiativeTransitionType::EnergyWavelength = NULL;
	this->ns2__RadiativeTransitionType::InitialStateRef = NULL;
	this->ns2__RadiativeTransitionType::FinalStateRef = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(soap, &this->ns2__RadiativeTransitionType::Probability);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__RadiativeTransitionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EnergyWavelengthType(soap, &this->ns2__RadiativeTransitionType::EnergyWavelength);
	soap_serialize_PointerTons2__StateRef(soap, &this->ns2__RadiativeTransitionType::InitialStateRef);
	soap_serialize_PointerTons2__StateRef(soap, &this->ns2__RadiativeTransitionType::FinalStateRef);
	soap_serialize_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(soap, &this->ns2__RadiativeTransitionType::Probability);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__RadiativeTransitionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RadiativeTransitionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RadiativeTransitionType(struct soap *soap, const char *tag, int id, const ns2__RadiativeTransitionType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RadiativeTransitionType), "ns2:RadiativeTransitionType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__RadiativeTransitionType::EnergyWavelength)
	{	if (soap_out_PointerTons2__EnergyWavelengthType(soap, "ns2:EnergyWavelength", -1, &a->ns2__RadiativeTransitionType::EnergyWavelength, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:EnergyWavelength"))
		return soap->error;
	if (soap_out_PointerTons2__StateRef(soap, "ns2:InitialStateRef", -1, &(a->ns2__RadiativeTransitionType::InitialStateRef), ""))
		return soap->error;
	if (soap_out_PointerTons2__StateRef(soap, "ns2:FinalStateRef", -1, &(a->ns2__RadiativeTransitionType::FinalStateRef), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(soap, "ns2:Probability", -1, &(a->ns2__RadiativeTransitionType::Probability), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RadiativeTransitionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RadiativeTransitionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RadiativeTransitionType * SOAP_FMAC4 soap_in_ns2__RadiativeTransitionType(struct soap *soap, const char *tag, ns2__RadiativeTransitionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RadiativeTransitionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RadiativeTransitionType, sizeof(ns2__RadiativeTransitionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RadiativeTransitionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RadiativeTransitionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_EnergyWavelength1 = 1;
	size_t soap_flag_InitialStateRef1 = 1;
	size_t soap_flag_FinalStateRef1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_EnergyWavelength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EnergyWavelengthType(soap, "ns2:EnergyWavelength", &(a->ns2__RadiativeTransitionType::EnergyWavelength), "ns2:EnergyWavelengthType"))
				{	soap_flag_EnergyWavelength1--;
					continue;
				}
			if (soap_flag_InitialStateRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__StateRef(soap, "ns2:InitialStateRef", &(a->ns2__RadiativeTransitionType::InitialStateRef), "ns2:StateRef"))
				{	soap_flag_InitialStateRef1--;
					continue;
				}
			if (soap_flag_FinalStateRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__StateRef(soap, "ns2:FinalStateRef", &(a->ns2__RadiativeTransitionType::FinalStateRef), "ns2:StateRef"))
				{	soap_flag_FinalStateRef1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(soap, "ns2:Probability", &(a->ns2__RadiativeTransitionType::Probability), "ns2:RadiativeTransitionProbabilityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RadiativeTransitionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RadiativeTransitionType, 0, sizeof(ns2__RadiativeTransitionType), 0, soap_copy_ns2__RadiativeTransitionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EnergyWavelength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RadiativeTransitionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RadiativeTransitionType);
	if (this->soap_out(soap, tag?tag:"ns2:RadiativeTransitionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RadiativeTransitionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RadiativeTransitionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RadiativeTransitionType * SOAP_FMAC4 soap_get_ns2__RadiativeTransitionType(struct soap *soap, ns2__RadiativeTransitionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RadiativeTransitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RadiativeTransitionType * SOAP_FMAC2 soap_instantiate_ns2__RadiativeTransitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RadiativeTransitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RadiativeTransitionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionType);
		if (size)
			*size = sizeof(ns2__RadiativeTransitionType);
		((ns2__RadiativeTransitionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RadiativeTransitionType);
		for (int i = 0; i < n; i++)
			((ns2__RadiativeTransitionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RadiativeTransitionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RadiativeTransitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RadiativeTransitionType %p -> %p\n", q, p));
	*(ns2__RadiativeTransitionType*)p = *(ns2__RadiativeTransitionType*)q;
}

void ns2__RadiativeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(soap, &this->ns2__RadiativeType::RadiativeTransition);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__RadiativeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(soap, &this->ns2__RadiativeType::RadiativeTransition);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__RadiativeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RadiativeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RadiativeType(struct soap *soap, const char *tag, int id, const ns2__RadiativeType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RadiativeType), "ns2:RadiativeType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(soap, "ns2:RadiativeTransition", -1, &(a->ns2__RadiativeType::RadiativeTransition), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RadiativeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RadiativeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RadiativeType * SOAP_FMAC4 soap_in_ns2__RadiativeType(struct soap *soap, const char *tag, ns2__RadiativeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RadiativeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RadiativeType, sizeof(ns2__RadiativeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RadiativeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RadiativeType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(soap, "ns2:RadiativeTransition", &(a->ns2__RadiativeType::RadiativeTransition), "ns2:RadiativeTransitionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RadiativeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RadiativeType, 0, sizeof(ns2__RadiativeType), 0, soap_copy_ns2__RadiativeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__RadiativeType::RadiativeTransition.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RadiativeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RadiativeType);
	if (this->soap_out(soap, tag?tag:"ns2:RadiativeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RadiativeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RadiativeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RadiativeType * SOAP_FMAC4 soap_get_ns2__RadiativeType(struct soap *soap, ns2__RadiativeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RadiativeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RadiativeType * SOAP_FMAC2 soap_instantiate_ns2__RadiativeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RadiativeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RadiativeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeType);
		if (size)
			*size = sizeof(ns2__RadiativeType);
		((ns2__RadiativeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RadiativeType);
		for (int i = 0; i < n; i++)
			((ns2__RadiativeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RadiativeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RadiativeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RadiativeType %p -> %p\n", q, p));
	*(ns2__RadiativeType*)p = *(ns2__RadiativeType*)q;
}

void ns2__MaterialCompositionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__MaterialComponentType(soap, &this->ns2__MaterialCompositionType::Component);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__MaterialCompositionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__MaterialComponentType(soap, &this->ns2__MaterialCompositionType::Component);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__MaterialCompositionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MaterialCompositionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MaterialCompositionType(struct soap *soap, const char *tag, int id, const ns2__MaterialCompositionType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MaterialCompositionType), "ns2:MaterialCompositionType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__MaterialComponentType(soap, "ns2:Component", -1, &(a->ns2__MaterialCompositionType::Component), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MaterialCompositionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MaterialCompositionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MaterialCompositionType * SOAP_FMAC4 soap_in_ns2__MaterialCompositionType(struct soap *soap, const char *tag, ns2__MaterialCompositionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MaterialCompositionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MaterialCompositionType, sizeof(ns2__MaterialCompositionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MaterialCompositionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MaterialCompositionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MaterialComponentType(soap, "ns2:Component", &(a->ns2__MaterialCompositionType::Component), "ns2:MaterialComponentType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MaterialCompositionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MaterialCompositionType, 0, sizeof(ns2__MaterialCompositionType), 0, soap_copy_ns2__MaterialCompositionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__MaterialCompositionType::Component.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MaterialCompositionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MaterialCompositionType);
	if (this->soap_out(soap, tag?tag:"ns2:MaterialCompositionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MaterialCompositionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MaterialCompositionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MaterialCompositionType * SOAP_FMAC4 soap_get_ns2__MaterialCompositionType(struct soap *soap, ns2__MaterialCompositionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MaterialCompositionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MaterialCompositionType * SOAP_FMAC2 soap_instantiate_ns2__MaterialCompositionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MaterialCompositionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MaterialCompositionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialCompositionType);
		if (size)
			*size = sizeof(ns2__MaterialCompositionType);
		((ns2__MaterialCompositionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialCompositionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MaterialCompositionType);
		for (int i = 0; i < n; i++)
			((ns2__MaterialCompositionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MaterialCompositionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MaterialCompositionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MaterialCompositionType %p -> %p\n", q, p));
	*(ns2__MaterialCompositionType*)p = *(ns2__MaterialCompositionType*)q;
}

void ns2__MaterialType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__MaterialType::MaterialName);
	this->ns2__MaterialType::MaterialComposition = NULL;
	this->ns2__MaterialType::MaterialThickness = NULL;
	this->ns2__MaterialType::MaterialTopology = NULL;
	this->ns2__MaterialType::MaterialTemperature = NULL;
	this->ns2__MaterialType::Comments = NULL;
	/* transient soap skipped */
}

void ns2__MaterialType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MaterialType::MaterialName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MaterialType::MaterialName);
	soap_serialize_PointerTons2__MaterialCompositionType(soap, &this->ns2__MaterialType::MaterialComposition);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__MaterialType::MaterialThickness);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MaterialType::MaterialTopology);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__MaterialType::MaterialTemperature);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MaterialType::Comments);
	/* transient soap skipped */
}

int ns2__MaterialType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MaterialType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MaterialType(struct soap *soap, const char *tag, int id, const ns2__MaterialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MaterialType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:MaterialName", -1, &(a->ns2__MaterialType::MaterialName), ""))
		return soap->error;
	if (a->ns2__MaterialType::MaterialComposition)
	{	if (soap_out_PointerTons2__MaterialCompositionType(soap, "ns2:MaterialComposition", -1, &a->ns2__MaterialType::MaterialComposition, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MaterialComposition"))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:MaterialThickness", -1, &(a->ns2__MaterialType::MaterialThickness), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:MaterialTopology", -1, &(a->ns2__MaterialType::MaterialTopology), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:MaterialTemperature", -1, &(a->ns2__MaterialType::MaterialTemperature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__MaterialType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MaterialType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MaterialType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MaterialType * SOAP_FMAC4 soap_in_ns2__MaterialType(struct soap *soap, const char *tag, ns2__MaterialType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MaterialType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MaterialType, sizeof(ns2__MaterialType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MaterialType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MaterialType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MaterialName1 = 1;
	size_t soap_flag_MaterialComposition1 = 1;
	size_t soap_flag_MaterialThickness1 = 1;
	size_t soap_flag_MaterialTopology1 = 1;
	size_t soap_flag_MaterialTemperature1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaterialName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:MaterialName", &(a->ns2__MaterialType::MaterialName), "xsd:string"))
				{	soap_flag_MaterialName1--;
					continue;
				}
			if (soap_flag_MaterialComposition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MaterialCompositionType(soap, "ns2:MaterialComposition", &(a->ns2__MaterialType::MaterialComposition), "ns2:MaterialCompositionType"))
				{	soap_flag_MaterialComposition1--;
					continue;
				}
			if (soap_flag_MaterialThickness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:MaterialThickness", &(a->ns2__MaterialType::MaterialThickness), "ns2:DataType"))
				{	soap_flag_MaterialThickness1--;
					continue;
				}
			if (soap_flag_MaterialTopology1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:MaterialTopology", &(a->ns2__MaterialType::MaterialTopology), "xsd:string"))
				{	soap_flag_MaterialTopology1--;
					continue;
				}
			if (soap_flag_MaterialTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:MaterialTemperature", &(a->ns2__MaterialType::MaterialTemperature), "ns2:DataType"))
				{	soap_flag_MaterialTemperature1--;
					continue;
				}
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__MaterialType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MaterialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MaterialType, 0, sizeof(ns2__MaterialType), 0, soap_copy_ns2__MaterialType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaterialName1 > 0 || soap_flag_MaterialComposition1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MaterialType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MaterialType);
	if (this->soap_out(soap, tag?tag:"ns2:MaterialType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MaterialType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MaterialType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MaterialType * SOAP_FMAC4 soap_get_ns2__MaterialType(struct soap *soap, ns2__MaterialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MaterialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MaterialType * SOAP_FMAC2 soap_instantiate_ns2__MaterialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MaterialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MaterialType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialType);
		if (size)
			*size = sizeof(ns2__MaterialType);
		((ns2__MaterialType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MaterialType);
		for (int i = 0; i < n; i++)
			((ns2__MaterialType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MaterialType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MaterialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MaterialType %p -> %p\n", q, p));
	*(ns2__MaterialType*)p = *(ns2__MaterialType*)q;
}

void ns2__MaterialComponentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MaterialComponentType::ChemicalElement = NULL;
	this->ns2__MaterialComponentType::__union_MaterialComponentType = 0;
	/* transient soap skipped */
}

void ns2__MaterialComponentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ChemicalElementType(soap, &this->ns2__MaterialComponentType::ChemicalElement);
	soap_serialize__ns2__union_MaterialComponentType(soap, this->ns2__MaterialComponentType::__union_MaterialComponentType, &this->ns2__MaterialComponentType::union_MaterialComponentType);
	/* transient soap skipped */
}

int ns2__MaterialComponentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MaterialComponentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MaterialComponentType(struct soap *soap, const char *tag, int id, const ns2__MaterialComponentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MaterialComponentType), type))
		return soap->error;
	if (a->ns2__MaterialComponentType::ChemicalElement)
	{	if (soap_out_PointerTons2__ChemicalElementType(soap, "ns2:ChemicalElement", -1, &a->ns2__MaterialComponentType::ChemicalElement, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ChemicalElement"))
		return soap->error;
	if (soap_out__ns2__union_MaterialComponentType(soap, a->ns2__MaterialComponentType::__union_MaterialComponentType, &a->ns2__MaterialComponentType::union_MaterialComponentType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MaterialComponentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MaterialComponentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MaterialComponentType * SOAP_FMAC4 soap_in_ns2__MaterialComponentType(struct soap *soap, const char *tag, ns2__MaterialComponentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MaterialComponentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MaterialComponentType, sizeof(ns2__MaterialComponentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MaterialComponentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MaterialComponentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ChemicalElement1 = 1;
	size_t soap_flag_union_MaterialComponentType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChemicalElement1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ChemicalElementType(soap, "ns2:ChemicalElement", &(a->ns2__MaterialComponentType::ChemicalElement), "ns2:ChemicalElementType"))
				{	soap_flag_ChemicalElement1--;
					continue;
				}
			if (soap_flag_union_MaterialComponentType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_MaterialComponentType(soap, &a->ns2__MaterialComponentType::__union_MaterialComponentType, &a->ns2__MaterialComponentType::union_MaterialComponentType))
				{	soap_flag_union_MaterialComponentType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MaterialComponentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MaterialComponentType, 0, sizeof(ns2__MaterialComponentType), 0, soap_copy_ns2__MaterialComponentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChemicalElement1 > 0 || soap_flag_union_MaterialComponentType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MaterialComponentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MaterialComponentType);
	if (this->soap_out(soap, tag?tag:"ns2:MaterialComponentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MaterialComponentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MaterialComponentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MaterialComponentType * SOAP_FMAC4 soap_get_ns2__MaterialComponentType(struct soap *soap, ns2__MaterialComponentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MaterialComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MaterialComponentType * SOAP_FMAC2 soap_instantiate_ns2__MaterialComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MaterialComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MaterialComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialComponentType);
		if (size)
			*size = sizeof(ns2__MaterialComponentType);
		((ns2__MaterialComponentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialComponentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MaterialComponentType);
		for (int i = 0; i < n; i++)
			((ns2__MaterialComponentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MaterialComponentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MaterialComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MaterialComponentType %p -> %p\n", q, p));
	*(ns2__MaterialComponentType*)p = *(ns2__MaterialComponentType*)q;
}

void ns2__SolidsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__SolidType(soap, &this->ns2__SolidsType::Solid);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__SolidsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__SolidType(soap, &this->ns2__SolidsType::Solid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__SolidsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SolidsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SolidsType(struct soap *soap, const char *tag, int id, const ns2__SolidsType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SolidsType), "ns2:SolidsType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__SolidType(soap, "ns2:Solid", -1, &(a->ns2__SolidsType::Solid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SolidsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SolidsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SolidsType * SOAP_FMAC4 soap_in_ns2__SolidsType(struct soap *soap, const char *tag, ns2__SolidsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SolidsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SolidsType, sizeof(ns2__SolidsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SolidsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SolidsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__SolidType(soap, "ns2:Solid", &(a->ns2__SolidsType::Solid), "ns2:SolidType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SolidsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SolidsType, 0, sizeof(ns2__SolidsType), 0, soap_copy_ns2__SolidsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SolidsType::Solid.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SolidsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SolidsType);
	if (this->soap_out(soap, tag?tag:"ns2:SolidsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SolidsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SolidsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SolidsType * SOAP_FMAC4 soap_get_ns2__SolidsType(struct soap *soap, ns2__SolidsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SolidsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SolidsType * SOAP_FMAC2 soap_instantiate_ns2__SolidsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SolidsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SolidsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SolidsType);
		if (size)
			*size = sizeof(ns2__SolidsType);
		((ns2__SolidsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SolidsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SolidsType);
		for (int i = 0; i < n; i++)
			((ns2__SolidsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SolidsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SolidsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SolidsType %p -> %p\n", q, p));
	*(ns2__SolidsType*)p = *(ns2__SolidsType*)q;
}

void ns2__SolidType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__MaterialType(soap, &this->ns2__SolidType::Layer);
	soap_default__ns2__stateID(soap, &this->ns2__SolidType::ns2__stateID);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__SolidType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__MaterialType(soap, &this->ns2__SolidType::Layer);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__SolidType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SolidType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SolidType(struct soap *soap, const char *tag, int id, const ns2__SolidType *a, const char *type)
{
	soap_set_attr(soap, "ns2:stateID", ((ns2__SolidType*)a)->ns2__stateID.c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SolidType), "ns2:SolidType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__MaterialType(soap, "ns2:Layer", -1, &(a->ns2__SolidType::Layer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SolidType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SolidType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SolidType * SOAP_FMAC4 soap_in_ns2__SolidType(struct soap *soap, const char *tag, ns2__SolidType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SolidType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SolidType, sizeof(ns2__SolidType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SolidType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SolidType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:stateID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__SolidType*)a)->ns2__stateID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MaterialType(soap, "ns2:Layer", &(a->ns2__SolidType::Layer), "ns2:MaterialType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SolidType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SolidType, 0, sizeof(ns2__SolidType), 0, soap_copy_ns2__SolidType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SolidType::Layer.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SolidType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SolidType);
	if (this->soap_out(soap, tag?tag:"ns2:SolidType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SolidType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SolidType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SolidType * SOAP_FMAC4 soap_get_ns2__SolidType(struct soap *soap, ns2__SolidType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SolidType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SolidType * SOAP_FMAC2 soap_instantiate_ns2__SolidType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SolidType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SolidType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SolidType);
		if (size)
			*size = sizeof(ns2__SolidType);
		((ns2__SolidType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SolidType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SolidType);
		for (int i = 0; i < n; i++)
			((ns2__SolidType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SolidType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SolidType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SolidType %p -> %p\n", q, p));
	*(ns2__SolidType*)p = *(ns2__SolidType*)q;
}

void ns2__ParticlePropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ParticlePropertiesType::ParticleCharge = NULL;
	this->ns2__ParticlePropertiesType::ParticleMass = NULL;
	this->ns2__ParticlePropertiesType::ParticleSpin = NULL;
	this->ns2__ParticlePropertiesType::ParticlePolarization = NULL;
	/* transient soap skipped */
}

void ns2__ParticlePropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ParticlePropertiesType::ParticleCharge);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__ParticlePropertiesType::ParticleMass);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__ParticlePropertiesType::ParticleSpin);
	soap_serialize_PointerTons2__AngularMomentumProjectionType(soap, &this->ns2__ParticlePropertiesType::ParticlePolarization);
	/* transient soap skipped */
}

int ns2__ParticlePropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParticlePropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParticlePropertiesType(struct soap *soap, const char *tag, int id, const ns2__ParticlePropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParticlePropertiesType), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:ParticleCharge", -1, &(a->ns2__ParticlePropertiesType::ParticleCharge), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:ParticleMass", -1, &(a->ns2__ParticlePropertiesType::ParticleMass), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:ParticleSpin", -1, &(a->ns2__ParticlePropertiesType::ParticleSpin), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumProjectionType(soap, "ns2:ParticlePolarization", -1, &(a->ns2__ParticlePropertiesType::ParticlePolarization), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParticlePropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParticlePropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParticlePropertiesType * SOAP_FMAC4 soap_in_ns2__ParticlePropertiesType(struct soap *soap, const char *tag, ns2__ParticlePropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParticlePropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParticlePropertiesType, sizeof(ns2__ParticlePropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParticlePropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParticlePropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ParticleCharge1 = 1;
	size_t soap_flag_ParticleMass1 = 1;
	size_t soap_flag_ParticleSpin1 = 1;
	size_t soap_flag_ParticlePolarization1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParticleCharge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "ns2:ParticleCharge", &(a->ns2__ParticlePropertiesType::ParticleCharge), "xsd:integer"))
				{	soap_flag_ParticleCharge1--;
					continue;
				}
			if (soap_flag_ParticleMass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:ParticleMass", &(a->ns2__ParticlePropertiesType::ParticleMass), "ns2:DataType"))
				{	soap_flag_ParticleMass1--;
					continue;
				}
			if (soap_flag_ParticleSpin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:ParticleSpin", &(a->ns2__ParticlePropertiesType::ParticleSpin), "ns2:AngularMomentumType"))
				{	soap_flag_ParticleSpin1--;
					continue;
				}
			if (soap_flag_ParticlePolarization1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumProjectionType(soap, "ns2:ParticlePolarization", &(a->ns2__ParticlePropertiesType::ParticlePolarization), "ns2:AngularMomentumProjectionType"))
				{	soap_flag_ParticlePolarization1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParticlePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParticlePropertiesType, 0, sizeof(ns2__ParticlePropertiesType), 0, soap_copy_ns2__ParticlePropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParticlePropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParticlePropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:ParticlePropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParticlePropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParticlePropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParticlePropertiesType * SOAP_FMAC4 soap_get_ns2__ParticlePropertiesType(struct soap *soap, ns2__ParticlePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParticlePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParticlePropertiesType * SOAP_FMAC2 soap_instantiate_ns2__ParticlePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParticlePropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParticlePropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParticlePropertiesType);
		if (size)
			*size = sizeof(ns2__ParticlePropertiesType);
		((ns2__ParticlePropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParticlePropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ParticlePropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__ParticlePropertiesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ParticlePropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParticlePropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParticlePropertiesType %p -> %p\n", q, p));
	*(ns2__ParticlePropertiesType*)p = *(ns2__ParticlePropertiesType*)q;
}

void ns2__ParticleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ParticleType::ParticleProperties = NULL;
	this->ns2__ParticleType::Comments = NULL;
	soap_default__ns2__stateID(soap, &this->ns2__ParticleType::ns2__stateID);
	this->ns2__ParticleType::name = NULL;
	/* transient soap skipped */
}

void ns2__ParticleType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParticlePropertiesType(soap, &this->ns2__ParticleType::ParticleProperties);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ParticleType::Comments);
	/* transient soap skipped */
}

int ns2__ParticleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParticleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParticleType(struct soap *soap, const char *tag, int id, const ns2__ParticleType *a, const char *type)
{
	soap_set_attr(soap, "ns2:stateID", ((ns2__ParticleType*)a)->ns2__stateID.c_str(), 1);
	if (((ns2__ParticleType*)a)->name)
		soap_set_attr(soap, "name", soap_ns2__ParticleNameType2s(soap, *((ns2__ParticleType*)a)->name), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParticleType), type))
		return soap->error;
	if (soap_out_PointerTons2__ParticlePropertiesType(soap, "ns2:ParticleProperties", -1, &(a->ns2__ParticleType::ParticleProperties), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__ParticleType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParticleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParticleType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParticleType * SOAP_FMAC4 soap_in_ns2__ParticleType(struct soap *soap, const char *tag, ns2__ParticleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParticleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParticleType, sizeof(ns2__ParticleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParticleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParticleType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:stateID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__ParticleType*)a)->ns2__stateID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			if (!(((ns2__ParticleType*)a)->name = (enum ns2__ParticleNameType *)soap_malloc(soap, sizeof(enum ns2__ParticleNameType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ParticleNameType(soap, t, ((ns2__ParticleType*)a)->name))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_ParticleProperties1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParticleProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParticlePropertiesType(soap, "ns2:ParticleProperties", &(a->ns2__ParticleType::ParticleProperties), "ns2:ParticlePropertiesType"))
				{	soap_flag_ParticleProperties1--;
					continue;
				}
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__ParticleType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParticleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParticleType, 0, sizeof(ns2__ParticleType), 0, soap_copy_ns2__ParticleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParticleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParticleType);
	if (this->soap_out(soap, tag?tag:"ns2:ParticleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParticleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParticleType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParticleType * SOAP_FMAC4 soap_get_ns2__ParticleType(struct soap *soap, ns2__ParticleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParticleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParticleType * SOAP_FMAC2 soap_instantiate_ns2__ParticleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParticleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParticleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParticleType);
		if (size)
			*size = sizeof(ns2__ParticleType);
		((ns2__ParticleType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParticleType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ParticleType);
		for (int i = 0; i < n; i++)
			((ns2__ParticleType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ParticleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParticleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParticleType %p -> %p\n", q, p));
	*(ns2__ParticleType*)p = *(ns2__ParticleType*)q;
}

void ns2__ParticlesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ParticleType(soap, &this->ns2__ParticlesType::Particle);
	/* transient soap skipped */
}

void ns2__ParticlesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ParticleType(soap, &this->ns2__ParticlesType::Particle);
	/* transient soap skipped */
}

int ns2__ParticlesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParticlesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParticlesType(struct soap *soap, const char *tag, int id, const ns2__ParticlesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParticlesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ParticleType(soap, "ns2:Particle", -1, &(a->ns2__ParticlesType::Particle), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParticlesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParticlesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParticlesType * SOAP_FMAC4 soap_in_ns2__ParticlesType(struct soap *soap, const char *tag, ns2__ParticlesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParticlesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParticlesType, sizeof(ns2__ParticlesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParticlesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParticlesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ParticleType(soap, "ns2:Particle", &(a->ns2__ParticlesType::Particle), "ns2:ParticleType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParticlesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParticlesType, 0, sizeof(ns2__ParticlesType), 0, soap_copy_ns2__ParticlesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ParticlesType::Particle.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParticlesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParticlesType);
	if (this->soap_out(soap, tag?tag:"ns2:ParticlesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParticlesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParticlesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParticlesType * SOAP_FMAC4 soap_get_ns2__ParticlesType(struct soap *soap, ns2__ParticlesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParticlesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParticlesType * SOAP_FMAC2 soap_instantiate_ns2__ParticlesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParticlesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParticlesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParticlesType);
		if (size)
			*size = sizeof(ns2__ParticlesType);
		((ns2__ParticlesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParticlesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ParticlesType);
		for (int i = 0; i < n; i++)
			((ns2__ParticlesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ParticlesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParticlesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParticlesType %p -> %p\n", q, p));
	*(ns2__ParticlesType*)p = *(ns2__ParticlesType*)q;
}

void ns2__CharacterisationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CharacterisationType::Name = NULL;
	this->ns2__CharacterisationType::__union_CharacterisationType = 0;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__CharacterisationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__CharacterisationType::Name);
	soap_serialize__ns2__union_CharacterisationType(soap, this->ns2__CharacterisationType::__union_CharacterisationType, &this->ns2__CharacterisationType::union_CharacterisationType);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__CharacterisationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CharacterisationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CharacterisationType(struct soap *soap, const char *tag, int id, const ns2__CharacterisationType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CharacterisationType), "ns2:CharacterisationType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:Name", -1, &(a->ns2__CharacterisationType::Name), ""))
		return soap->error;
	if (soap_out__ns2__union_CharacterisationType(soap, a->ns2__CharacterisationType::__union_CharacterisationType, &a->ns2__CharacterisationType::union_CharacterisationType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CharacterisationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CharacterisationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CharacterisationType * SOAP_FMAC4 soap_in_ns2__CharacterisationType(struct soap *soap, const char *tag, ns2__CharacterisationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CharacterisationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CharacterisationType, sizeof(ns2__CharacterisationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CharacterisationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CharacterisationType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_union_CharacterisationType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Name", &(a->ns2__CharacterisationType::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_union_CharacterisationType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_CharacterisationType(soap, &a->ns2__CharacterisationType::__union_CharacterisationType, &a->ns2__CharacterisationType::union_CharacterisationType))
				{	soap_flag_union_CharacterisationType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CharacterisationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CharacterisationType, 0, sizeof(ns2__CharacterisationType), 0, soap_copy_ns2__CharacterisationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CharacterisationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CharacterisationType);
	if (this->soap_out(soap, tag?tag:"ns2:CharacterisationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CharacterisationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CharacterisationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CharacterisationType * SOAP_FMAC4 soap_get_ns2__CharacterisationType(struct soap *soap, ns2__CharacterisationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CharacterisationType * SOAP_FMAC2 soap_instantiate_ns2__CharacterisationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CharacterisationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CharacterisationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CharacterisationType);
		if (size)
			*size = sizeof(ns2__CharacterisationType);
		((ns2__CharacterisationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CharacterisationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CharacterisationType);
		for (int i = 0; i < n; i++)
			((ns2__CharacterisationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CharacterisationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CharacterisationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CharacterisationType %p -> %p\n", q, p));
	*(ns2__CharacterisationType*)p = *(ns2__CharacterisationType*)q;
}

void ns2__ReferencedTextType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__ReferencedTextType::__item);
	this->ns2__ReferencedTextType::ns2__sourceRef = NULL;
	/* transient soap skipped */
}

void ns2__ReferencedTextType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ReferencedTextType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ReferencedTextType::__item);
	/* transient soap skipped */
}

int ns2__ReferencedTextType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReferencedTextType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReferencedTextType(struct soap *soap, const char *tag, int id, const ns2__ReferencedTextType *a, const char *type)
{
	if (((ns2__ReferencedTextType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__ReferencedTextType*)a)->ns2__sourceRef->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->ns2__ReferencedTextType::__item, "");
}

void *ns2__ReferencedTextType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReferencedTextType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReferencedTextType * SOAP_FMAC4 soap_in_ns2__ReferencedTextType(struct soap *soap, const char *tag, ns2__ReferencedTextType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__ReferencedTextType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReferencedTextType, sizeof(ns2__ReferencedTextType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReferencedTextType)
			return (ns2__ReferencedTextType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ReferencedTextType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__ReferencedTextType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->ns2__ReferencedTextType::__item), "ns2:ReferencedTextType"))
		return NULL;
	return a;
}

int ns2__ReferencedTextType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReferencedTextType);
	if (this->soap_out(soap, tag?tag:"ns2:ReferencedTextType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReferencedTextType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReferencedTextType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReferencedTextType * SOAP_FMAC4 soap_get_ns2__ReferencedTextType(struct soap *soap, ns2__ReferencedTextType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReferencedTextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ReferencedTextType * SOAP_FMAC2 soap_instantiate_ns2__ReferencedTextType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReferencedTextType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReferencedTextType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReferencedTextType);
		if (size)
			*size = sizeof(ns2__ReferencedTextType);
		((ns2__ReferencedTextType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReferencedTextType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ReferencedTextType);
		for (int i = 0; i < n; i++)
			((ns2__ReferencedTextType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ReferencedTextType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReferencedTextType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReferencedTextType %p -> %p\n", q, p));
	*(ns2__ReferencedTextType*)p = *(ns2__ReferencedTextType*)q;
}

void ns2__HyperfineQuantumNumbersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HyperfineQuantumNumbersType::__size_HyperfineQuantumNumbersType = 0;
	this->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType = NULL;
	this->ns2__HyperfineQuantumNumbersType::TotalAngularMomentumF = NULL;
	this->ns2__HyperfineQuantumNumbersType::TotalMagneticQuantumNumberF = NULL;
	/* transient soap skipped */
}

void ns2__HyperfineQuantumNumbersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType)
	{	int i;
		for (i = 0; i < this->ns2__HyperfineQuantumNumbersType::__size_HyperfineQuantumNumbersType; i++)
		{
			this->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__HyperfineQuantumNumbersType::TotalAngularMomentumF);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__HyperfineQuantumNumbersType::TotalMagneticQuantumNumberF);
	/* transient soap skipped */
}

int ns2__HyperfineQuantumNumbersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HyperfineQuantumNumbersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HyperfineQuantumNumbersType(struct soap *soap, const char *tag, int id, const ns2__HyperfineQuantumNumbersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HyperfineQuantumNumbersType), type))
		return soap->error;
	if (a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType)
	{	int i;
		for (i = 0; i < a->ns2__HyperfineQuantumNumbersType::__size_HyperfineQuantumNumbersType; i++)
			if (a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType[i].soap_out(soap, "-union-HyperfineQuantumNumbersType", -1, ""))
				return soap->error;
	}
	if (a->ns2__HyperfineQuantumNumbersType::TotalAngularMomentumF)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumF", -1, &a->ns2__HyperfineQuantumNumbersType::TotalAngularMomentumF, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumF"))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberF", -1, &(a->ns2__HyperfineQuantumNumbersType::TotalMagneticQuantumNumberF), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HyperfineQuantumNumbersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HyperfineQuantumNumbersType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HyperfineQuantumNumbersType * SOAP_FMAC4 soap_in_ns2__HyperfineQuantumNumbersType(struct soap *soap, const char *tag, ns2__HyperfineQuantumNumbersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HyperfineQuantumNumbersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HyperfineQuantumNumbersType, sizeof(ns2__HyperfineQuantumNumbersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HyperfineQuantumNumbersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HyperfineQuantumNumbersType *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_HyperfineQuantumNumbersType1 = NULL;
	size_t soap_flag_TotalAngularMomentumF1 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberF1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType == NULL)
				{	if (soap_blist___union_HyperfineQuantumNumbersType1 == NULL)
						soap_blist___union_HyperfineQuantumNumbersType1 = soap_new_block(soap);
					a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType = (__ns2__union_HyperfineQuantumNumbersType *)soap_push_block(soap, soap_blist___union_HyperfineQuantumNumbersType1, sizeof(__ns2__union_HyperfineQuantumNumbersType));
					if (a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType, __ns2__union_HyperfineQuantumNumbersType);
					a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType->soap_default(soap);
				}
				if (soap_in___ns2__union_HyperfineQuantumNumbersType(soap, "-union-HyperfineQuantumNumbersType", a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType, "-ns2:union-HyperfineQuantumNumbersType"))
				{	a->ns2__HyperfineQuantumNumbersType::__size_HyperfineQuantumNumbersType++;
					a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType = NULL;
					continue;
				}
			}
			if (soap_flag_TotalAngularMomentumF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumF", &(a->ns2__HyperfineQuantumNumbersType::TotalAngularMomentumF), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumF1--;
					continue;
				}
			if (soap_flag_TotalMagneticQuantumNumberF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberF", &(a->ns2__HyperfineQuantumNumbersType::TotalMagneticQuantumNumberF), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberF1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType)
			soap_pop_block(soap, soap_blist___union_HyperfineQuantumNumbersType1);
		if (a->ns2__HyperfineQuantumNumbersType::__size_HyperfineQuantumNumbersType)
			a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType = (__ns2__union_HyperfineQuantumNumbersType *)soap_save_block(soap, soap_blist___union_HyperfineQuantumNumbersType1, NULL, 1);
		else
		{	a->ns2__HyperfineQuantumNumbersType::__union_HyperfineQuantumNumbersType = NULL;
			if (soap_blist___union_HyperfineQuantumNumbersType1)
				soap_end_block(soap, soap_blist___union_HyperfineQuantumNumbersType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HyperfineQuantumNumbersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HyperfineQuantumNumbersType, 0, sizeof(ns2__HyperfineQuantumNumbersType), 0, soap_copy_ns2__HyperfineQuantumNumbersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumF1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HyperfineQuantumNumbersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HyperfineQuantumNumbersType);
	if (this->soap_out(soap, tag?tag:"ns2:HyperfineQuantumNumbersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HyperfineQuantumNumbersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HyperfineQuantumNumbersType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HyperfineQuantumNumbersType * SOAP_FMAC4 soap_get_ns2__HyperfineQuantumNumbersType(struct soap *soap, ns2__HyperfineQuantumNumbersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HyperfineQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HyperfineQuantumNumbersType * SOAP_FMAC2 soap_instantiate_ns2__HyperfineQuantumNumbersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HyperfineQuantumNumbersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HyperfineQuantumNumbersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineQuantumNumbersType);
		if (size)
			*size = sizeof(ns2__HyperfineQuantumNumbersType);
		((ns2__HyperfineQuantumNumbersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineQuantumNumbersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HyperfineQuantumNumbersType);
		for (int i = 0; i < n; i++)
			((ns2__HyperfineQuantumNumbersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HyperfineQuantumNumbersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HyperfineQuantumNumbersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HyperfineQuantumNumbersType %p -> %p\n", q, p));
	*(ns2__HyperfineQuantumNumbersType*)p = *(ns2__HyperfineQuantumNumbersType*)q;
}

void ns2__NonLinearNoElecHyperFType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearNoElecHyperFType::HyperfineQuantumNumbers = NULL;
	this->ns2__NonLinearNoElecType::TotalAngularMomentumN = NULL;
	this->ns2__NonLinearNoElecType::MolecularProjection = NULL;
	this->ns2__NonLinearNoElecType::C2Symmetries = NULL;
	/* transient soap skipped */
}

void ns2__NonLinearNoElecHyperFType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__HyperfineQuantumNumbersType(soap, &this->ns2__NonLinearNoElecHyperFType::HyperfineQuantumNumbers);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__NonLinearNoElecType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__MolecularProjectionType(soap, &this->ns2__NonLinearNoElecType::MolecularProjection);
	soap_serialize_PointerTons2__C2SymmetriesType(soap, &this->ns2__NonLinearNoElecType::C2Symmetries);
	/* transient soap skipped */
}

int ns2__NonLinearNoElecHyperFType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearNoElecHyperFType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearNoElecHyperFType(struct soap *soap, const char *tag, int id, const ns2__NonLinearNoElecHyperFType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearNoElecHyperFType), "ns2:NonLinearNoElecHyperFType"))
		return soap->error;
	if (a->ns2__NonLinearNoElecType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__NonLinearNoElecType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__NonLinearNoElecType::MolecularProjection)
	{	if (soap_out_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", -1, &a->ns2__NonLinearNoElecType::MolecularProjection, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularProjection"))
		return soap->error;
	if (soap_out_PointerTons2__C2SymmetriesType(soap, "ns2:C2Symmetries", -1, &(a->ns2__NonLinearNoElecType::C2Symmetries), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__NonLinearNoElecHyperFType::HyperfineQuantumNumbers)
	{	if (soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", -1, &a->ns2__NonLinearNoElecHyperFType::HyperfineQuantumNumbers, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HyperfineQuantumNumbers"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearNoElecHyperFType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearNoElecHyperFType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecHyperFType * SOAP_FMAC4 soap_in_ns2__NonLinearNoElecHyperFType(struct soap *soap, const char *tag, ns2__NonLinearNoElecHyperFType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearNoElecHyperFType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearNoElecHyperFType, sizeof(ns2__NonLinearNoElecHyperFType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonLinearNoElecHyperFType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonLinearNoElecHyperFType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumN2 = 1;
	size_t soap_flag_MolecularProjection2 = 1;
	size_t soap_flag_C2Symmetries2 = 1;
	size_t soap_flag_HyperfineQuantumNumbers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumN2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__NonLinearNoElecType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN2--;
					continue;
				}
			if (soap_flag_MolecularProjection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", &(a->ns2__NonLinearNoElecType::MolecularProjection), "ns2:MolecularProjectionType"))
				{	soap_flag_MolecularProjection2--;
					continue;
				}
			if (soap_flag_C2Symmetries2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__C2SymmetriesType(soap, "ns2:C2Symmetries", &(a->ns2__NonLinearNoElecType::C2Symmetries), "ns2:C2SymmetriesType"))
				{	soap_flag_C2Symmetries2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_HyperfineQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", &(a->ns2__NonLinearNoElecHyperFType::HyperfineQuantumNumbers), "ns2:HyperfineQuantumNumbersType"))
				{	soap_flag_HyperfineQuantumNumbers1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearNoElecHyperFType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearNoElecHyperFType, 0, sizeof(ns2__NonLinearNoElecHyperFType), 0, soap_copy_ns2__NonLinearNoElecHyperFType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN2 > 0 || soap_flag_MolecularProjection2 > 0 || soap_flag_HyperfineQuantumNumbers1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonLinearNoElecHyperFType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearNoElecHyperFType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearNoElecHyperFType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearNoElecHyperFType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearNoElecHyperFType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecHyperFType * SOAP_FMAC4 soap_get_ns2__NonLinearNoElecHyperFType(struct soap *soap, ns2__NonLinearNoElecHyperFType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearNoElecHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearNoElecHyperFType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearNoElecHyperFType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearNoElecHyperFType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearNoElecHyperFType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecHyperFType);
		if (size)
			*size = sizeof(ns2__NonLinearNoElecHyperFType);
		((ns2__NonLinearNoElecHyperFType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecHyperFType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearNoElecHyperFType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearNoElecHyperFType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearNoElecHyperFType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearNoElecHyperFType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearNoElecHyperFType %p -> %p\n", q, p));
	*(ns2__NonLinearNoElecHyperFType*)p = *(ns2__NonLinearNoElecHyperFType*)q;
}

void ns2__NonLinearNoElecNoHyperFType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearNoElecNoHyperFType::TotalMagneticQuantumNumberN = NULL;
	this->ns2__NonLinearNoElecType::TotalAngularMomentumN = NULL;
	this->ns2__NonLinearNoElecType::MolecularProjection = NULL;
	this->ns2__NonLinearNoElecType::C2Symmetries = NULL;
	/* transient soap skipped */
}

void ns2__NonLinearNoElecNoHyperFType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__NonLinearNoElecNoHyperFType::TotalMagneticQuantumNumberN);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__NonLinearNoElecType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__MolecularProjectionType(soap, &this->ns2__NonLinearNoElecType::MolecularProjection);
	soap_serialize_PointerTons2__C2SymmetriesType(soap, &this->ns2__NonLinearNoElecType::C2Symmetries);
	/* transient soap skipped */
}

int ns2__NonLinearNoElecNoHyperFType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearNoElecNoHyperFType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearNoElecNoHyperFType(struct soap *soap, const char *tag, int id, const ns2__NonLinearNoElecNoHyperFType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType), "ns2:NonLinearNoElecNoHyperFType"))
		return soap->error;
	if (a->ns2__NonLinearNoElecType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__NonLinearNoElecType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__NonLinearNoElecType::MolecularProjection)
	{	if (soap_out_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", -1, &a->ns2__NonLinearNoElecType::MolecularProjection, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularProjection"))
		return soap->error;
	if (soap_out_PointerTons2__C2SymmetriesType(soap, "ns2:C2Symmetries", -1, &(a->ns2__NonLinearNoElecType::C2Symmetries), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberN", -1, &(a->ns2__NonLinearNoElecNoHyperFType::TotalMagneticQuantumNumberN), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearNoElecNoHyperFType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearNoElecNoHyperFType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecNoHyperFType * SOAP_FMAC4 soap_in_ns2__NonLinearNoElecNoHyperFType(struct soap *soap, const char *tag, ns2__NonLinearNoElecNoHyperFType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearNoElecNoHyperFType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType, sizeof(ns2__NonLinearNoElecNoHyperFType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonLinearNoElecNoHyperFType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumN2 = 1;
	size_t soap_flag_MolecularProjection2 = 1;
	size_t soap_flag_C2Symmetries2 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumN2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__NonLinearNoElecType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN2--;
					continue;
				}
			if (soap_flag_MolecularProjection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", &(a->ns2__NonLinearNoElecType::MolecularProjection), "ns2:MolecularProjectionType"))
				{	soap_flag_MolecularProjection2--;
					continue;
				}
			if (soap_flag_C2Symmetries2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__C2SymmetriesType(soap, "ns2:C2Symmetries", &(a->ns2__NonLinearNoElecType::C2Symmetries), "ns2:C2SymmetriesType"))
				{	soap_flag_C2Symmetries2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_TotalMagneticQuantumNumberN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberN", &(a->ns2__NonLinearNoElecNoHyperFType::TotalMagneticQuantumNumberN), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearNoElecNoHyperFType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType, 0, sizeof(ns2__NonLinearNoElecNoHyperFType), 0, soap_copy_ns2__NonLinearNoElecNoHyperFType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN2 > 0 || soap_flag_MolecularProjection2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonLinearNoElecNoHyperFType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearNoElecNoHyperFType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearNoElecNoHyperFType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearNoElecNoHyperFType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecNoHyperFType * SOAP_FMAC4 soap_get_ns2__NonLinearNoElecNoHyperFType(struct soap *soap, ns2__NonLinearNoElecNoHyperFType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearNoElecNoHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearNoElecNoHyperFType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearNoElecNoHyperFType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearNoElecNoHyperFType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecNoHyperFType);
		if (size)
			*size = sizeof(ns2__NonLinearNoElecNoHyperFType);
		((ns2__NonLinearNoElecNoHyperFType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecNoHyperFType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearNoElecNoHyperFType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearNoElecNoHyperFType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearNoElecNoHyperFType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearNoElecNoHyperFType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearNoElecNoHyperFType %p -> %p\n", q, p));
	*(ns2__NonLinearNoElecNoHyperFType*)p = *(ns2__NonLinearNoElecNoHyperFType*)q;
}

void ns2__NonLinearNoElecType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearNoElecType::TotalAngularMomentumN = NULL;
	this->ns2__NonLinearNoElecType::MolecularProjection = NULL;
	this->ns2__NonLinearNoElecType::C2Symmetries = NULL;
	/* transient soap skipped */
}

void ns2__NonLinearNoElecType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__NonLinearNoElecType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__MolecularProjectionType(soap, &this->ns2__NonLinearNoElecType::MolecularProjection);
	soap_serialize_PointerTons2__C2SymmetriesType(soap, &this->ns2__NonLinearNoElecType::C2Symmetries);
	/* transient soap skipped */
}

int ns2__NonLinearNoElecType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearNoElecType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearNoElecType(struct soap *soap, const char *tag, int id, const ns2__NonLinearNoElecType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearNoElecType), type))
		return soap->error;
	if (a->ns2__NonLinearNoElecType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__NonLinearNoElecType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__NonLinearNoElecType::MolecularProjection)
	{	if (soap_out_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", -1, &a->ns2__NonLinearNoElecType::MolecularProjection, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularProjection"))
		return soap->error;
	if (soap_out_PointerTons2__C2SymmetriesType(soap, "ns2:C2Symmetries", -1, &(a->ns2__NonLinearNoElecType::C2Symmetries), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearNoElecType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearNoElecType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecType * SOAP_FMAC4 soap_in_ns2__NonLinearNoElecType(struct soap *soap, const char *tag, ns2__NonLinearNoElecType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearNoElecType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearNoElecType, sizeof(ns2__NonLinearNoElecType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonLinearNoElecType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonLinearNoElecType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumN1 = 1;
	size_t soap_flag_MolecularProjection1 = 1;
	size_t soap_flag_C2Symmetries1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__NonLinearNoElecType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN1--;
					continue;
				}
			if (soap_flag_MolecularProjection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", &(a->ns2__NonLinearNoElecType::MolecularProjection), "ns2:MolecularProjectionType"))
				{	soap_flag_MolecularProjection1--;
					continue;
				}
			if (soap_flag_C2Symmetries1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__C2SymmetriesType(soap, "ns2:C2Symmetries", &(a->ns2__NonLinearNoElecType::C2Symmetries), "ns2:C2SymmetriesType"))
				{	soap_flag_C2Symmetries1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearNoElecType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearNoElecType, 0, sizeof(ns2__NonLinearNoElecType), 0, soap_copy_ns2__NonLinearNoElecType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN1 > 0 || soap_flag_MolecularProjection1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonLinearNoElecType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearNoElecType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearNoElecType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearNoElecType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearNoElecType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecType * SOAP_FMAC4 soap_get_ns2__NonLinearNoElecType(struct soap *soap, ns2__NonLinearNoElecType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearNoElecType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearNoElecType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearNoElecType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearNoElecType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearNoElecType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:NonLinearNoElecNoHyperFType"))
	{	cp->type = SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecNoHyperFType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__NonLinearNoElecNoHyperFType);
			((ns2__NonLinearNoElecNoHyperFType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecNoHyperFType[n]);
			if (size)
				*size = n * sizeof(ns2__NonLinearNoElecNoHyperFType);
			for (int i = 0; i < n; i++)
				((ns2__NonLinearNoElecNoHyperFType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__NonLinearNoElecNoHyperFType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:NonLinearNoElecHyperFType"))
	{	cp->type = SOAP_TYPE_ns2__NonLinearNoElecHyperFType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecHyperFType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__NonLinearNoElecHyperFType);
			((ns2__NonLinearNoElecHyperFType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecHyperFType[n]);
			if (size)
				*size = n * sizeof(ns2__NonLinearNoElecHyperFType);
			for (int i = 0; i < n; i++)
				((ns2__NonLinearNoElecHyperFType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__NonLinearNoElecHyperFType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecType);
		if (size)
			*size = sizeof(ns2__NonLinearNoElecType);
		((ns2__NonLinearNoElecType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearNoElecType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearNoElecType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearNoElecType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearNoElecType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearNoElecType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearNoElecType %p -> %p\n", q, p));
	*(ns2__NonLinearNoElecType*)p = *(ns2__NonLinearNoElecType*)q;
}

void ns2__NonLinearElecNoHyperFType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearElecNoHyperFType::TotalMagneticQuantumNumberJ = NULL;
	this->ns2__NonLinearElecCouplingType::Label = NULL;
	this->ns2__NonLinearElecCouplingType::EfSymmetry = NULL;
	this->ns2__NonLinearElecCouplingType::TotalAngularMomentumN = NULL;
	this->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ = NULL;
	this->ns2__NonLinearElecCouplingType::MolecularProjection = NULL;
	this->ns2__NonLinearElecCouplingType::RoVibronicSplitting = NULL;
	/* transient soap skipped */
}

void ns2__NonLinearElecNoHyperFType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__NonLinearElecNoHyperFType::TotalMagneticQuantumNumberJ);
	soap_serialize_PointerTostd__string(soap, &this->ns2__NonLinearElecCouplingType::Label);
	soap_serialize_PointerTons2__EfSymmetryType(soap, &this->ns2__NonLinearElecCouplingType::EfSymmetry);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__NonLinearElecCouplingType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__MolecularProjectionType(soap, &this->ns2__NonLinearElecCouplingType::MolecularProjection);
	soap_serialize_PointerTons2__RoVibronicSplittingType(soap, &this->ns2__NonLinearElecCouplingType::RoVibronicSplitting);
	/* transient soap skipped */
}

int ns2__NonLinearElecNoHyperFType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearElecNoHyperFType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearElecNoHyperFType(struct soap *soap, const char *tag, int id, const ns2__NonLinearElecNoHyperFType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearElecNoHyperFType), "ns2:NonLinearElecNoHyperFType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Label", -1, &(a->ns2__NonLinearElecCouplingType::Label), ""))
		return soap->error;
	if (soap_out_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", -1, &(a->ns2__NonLinearElecCouplingType::EfSymmetry), ""))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumJ"))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::MolecularProjection)
	{	if (soap_out_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", -1, &a->ns2__NonLinearElecCouplingType::MolecularProjection, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularProjection"))
		return soap->error;
	if (soap_out_PointerTons2__RoVibronicSplittingType(soap, "ns2:RoVibronicSplitting", -1, &(a->ns2__NonLinearElecCouplingType::RoVibronicSplitting), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberJ", -1, &(a->ns2__NonLinearElecNoHyperFType::TotalMagneticQuantumNumberJ), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearElecNoHyperFType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearElecNoHyperFType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearElecNoHyperFType * SOAP_FMAC4 soap_in_ns2__NonLinearElecNoHyperFType(struct soap *soap, const char *tag, ns2__NonLinearElecNoHyperFType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearElecNoHyperFType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearElecNoHyperFType, sizeof(ns2__NonLinearElecNoHyperFType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonLinearElecNoHyperFType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonLinearElecNoHyperFType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Label2 = 1;
	size_t soap_flag_EfSymmetry2 = 1;
	size_t soap_flag_TotalAngularMomentumN2 = 1;
	size_t soap_flag_TotalAngularMomentumJ2 = 1;
	size_t soap_flag_MolecularProjection2 = 1;
	size_t soap_flag_RoVibronicSplitting2 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberJ1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Label", &(a->ns2__NonLinearElecCouplingType::Label), "xsd:string"))
				{	soap_flag_Label2--;
					continue;
				}
			if (soap_flag_EfSymmetry2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", &(a->ns2__NonLinearElecCouplingType::EfSymmetry), "ns2:EfSymmetryType"))
				{	soap_flag_EfSymmetry2--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumN2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN2--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumJ2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ2--;
					continue;
				}
			if (soap_flag_MolecularProjection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", &(a->ns2__NonLinearElecCouplingType::MolecularProjection), "ns2:MolecularProjectionType"))
				{	soap_flag_MolecularProjection2--;
					continue;
				}
			if (soap_flag_RoVibronicSplitting2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RoVibronicSplittingType(soap, "ns2:RoVibronicSplitting", &(a->ns2__NonLinearElecCouplingType::RoVibronicSplitting), "ns2:RoVibronicSplittingType"))
				{	soap_flag_RoVibronicSplitting2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_TotalMagneticQuantumNumberJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberJ", &(a->ns2__NonLinearElecNoHyperFType::TotalMagneticQuantumNumberJ), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberJ1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearElecNoHyperFType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearElecNoHyperFType, 0, sizeof(ns2__NonLinearElecNoHyperFType), 0, soap_copy_ns2__NonLinearElecNoHyperFType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN2 > 0 || soap_flag_TotalAngularMomentumJ2 > 0 || soap_flag_MolecularProjection2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonLinearElecNoHyperFType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearElecNoHyperFType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearElecNoHyperFType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearElecNoHyperFType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearElecNoHyperFType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearElecNoHyperFType * SOAP_FMAC4 soap_get_ns2__NonLinearElecNoHyperFType(struct soap *soap, ns2__NonLinearElecNoHyperFType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearElecNoHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearElecNoHyperFType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearElecNoHyperFType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearElecNoHyperFType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearElecNoHyperFType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecNoHyperFType);
		if (size)
			*size = sizeof(ns2__NonLinearElecNoHyperFType);
		((ns2__NonLinearElecNoHyperFType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecNoHyperFType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearElecNoHyperFType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearElecNoHyperFType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearElecNoHyperFType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearElecNoHyperFType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearElecNoHyperFType %p -> %p\n", q, p));
	*(ns2__NonLinearElecNoHyperFType*)p = *(ns2__NonLinearElecNoHyperFType*)q;
}

void ns2__NonLinearElecHyperFType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearElecHyperFType::HyperfineQuantumNumbers = NULL;
	this->ns2__NonLinearElecCouplingType::Label = NULL;
	this->ns2__NonLinearElecCouplingType::EfSymmetry = NULL;
	this->ns2__NonLinearElecCouplingType::TotalAngularMomentumN = NULL;
	this->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ = NULL;
	this->ns2__NonLinearElecCouplingType::MolecularProjection = NULL;
	this->ns2__NonLinearElecCouplingType::RoVibronicSplitting = NULL;
	/* transient soap skipped */
}

void ns2__NonLinearElecHyperFType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__HyperfineQuantumNumbersType(soap, &this->ns2__NonLinearElecHyperFType::HyperfineQuantumNumbers);
	soap_serialize_PointerTostd__string(soap, &this->ns2__NonLinearElecCouplingType::Label);
	soap_serialize_PointerTons2__EfSymmetryType(soap, &this->ns2__NonLinearElecCouplingType::EfSymmetry);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__NonLinearElecCouplingType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__MolecularProjectionType(soap, &this->ns2__NonLinearElecCouplingType::MolecularProjection);
	soap_serialize_PointerTons2__RoVibronicSplittingType(soap, &this->ns2__NonLinearElecCouplingType::RoVibronicSplitting);
	/* transient soap skipped */
}

int ns2__NonLinearElecHyperFType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearElecHyperFType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearElecHyperFType(struct soap *soap, const char *tag, int id, const ns2__NonLinearElecHyperFType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearElecHyperFType), "ns2:NonLinearElecHyperFType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Label", -1, &(a->ns2__NonLinearElecCouplingType::Label), ""))
		return soap->error;
	if (soap_out_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", -1, &(a->ns2__NonLinearElecCouplingType::EfSymmetry), ""))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumJ"))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::MolecularProjection)
	{	if (soap_out_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", -1, &a->ns2__NonLinearElecCouplingType::MolecularProjection, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularProjection"))
		return soap->error;
	if (soap_out_PointerTons2__RoVibronicSplittingType(soap, "ns2:RoVibronicSplitting", -1, &(a->ns2__NonLinearElecCouplingType::RoVibronicSplitting), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__NonLinearElecHyperFType::HyperfineQuantumNumbers)
	{	if (soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", -1, &a->ns2__NonLinearElecHyperFType::HyperfineQuantumNumbers, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HyperfineQuantumNumbers"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearElecHyperFType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearElecHyperFType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearElecHyperFType * SOAP_FMAC4 soap_in_ns2__NonLinearElecHyperFType(struct soap *soap, const char *tag, ns2__NonLinearElecHyperFType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearElecHyperFType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearElecHyperFType, sizeof(ns2__NonLinearElecHyperFType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonLinearElecHyperFType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonLinearElecHyperFType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Label2 = 1;
	size_t soap_flag_EfSymmetry2 = 1;
	size_t soap_flag_TotalAngularMomentumN2 = 1;
	size_t soap_flag_TotalAngularMomentumJ2 = 1;
	size_t soap_flag_MolecularProjection2 = 1;
	size_t soap_flag_RoVibronicSplitting2 = 1;
	size_t soap_flag_HyperfineQuantumNumbers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Label", &(a->ns2__NonLinearElecCouplingType::Label), "xsd:string"))
				{	soap_flag_Label2--;
					continue;
				}
			if (soap_flag_EfSymmetry2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", &(a->ns2__NonLinearElecCouplingType::EfSymmetry), "ns2:EfSymmetryType"))
				{	soap_flag_EfSymmetry2--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumN2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN2--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumJ2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ2--;
					continue;
				}
			if (soap_flag_MolecularProjection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", &(a->ns2__NonLinearElecCouplingType::MolecularProjection), "ns2:MolecularProjectionType"))
				{	soap_flag_MolecularProjection2--;
					continue;
				}
			if (soap_flag_RoVibronicSplitting2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RoVibronicSplittingType(soap, "ns2:RoVibronicSplitting", &(a->ns2__NonLinearElecCouplingType::RoVibronicSplitting), "ns2:RoVibronicSplittingType"))
				{	soap_flag_RoVibronicSplitting2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_HyperfineQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", &(a->ns2__NonLinearElecHyperFType::HyperfineQuantumNumbers), "ns2:HyperfineQuantumNumbersType"))
				{	soap_flag_HyperfineQuantumNumbers1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearElecHyperFType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearElecHyperFType, 0, sizeof(ns2__NonLinearElecHyperFType), 0, soap_copy_ns2__NonLinearElecHyperFType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN2 > 0 || soap_flag_TotalAngularMomentumJ2 > 0 || soap_flag_MolecularProjection2 > 0 || soap_flag_HyperfineQuantumNumbers1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonLinearElecHyperFType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearElecHyperFType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearElecHyperFType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearElecHyperFType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearElecHyperFType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearElecHyperFType * SOAP_FMAC4 soap_get_ns2__NonLinearElecHyperFType(struct soap *soap, ns2__NonLinearElecHyperFType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearElecHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearElecHyperFType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearElecHyperFType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearElecHyperFType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearElecHyperFType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecHyperFType);
		if (size)
			*size = sizeof(ns2__NonLinearElecHyperFType);
		((ns2__NonLinearElecHyperFType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecHyperFType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearElecHyperFType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearElecHyperFType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearElecHyperFType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearElecHyperFType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearElecHyperFType %p -> %p\n", q, p));
	*(ns2__NonLinearElecHyperFType*)p = *(ns2__NonLinearElecHyperFType*)q;
}

void ns2__NonLinearElecCouplingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearElecCouplingType::Label = NULL;
	this->ns2__NonLinearElecCouplingType::EfSymmetry = NULL;
	this->ns2__NonLinearElecCouplingType::TotalAngularMomentumN = NULL;
	this->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ = NULL;
	this->ns2__NonLinearElecCouplingType::MolecularProjection = NULL;
	this->ns2__NonLinearElecCouplingType::RoVibronicSplitting = NULL;
	/* transient soap skipped */
}

void ns2__NonLinearElecCouplingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__NonLinearElecCouplingType::Label);
	soap_serialize_PointerTons2__EfSymmetryType(soap, &this->ns2__NonLinearElecCouplingType::EfSymmetry);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__NonLinearElecCouplingType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__MolecularProjectionType(soap, &this->ns2__NonLinearElecCouplingType::MolecularProjection);
	soap_serialize_PointerTons2__RoVibronicSplittingType(soap, &this->ns2__NonLinearElecCouplingType::RoVibronicSplitting);
	/* transient soap skipped */
}

int ns2__NonLinearElecCouplingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearElecCouplingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearElecCouplingType(struct soap *soap, const char *tag, int id, const ns2__NonLinearElecCouplingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearElecCouplingType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Label", -1, &(a->ns2__NonLinearElecCouplingType::Label), ""))
		return soap->error;
	if (soap_out_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", -1, &(a->ns2__NonLinearElecCouplingType::EfSymmetry), ""))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumJ"))
		return soap->error;
	if (a->ns2__NonLinearElecCouplingType::MolecularProjection)
	{	if (soap_out_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", -1, &a->ns2__NonLinearElecCouplingType::MolecularProjection, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularProjection"))
		return soap->error;
	if (soap_out_PointerTons2__RoVibronicSplittingType(soap, "ns2:RoVibronicSplitting", -1, &(a->ns2__NonLinearElecCouplingType::RoVibronicSplitting), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearElecCouplingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearElecCouplingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearElecCouplingType * SOAP_FMAC4 soap_in_ns2__NonLinearElecCouplingType(struct soap *soap, const char *tag, ns2__NonLinearElecCouplingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearElecCouplingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearElecCouplingType, sizeof(ns2__NonLinearElecCouplingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NonLinearElecCouplingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NonLinearElecCouplingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Label1 = 1;
	size_t soap_flag_EfSymmetry1 = 1;
	size_t soap_flag_TotalAngularMomentumN1 = 1;
	size_t soap_flag_TotalAngularMomentumJ1 = 1;
	size_t soap_flag_MolecularProjection1 = 1;
	size_t soap_flag_RoVibronicSplitting1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Label", &(a->ns2__NonLinearElecCouplingType::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap_flag_EfSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", &(a->ns2__NonLinearElecCouplingType::EfSymmetry), "ns2:EfSymmetryType"))
				{	soap_flag_EfSymmetry1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__NonLinearElecCouplingType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__NonLinearElecCouplingType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ1--;
					continue;
				}
			if (soap_flag_MolecularProjection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularProjectionType(soap, "ns2:MolecularProjection", &(a->ns2__NonLinearElecCouplingType::MolecularProjection), "ns2:MolecularProjectionType"))
				{	soap_flag_MolecularProjection1--;
					continue;
				}
			if (soap_flag_RoVibronicSplitting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RoVibronicSplittingType(soap, "ns2:RoVibronicSplitting", &(a->ns2__NonLinearElecCouplingType::RoVibronicSplitting), "ns2:RoVibronicSplittingType"))
				{	soap_flag_RoVibronicSplitting1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearElecCouplingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearElecCouplingType, 0, sizeof(ns2__NonLinearElecCouplingType), 0, soap_copy_ns2__NonLinearElecCouplingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN1 > 0 || soap_flag_TotalAngularMomentumJ1 > 0 || soap_flag_MolecularProjection1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NonLinearElecCouplingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearElecCouplingType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearElecCouplingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearElecCouplingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearElecCouplingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearElecCouplingType * SOAP_FMAC4 soap_get_ns2__NonLinearElecCouplingType(struct soap *soap, ns2__NonLinearElecCouplingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearElecCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearElecCouplingType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearElecCouplingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearElecCouplingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearElecCouplingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:NonLinearElecHyperFType"))
	{	cp->type = SOAP_TYPE_ns2__NonLinearElecHyperFType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecHyperFType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__NonLinearElecHyperFType);
			((ns2__NonLinearElecHyperFType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecHyperFType[n]);
			if (size)
				*size = n * sizeof(ns2__NonLinearElecHyperFType);
			for (int i = 0; i < n; i++)
				((ns2__NonLinearElecHyperFType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__NonLinearElecHyperFType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:NonLinearElecNoHyperFType"))
	{	cp->type = SOAP_TYPE_ns2__NonLinearElecNoHyperFType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecNoHyperFType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__NonLinearElecNoHyperFType);
			((ns2__NonLinearElecNoHyperFType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecNoHyperFType[n]);
			if (size)
				*size = n * sizeof(ns2__NonLinearElecNoHyperFType);
			for (int i = 0; i < n; i++)
				((ns2__NonLinearElecNoHyperFType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__NonLinearElecNoHyperFType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecCouplingType);
		if (size)
			*size = sizeof(ns2__NonLinearElecCouplingType);
		((ns2__NonLinearElecCouplingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearElecCouplingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearElecCouplingType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearElecCouplingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearElecCouplingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearElecCouplingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearElecCouplingType %p -> %p\n", q, p));
	*(ns2__NonLinearElecCouplingType*)p = *(ns2__NonLinearElecCouplingType*)q;
}

void ns2__HyperfineCouplingBType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__CouplingListType(soap, &this->ns2__HyperfineCouplingBType::CouplingType);
	this->ns2__HyperfineCouplingBType::TotalAngularMomentumN = NULL;
	this->ns2__HyperfineCouplingBType::TotalAngularMomentumJ = NULL;
	this->ns2__HyperfineCouplingBType::HyperfineQuantumNumbers = NULL;
	/* transient soap skipped */
}

void ns2__HyperfineCouplingBType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HyperfineCouplingBType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__HyperfineCouplingBType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__HyperfineQuantumNumbersType(soap, &this->ns2__HyperfineCouplingBType::HyperfineQuantumNumbers);
	/* transient soap skipped */
}

int ns2__HyperfineCouplingBType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HyperfineCouplingBType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HyperfineCouplingBType(struct soap *soap, const char *tag, int id, const ns2__HyperfineCouplingBType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HyperfineCouplingBType), type))
		return soap->error;
	if (soap_out_ns2__CouplingListType(soap, "ns2:CouplingType", -1, &(a->ns2__HyperfineCouplingBType::CouplingType), ""))
		return soap->error;
	if (a->ns2__HyperfineCouplingBType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__HyperfineCouplingBType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &(a->ns2__HyperfineCouplingBType::TotalAngularMomentumJ), ""))
		return soap->error;
	if (a->ns2__HyperfineCouplingBType::HyperfineQuantumNumbers)
	{	if (soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", -1, &a->ns2__HyperfineCouplingBType::HyperfineQuantumNumbers, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HyperfineQuantumNumbers"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HyperfineCouplingBType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HyperfineCouplingBType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HyperfineCouplingBType * SOAP_FMAC4 soap_in_ns2__HyperfineCouplingBType(struct soap *soap, const char *tag, ns2__HyperfineCouplingBType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HyperfineCouplingBType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HyperfineCouplingBType, sizeof(ns2__HyperfineCouplingBType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HyperfineCouplingBType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HyperfineCouplingBType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CouplingType1 = 1;
	size_t soap_flag_TotalAngularMomentumN1 = 1;
	size_t soap_flag_TotalAngularMomentumJ1 = 1;
	size_t soap_flag_HyperfineQuantumNumbers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CouplingType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__CouplingListType(soap, "ns2:CouplingType", &(a->ns2__HyperfineCouplingBType::CouplingType), "ns2:CouplingListType"))
				{	soap_flag_CouplingType1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__HyperfineCouplingBType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__HyperfineCouplingBType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ1--;
					continue;
				}
			if (soap_flag_HyperfineQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", &(a->ns2__HyperfineCouplingBType::HyperfineQuantumNumbers), "ns2:HyperfineQuantumNumbersType"))
				{	soap_flag_HyperfineQuantumNumbers1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HyperfineCouplingBType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HyperfineCouplingBType, 0, sizeof(ns2__HyperfineCouplingBType), 0, soap_copy_ns2__HyperfineCouplingBType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CouplingType1 > 0 || soap_flag_TotalAngularMomentumN1 > 0 || soap_flag_HyperfineQuantumNumbers1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HyperfineCouplingBType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HyperfineCouplingBType);
	if (this->soap_out(soap, tag?tag:"ns2:HyperfineCouplingBType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HyperfineCouplingBType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HyperfineCouplingBType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HyperfineCouplingBType * SOAP_FMAC4 soap_get_ns2__HyperfineCouplingBType(struct soap *soap, ns2__HyperfineCouplingBType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HyperfineCouplingBType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HyperfineCouplingBType * SOAP_FMAC2 soap_instantiate_ns2__HyperfineCouplingBType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HyperfineCouplingBType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HyperfineCouplingBType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineCouplingBType);
		if (size)
			*size = sizeof(ns2__HyperfineCouplingBType);
		((ns2__HyperfineCouplingBType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineCouplingBType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HyperfineCouplingBType);
		for (int i = 0; i < n; i++)
			((ns2__HyperfineCouplingBType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HyperfineCouplingBType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HyperfineCouplingBType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HyperfineCouplingBType %p -> %p\n", q, p));
	*(ns2__HyperfineCouplingBType*)p = *(ns2__HyperfineCouplingBType*)q;
}

void ns2__HyperfineCaseABetaType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HyperfineCaseABetaType::TotalAngularMomentumJ = NULL;
	this->ns2__HyperfineCaseABetaType::TotalMolecularProjectionJ = NULL;
	this->ns2__HyperfineCaseABetaType::HyperfineQuantumNumbers = NULL;
	/* transient soap skipped */
}

void ns2__HyperfineCaseABetaType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__HyperfineCaseABetaType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HyperfineCaseABetaType::TotalMolecularProjectionJ);
	soap_serialize_PointerTons2__HyperfineQuantumNumbersType(soap, &this->ns2__HyperfineCaseABetaType::HyperfineQuantumNumbers);
	/* transient soap skipped */
}

int ns2__HyperfineCaseABetaType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HyperfineCaseABetaType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HyperfineCaseABetaType(struct soap *soap, const char *tag, int id, const ns2__HyperfineCaseABetaType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HyperfineCaseABetaType), type))
		return soap->error;
	if (a->ns2__HyperfineCaseABetaType::TotalAngularMomentumJ)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &a->ns2__HyperfineCaseABetaType::TotalAngularMomentumJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumJ"))
		return soap->error;
	if (a->ns2__HyperfineCaseABetaType::TotalMolecularProjectionJ)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionJ", -1, &a->ns2__HyperfineCaseABetaType::TotalMolecularProjectionJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalMolecularProjectionJ"))
		return soap->error;
	if (a->ns2__HyperfineCaseABetaType::HyperfineQuantumNumbers)
	{	if (soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", -1, &a->ns2__HyperfineCaseABetaType::HyperfineQuantumNumbers, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HyperfineQuantumNumbers"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HyperfineCaseABetaType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HyperfineCaseABetaType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HyperfineCaseABetaType * SOAP_FMAC4 soap_in_ns2__HyperfineCaseABetaType(struct soap *soap, const char *tag, ns2__HyperfineCaseABetaType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HyperfineCaseABetaType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HyperfineCaseABetaType, sizeof(ns2__HyperfineCaseABetaType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HyperfineCaseABetaType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HyperfineCaseABetaType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumJ1 = 1;
	size_t soap_flag_TotalMolecularProjectionJ1 = 1;
	size_t soap_flag_HyperfineQuantumNumbers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__HyperfineCaseABetaType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ1--;
					continue;
				}
			if (soap_flag_TotalMolecularProjectionJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionJ", &(a->ns2__HyperfineCaseABetaType::TotalMolecularProjectionJ), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalMolecularProjectionJ1--;
					continue;
				}
			if (soap_flag_HyperfineQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", &(a->ns2__HyperfineCaseABetaType::HyperfineQuantumNumbers), "ns2:HyperfineQuantumNumbersType"))
				{	soap_flag_HyperfineQuantumNumbers1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HyperfineCaseABetaType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HyperfineCaseABetaType, 0, sizeof(ns2__HyperfineCaseABetaType), 0, soap_copy_ns2__HyperfineCaseABetaType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumJ1 > 0 || soap_flag_TotalMolecularProjectionJ1 > 0 || soap_flag_HyperfineQuantumNumbers1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HyperfineCaseABetaType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HyperfineCaseABetaType);
	if (this->soap_out(soap, tag?tag:"ns2:HyperfineCaseABetaType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HyperfineCaseABetaType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HyperfineCaseABetaType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HyperfineCaseABetaType * SOAP_FMAC4 soap_get_ns2__HyperfineCaseABetaType(struct soap *soap, ns2__HyperfineCaseABetaType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HyperfineCaseABetaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HyperfineCaseABetaType * SOAP_FMAC2 soap_instantiate_ns2__HyperfineCaseABetaType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HyperfineCaseABetaType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HyperfineCaseABetaType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineCaseABetaType);
		if (size)
			*size = sizeof(ns2__HyperfineCaseABetaType);
		((ns2__HyperfineCaseABetaType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineCaseABetaType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HyperfineCaseABetaType);
		for (int i = 0; i < n; i++)
			((ns2__HyperfineCaseABetaType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HyperfineCaseABetaType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HyperfineCaseABetaType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HyperfineCaseABetaType %p -> %p\n", q, p));
	*(ns2__HyperfineCaseABetaType*)p = *(ns2__HyperfineCaseABetaType*)q;
}

void ns2__HyperfineCaseAAlphaType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HyperfineCaseAAlphaType::TotalAngularMomentumF = NULL;
	this->ns2__HyperfineCaseAAlphaType::TotalMolecularProjectionF = NULL;
	this->ns2__HyperfineCaseAAlphaType::TotalMagneticQuantumNumberF = NULL;
	/* transient soap skipped */
}

void ns2__HyperfineCaseAAlphaType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__HyperfineCaseAAlphaType::TotalAngularMomentumF);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HyperfineCaseAAlphaType::TotalMolecularProjectionF);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__HyperfineCaseAAlphaType::TotalMagneticQuantumNumberF);
	/* transient soap skipped */
}

int ns2__HyperfineCaseAAlphaType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HyperfineCaseAAlphaType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HyperfineCaseAAlphaType(struct soap *soap, const char *tag, int id, const ns2__HyperfineCaseAAlphaType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HyperfineCaseAAlphaType), type))
		return soap->error;
	if (a->ns2__HyperfineCaseAAlphaType::TotalAngularMomentumF)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumF", -1, &a->ns2__HyperfineCaseAAlphaType::TotalAngularMomentumF, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumF"))
		return soap->error;
	if (a->ns2__HyperfineCaseAAlphaType::TotalMolecularProjectionF)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionF", -1, &a->ns2__HyperfineCaseAAlphaType::TotalMolecularProjectionF, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalMolecularProjectionF"))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberF", -1, &(a->ns2__HyperfineCaseAAlphaType::TotalMagneticQuantumNumberF), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HyperfineCaseAAlphaType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HyperfineCaseAAlphaType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HyperfineCaseAAlphaType * SOAP_FMAC4 soap_in_ns2__HyperfineCaseAAlphaType(struct soap *soap, const char *tag, ns2__HyperfineCaseAAlphaType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HyperfineCaseAAlphaType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HyperfineCaseAAlphaType, sizeof(ns2__HyperfineCaseAAlphaType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HyperfineCaseAAlphaType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HyperfineCaseAAlphaType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumF1 = 1;
	size_t soap_flag_TotalMolecularProjectionF1 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberF1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumF", &(a->ns2__HyperfineCaseAAlphaType::TotalAngularMomentumF), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumF1--;
					continue;
				}
			if (soap_flag_TotalMolecularProjectionF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionF", &(a->ns2__HyperfineCaseAAlphaType::TotalMolecularProjectionF), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalMolecularProjectionF1--;
					continue;
				}
			if (soap_flag_TotalMagneticQuantumNumberF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberF", &(a->ns2__HyperfineCaseAAlphaType::TotalMagneticQuantumNumberF), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberF1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HyperfineCaseAAlphaType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HyperfineCaseAAlphaType, 0, sizeof(ns2__HyperfineCaseAAlphaType), 0, soap_copy_ns2__HyperfineCaseAAlphaType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumF1 > 0 || soap_flag_TotalMolecularProjectionF1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HyperfineCaseAAlphaType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HyperfineCaseAAlphaType);
	if (this->soap_out(soap, tag?tag:"ns2:HyperfineCaseAAlphaType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HyperfineCaseAAlphaType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HyperfineCaseAAlphaType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HyperfineCaseAAlphaType * SOAP_FMAC4 soap_get_ns2__HyperfineCaseAAlphaType(struct soap *soap, ns2__HyperfineCaseAAlphaType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HyperfineCaseAAlphaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HyperfineCaseAAlphaType * SOAP_FMAC2 soap_instantiate_ns2__HyperfineCaseAAlphaType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HyperfineCaseAAlphaType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HyperfineCaseAAlphaType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineCaseAAlphaType);
		if (size)
			*size = sizeof(ns2__HyperfineCaseAAlphaType);
		((ns2__HyperfineCaseAAlphaType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HyperfineCaseAAlphaType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HyperfineCaseAAlphaType);
		for (int i = 0; i < n; i++)
			((ns2__HyperfineCaseAAlphaType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HyperfineCaseAAlphaType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HyperfineCaseAAlphaType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HyperfineCaseAAlphaType %p -> %p\n", q, p));
	*(ns2__HyperfineCaseAAlphaType*)p = *(ns2__HyperfineCaseAAlphaType*)q;
}

void ns2__HundCaseBType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HundCaseBType::TotalAngularMomentumN = NULL;
	this->ns2__HundCaseBType::TotalAngularMomentumJ = NULL;
	this->ns2__HundCaseBType::TotalMagneticQuantumNumberJ = NULL;
	/* transient soap skipped */
}

void ns2__HundCaseBType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HundCaseBType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__HundCaseBType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__HundCaseBType::TotalMagneticQuantumNumberJ);
	/* transient soap skipped */
}

int ns2__HundCaseBType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HundCaseBType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HundCaseBType(struct soap *soap, const char *tag, int id, const ns2__HundCaseBType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HundCaseBType), type))
		return soap->error;
	if (a->ns2__HundCaseBType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__HundCaseBType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__HundCaseBType::TotalAngularMomentumJ)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &a->ns2__HundCaseBType::TotalAngularMomentumJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumJ"))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberJ", -1, &(a->ns2__HundCaseBType::TotalMagneticQuantumNumberJ), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HundCaseBType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HundCaseBType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HundCaseBType * SOAP_FMAC4 soap_in_ns2__HundCaseBType(struct soap *soap, const char *tag, ns2__HundCaseBType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HundCaseBType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HundCaseBType, sizeof(ns2__HundCaseBType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HundCaseBType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HundCaseBType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumN1 = 1;
	size_t soap_flag_TotalAngularMomentumJ1 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberJ1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__HundCaseBType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentumJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__HundCaseBType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ1--;
					continue;
				}
			if (soap_flag_TotalMagneticQuantumNumberJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberJ", &(a->ns2__HundCaseBType::TotalMagneticQuantumNumberJ), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberJ1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HundCaseBType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HundCaseBType, 0, sizeof(ns2__HundCaseBType), 0, soap_copy_ns2__HundCaseBType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN1 > 0 || soap_flag_TotalAngularMomentumJ1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HundCaseBType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HundCaseBType);
	if (this->soap_out(soap, tag?tag:"ns2:HundCaseBType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HundCaseBType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HundCaseBType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HundCaseBType * SOAP_FMAC4 soap_get_ns2__HundCaseBType(struct soap *soap, ns2__HundCaseBType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HundCaseBType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HundCaseBType * SOAP_FMAC2 soap_instantiate_ns2__HundCaseBType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HundCaseBType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HundCaseBType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HundCaseBType);
		if (size)
			*size = sizeof(ns2__HundCaseBType);
		((ns2__HundCaseBType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HundCaseBType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HundCaseBType);
		for (int i = 0; i < n; i++)
			((ns2__HundCaseBType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HundCaseBType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HundCaseBType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HundCaseBType %p -> %p\n", q, p));
	*(ns2__HundCaseBType*)p = *(ns2__HundCaseBType*)q;
}

void ns2__HundCaseAType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HundCaseAType::TotalAngularMomentumJ = NULL;
	this->ns2__HundCaseAType::TotalMolecularProjectionJ = NULL;
	this->ns2__HundCaseAType::TotalMagneticQuantumNumberJ = NULL;
	/* transient soap skipped */
}

void ns2__HundCaseAType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__HundCaseAType::TotalAngularMomentumJ);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HundCaseAType::TotalMolecularProjectionJ);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__HundCaseAType::TotalMagneticQuantumNumberJ);
	/* transient soap skipped */
}

int ns2__HundCaseAType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HundCaseAType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HundCaseAType(struct soap *soap, const char *tag, int id, const ns2__HundCaseAType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HundCaseAType), type))
		return soap->error;
	if (a->ns2__HundCaseAType::TotalAngularMomentumJ)
	{	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", -1, &a->ns2__HundCaseAType::TotalAngularMomentumJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumJ"))
		return soap->error;
	if (a->ns2__HundCaseAType::TotalMolecularProjectionJ)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionJ", -1, &a->ns2__HundCaseAType::TotalMolecularProjectionJ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalMolecularProjectionJ"))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberJ", -1, &(a->ns2__HundCaseAType::TotalMagneticQuantumNumberJ), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HundCaseAType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HundCaseAType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HundCaseAType * SOAP_FMAC4 soap_in_ns2__HundCaseAType(struct soap *soap, const char *tag, ns2__HundCaseAType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HundCaseAType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HundCaseAType, sizeof(ns2__HundCaseAType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HundCaseAType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HundCaseAType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumJ1 = 1;
	size_t soap_flag_TotalMolecularProjectionJ1 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberJ1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumJ", &(a->ns2__HundCaseAType::TotalAngularMomentumJ), "ns2:ComplexMolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumJ1--;
					continue;
				}
			if (soap_flag_TotalMolecularProjectionJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionJ", &(a->ns2__HundCaseAType::TotalMolecularProjectionJ), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalMolecularProjectionJ1--;
					continue;
				}
			if (soap_flag_TotalMagneticQuantumNumberJ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberJ", &(a->ns2__HundCaseAType::TotalMagneticQuantumNumberJ), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberJ1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HundCaseAType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HundCaseAType, 0, sizeof(ns2__HundCaseAType), 0, soap_copy_ns2__HundCaseAType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumJ1 > 0 || soap_flag_TotalMolecularProjectionJ1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HundCaseAType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HundCaseAType);
	if (this->soap_out(soap, tag?tag:"ns2:HundCaseAType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HundCaseAType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HundCaseAType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HundCaseAType * SOAP_FMAC4 soap_get_ns2__HundCaseAType(struct soap *soap, ns2__HundCaseAType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HundCaseAType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HundCaseAType * SOAP_FMAC2 soap_instantiate_ns2__HundCaseAType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HundCaseAType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HundCaseAType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HundCaseAType);
		if (size)
			*size = sizeof(ns2__HundCaseAType);
		((ns2__HundCaseAType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HundCaseAType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HundCaseAType);
		for (int i = 0; i < n; i++)
			((ns2__HundCaseAType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HundCaseAType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HundCaseAType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HundCaseAType %p -> %p\n", q, p));
	*(ns2__HundCaseAType*)p = *(ns2__HundCaseAType*)q;
}

void ns2__LinearElecCouplingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__LinearElecCouplingType::Description);
	this->ns2__LinearElecCouplingType::EfSymmetry = NULL;
	this->ns2__LinearElecCouplingType::HundCaseA = NULL;
	this->ns2__LinearElecCouplingType::HyperfineCaseAAlpha = NULL;
	this->ns2__LinearElecCouplingType::HyperfineCaseABeta = NULL;
	this->ns2__LinearElecCouplingType::HundCaseB = NULL;
	this->ns2__LinearElecCouplingType::HyperfineCouplingHundCaseB = NULL;
	/* transient soap skipped */
}

void ns2__LinearElecCouplingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__LinearElecCouplingType::Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__LinearElecCouplingType::Description);
	soap_serialize_PointerTons2__EfSymmetryType(soap, &this->ns2__LinearElecCouplingType::EfSymmetry);
	soap_serialize_PointerTons2__HundCaseAType(soap, &this->ns2__LinearElecCouplingType::HundCaseA);
	soap_serialize_PointerTons2__HyperfineCaseAAlphaType(soap, &this->ns2__LinearElecCouplingType::HyperfineCaseAAlpha);
	soap_serialize_PointerTons2__HyperfineCaseABetaType(soap, &this->ns2__LinearElecCouplingType::HyperfineCaseABeta);
	soap_serialize_PointerTons2__HundCaseBType(soap, &this->ns2__LinearElecCouplingType::HundCaseB);
	soap_serialize_PointerTons2__HyperfineCouplingBType(soap, &this->ns2__LinearElecCouplingType::HyperfineCouplingHundCaseB);
	/* transient soap skipped */
}

int ns2__LinearElecCouplingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LinearElecCouplingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LinearElecCouplingType(struct soap *soap, const char *tag, int id, const ns2__LinearElecCouplingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LinearElecCouplingType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Description", -1, &(a->ns2__LinearElecCouplingType::Description), ""))
		return soap->error;
	if (soap_out_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", -1, &(a->ns2__LinearElecCouplingType::EfSymmetry), ""))
		return soap->error;
	if (soap_out_PointerTons2__HundCaseAType(soap, "ns2:HundCaseA", -1, &(a->ns2__LinearElecCouplingType::HundCaseA), ""))
		return soap->error;
	if (soap_out_PointerTons2__HyperfineCaseAAlphaType(soap, "ns2:HyperfineCaseAAlpha", -1, &(a->ns2__LinearElecCouplingType::HyperfineCaseAAlpha), ""))
		return soap->error;
	if (soap_out_PointerTons2__HyperfineCaseABetaType(soap, "ns2:HyperfineCaseABeta", -1, &(a->ns2__LinearElecCouplingType::HyperfineCaseABeta), ""))
		return soap->error;
	if (soap_out_PointerTons2__HundCaseBType(soap, "ns2:HundCaseB", -1, &(a->ns2__LinearElecCouplingType::HundCaseB), ""))
		return soap->error;
	if (soap_out_PointerTons2__HyperfineCouplingBType(soap, "ns2:HyperfineCouplingHundCaseB", -1, &(a->ns2__LinearElecCouplingType::HyperfineCouplingHundCaseB), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LinearElecCouplingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LinearElecCouplingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LinearElecCouplingType * SOAP_FMAC4 soap_in_ns2__LinearElecCouplingType(struct soap *soap, const char *tag, ns2__LinearElecCouplingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LinearElecCouplingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LinearElecCouplingType, sizeof(ns2__LinearElecCouplingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LinearElecCouplingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LinearElecCouplingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_EfSymmetry1 = 1;
	size_t soap_flag_HundCaseA1 = 1;
	size_t soap_flag_HyperfineCaseAAlpha1 = 1;
	size_t soap_flag_HyperfineCaseABeta1 = 1;
	size_t soap_flag_HundCaseB1 = 1;
	size_t soap_flag_HyperfineCouplingHundCaseB1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Description", &(a->ns2__LinearElecCouplingType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_EfSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EfSymmetryType(soap, "ns2:EfSymmetry", &(a->ns2__LinearElecCouplingType::EfSymmetry), "ns2:EfSymmetryType"))
				{	soap_flag_EfSymmetry1--;
					continue;
				}
			if (soap_flag_HundCaseA1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HundCaseAType(soap, "ns2:HundCaseA", &(a->ns2__LinearElecCouplingType::HundCaseA), "ns2:HundCaseAType"))
				{	soap_flag_HundCaseA1--;
					continue;
				}
			if (soap_flag_HyperfineCaseAAlpha1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineCaseAAlphaType(soap, "ns2:HyperfineCaseAAlpha", &(a->ns2__LinearElecCouplingType::HyperfineCaseAAlpha), "ns2:HyperfineCaseAAlphaType"))
				{	soap_flag_HyperfineCaseAAlpha1--;
					continue;
				}
			if (soap_flag_HyperfineCaseABeta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineCaseABetaType(soap, "ns2:HyperfineCaseABeta", &(a->ns2__LinearElecCouplingType::HyperfineCaseABeta), "ns2:HyperfineCaseABetaType"))
				{	soap_flag_HyperfineCaseABeta1--;
					continue;
				}
			if (soap_flag_HundCaseB1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HundCaseBType(soap, "ns2:HundCaseB", &(a->ns2__LinearElecCouplingType::HundCaseB), "ns2:HundCaseBType"))
				{	soap_flag_HundCaseB1--;
					continue;
				}
			if (soap_flag_HyperfineCouplingHundCaseB1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineCouplingBType(soap, "ns2:HyperfineCouplingHundCaseB", &(a->ns2__LinearElecCouplingType::HyperfineCouplingHundCaseB), "ns2:HyperfineCouplingBType"))
				{	soap_flag_HyperfineCouplingHundCaseB1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LinearElecCouplingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LinearElecCouplingType, 0, sizeof(ns2__LinearElecCouplingType), 0, soap_copy_ns2__LinearElecCouplingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LinearElecCouplingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LinearElecCouplingType);
	if (this->soap_out(soap, tag?tag:"ns2:LinearElecCouplingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LinearElecCouplingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LinearElecCouplingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LinearElecCouplingType * SOAP_FMAC4 soap_get_ns2__LinearElecCouplingType(struct soap *soap, ns2__LinearElecCouplingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LinearElecCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LinearElecCouplingType * SOAP_FMAC2 soap_instantiate_ns2__LinearElecCouplingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LinearElecCouplingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LinearElecCouplingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LinearElecCouplingType);
		if (size)
			*size = sizeof(ns2__LinearElecCouplingType);
		((ns2__LinearElecCouplingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LinearElecCouplingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LinearElecCouplingType);
		for (int i = 0; i < n; i++)
			((ns2__LinearElecCouplingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LinearElecCouplingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LinearElecCouplingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LinearElecCouplingType %p -> %p\n", q, p));
	*(ns2__LinearElecCouplingType*)p = *(ns2__LinearElecCouplingType*)q;
}

void ns2__LinearNoElecHyperFType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LinearNoElecHyperFType::TotalAngularMomentumN = NULL;
	this->ns2__LinearNoElecHyperFType::HyperfineQuantumNumbers = NULL;
	/* transient soap skipped */
}

void ns2__LinearNoElecHyperFType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__LinearNoElecHyperFType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__HyperfineQuantumNumbersType(soap, &this->ns2__LinearNoElecHyperFType::HyperfineQuantumNumbers);
	/* transient soap skipped */
}

int ns2__LinearNoElecHyperFType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LinearNoElecHyperFType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LinearNoElecHyperFType(struct soap *soap, const char *tag, int id, const ns2__LinearNoElecHyperFType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LinearNoElecHyperFType), type))
		return soap->error;
	if (a->ns2__LinearNoElecHyperFType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__LinearNoElecHyperFType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (a->ns2__LinearNoElecHyperFType::HyperfineQuantumNumbers)
	{	if (soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", -1, &a->ns2__LinearNoElecHyperFType::HyperfineQuantumNumbers, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HyperfineQuantumNumbers"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LinearNoElecHyperFType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LinearNoElecHyperFType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LinearNoElecHyperFType * SOAP_FMAC4 soap_in_ns2__LinearNoElecHyperFType(struct soap *soap, const char *tag, ns2__LinearNoElecHyperFType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LinearNoElecHyperFType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LinearNoElecHyperFType, sizeof(ns2__LinearNoElecHyperFType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LinearNoElecHyperFType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LinearNoElecHyperFType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumN1 = 1;
	size_t soap_flag_HyperfineQuantumNumbers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__LinearNoElecHyperFType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN1--;
					continue;
				}
			if (soap_flag_HyperfineQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, "ns2:HyperfineQuantumNumbers", &(a->ns2__LinearNoElecHyperFType::HyperfineQuantumNumbers), "ns2:HyperfineQuantumNumbersType"))
				{	soap_flag_HyperfineQuantumNumbers1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LinearNoElecHyperFType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LinearNoElecHyperFType, 0, sizeof(ns2__LinearNoElecHyperFType), 0, soap_copy_ns2__LinearNoElecHyperFType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN1 > 0 || soap_flag_HyperfineQuantumNumbers1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LinearNoElecHyperFType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LinearNoElecHyperFType);
	if (this->soap_out(soap, tag?tag:"ns2:LinearNoElecHyperFType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LinearNoElecHyperFType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LinearNoElecHyperFType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LinearNoElecHyperFType * SOAP_FMAC4 soap_get_ns2__LinearNoElecHyperFType(struct soap *soap, ns2__LinearNoElecHyperFType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LinearNoElecHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LinearNoElecHyperFType * SOAP_FMAC2 soap_instantiate_ns2__LinearNoElecHyperFType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LinearNoElecHyperFType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LinearNoElecHyperFType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LinearNoElecHyperFType);
		if (size)
			*size = sizeof(ns2__LinearNoElecHyperFType);
		((ns2__LinearNoElecHyperFType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LinearNoElecHyperFType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LinearNoElecHyperFType);
		for (int i = 0; i < n; i++)
			((ns2__LinearNoElecHyperFType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LinearNoElecHyperFType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LinearNoElecHyperFType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LinearNoElecHyperFType %p -> %p\n", q, p));
	*(ns2__LinearNoElecHyperFType*)p = *(ns2__LinearNoElecHyperFType*)q;
}

void ns2__LinearNoElecNoHyperFType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LinearNoElecNoHyperFType::TotalAngularMomentumN = NULL;
	this->ns2__LinearNoElecNoHyperFType::TotalMagneticQuantumNumberN = NULL;
	/* transient soap skipped */
}

void ns2__LinearNoElecNoHyperFType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__LinearNoElecNoHyperFType::TotalAngularMomentumN);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__LinearNoElecNoHyperFType::TotalMagneticQuantumNumberN);
	/* transient soap skipped */
}

int ns2__LinearNoElecNoHyperFType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LinearNoElecNoHyperFType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LinearNoElecNoHyperFType(struct soap *soap, const char *tag, int id, const ns2__LinearNoElecNoHyperFType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LinearNoElecNoHyperFType), type))
		return soap->error;
	if (a->ns2__LinearNoElecNoHyperFType::TotalAngularMomentumN)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", -1, &a->ns2__LinearNoElecNoHyperFType::TotalAngularMomentumN, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TotalAngularMomentumN"))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberN", -1, &(a->ns2__LinearNoElecNoHyperFType::TotalMagneticQuantumNumberN), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LinearNoElecNoHyperFType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LinearNoElecNoHyperFType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LinearNoElecNoHyperFType * SOAP_FMAC4 soap_in_ns2__LinearNoElecNoHyperFType(struct soap *soap, const char *tag, ns2__LinearNoElecNoHyperFType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LinearNoElecNoHyperFType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LinearNoElecNoHyperFType, sizeof(ns2__LinearNoElecNoHyperFType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LinearNoElecNoHyperFType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LinearNoElecNoHyperFType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalAngularMomentumN1 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalAngularMomentumN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalAngularMomentumN", &(a->ns2__LinearNoElecNoHyperFType::TotalAngularMomentumN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalAngularMomentumN1--;
					continue;
				}
			if (soap_flag_TotalMagneticQuantumNumberN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberN", &(a->ns2__LinearNoElecNoHyperFType::TotalMagneticQuantumNumberN), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberN1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LinearNoElecNoHyperFType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LinearNoElecNoHyperFType, 0, sizeof(ns2__LinearNoElecNoHyperFType), 0, soap_copy_ns2__LinearNoElecNoHyperFType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalAngularMomentumN1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LinearNoElecNoHyperFType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LinearNoElecNoHyperFType);
	if (this->soap_out(soap, tag?tag:"ns2:LinearNoElecNoHyperFType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LinearNoElecNoHyperFType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LinearNoElecNoHyperFType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LinearNoElecNoHyperFType * SOAP_FMAC4 soap_get_ns2__LinearNoElecNoHyperFType(struct soap *soap, ns2__LinearNoElecNoHyperFType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LinearNoElecNoHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LinearNoElecNoHyperFType * SOAP_FMAC2 soap_instantiate_ns2__LinearNoElecNoHyperFType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LinearNoElecNoHyperFType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LinearNoElecNoHyperFType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LinearNoElecNoHyperFType);
		if (size)
			*size = sizeof(ns2__LinearNoElecNoHyperFType);
		((ns2__LinearNoElecNoHyperFType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LinearNoElecNoHyperFType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LinearNoElecNoHyperFType);
		for (int i = 0; i < n; i++)
			((ns2__LinearNoElecNoHyperFType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LinearNoElecNoHyperFType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LinearNoElecNoHyperFType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LinearNoElecNoHyperFType %p -> %p\n", q, p));
	*(ns2__LinearNoElecNoHyperFType*)p = *(ns2__LinearNoElecNoHyperFType*)q;
}

void ns2__VibrationalQuantumNumbersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__VibrationalQuantumNumbersType::VibrationalNu);
	this->ns2__VibrationalQuantumNumbersType::TotalVibrationL = NULL;
	this->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumK = NULL;
	this->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumP = NULL;
	/* transient soap skipped */
}

void ns2__VibrationalQuantumNumbersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(soap, &this->ns2__VibrationalQuantumNumbersType::VibrationalNu);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__VibrationalQuantumNumbersType::TotalVibrationL);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumK);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumP);
	/* transient soap skipped */
}

int ns2__VibrationalQuantumNumbersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VibrationalQuantumNumbersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VibrationalQuantumNumbersType(struct soap *soap, const char *tag, int id, const ns2__VibrationalQuantumNumbersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VibrationalQuantumNumbersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:VibrationalNu", -1, &(a->ns2__VibrationalQuantumNumbersType::VibrationalNu), ""))
		return soap->error;
	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalVibrationL", -1, &(a->ns2__VibrationalQuantumNumbersType::TotalVibrationL), ""))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:VibronicAngularMomentumK", -1, &(a->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumK), ""))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:VibronicAngularMomentumP", -1, &(a->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumP), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VibrationalQuantumNumbersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VibrationalQuantumNumbersType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VibrationalQuantumNumbersType * SOAP_FMAC4 soap_in_ns2__VibrationalQuantumNumbersType(struct soap *soap, const char *tag, ns2__VibrationalQuantumNumbersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VibrationalQuantumNumbersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VibrationalQuantumNumbersType, sizeof(ns2__VibrationalQuantumNumbersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VibrationalQuantumNumbersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VibrationalQuantumNumbersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalVibrationL1 = 1;
	size_t soap_flag_VibronicAngularMomentumK1 = 1;
	size_t soap_flag_VibronicAngularMomentumP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:VibrationalNu", &(a->ns2__VibrationalQuantumNumbersType::VibrationalNu), "ns2:ComplexMolecularQuantumNumberType"))
					continue;
			if (soap_flag_TotalVibrationL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalVibrationL", &(a->ns2__VibrationalQuantumNumbersType::TotalVibrationL), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalVibrationL1--;
					continue;
				}
			if (soap_flag_VibronicAngularMomentumK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:VibronicAngularMomentumK", &(a->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumK), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_VibronicAngularMomentumK1--;
					continue;
				}
			if (soap_flag_VibronicAngularMomentumP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:VibronicAngularMomentumP", &(a->ns2__VibrationalQuantumNumbersType::VibronicAngularMomentumP), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_VibronicAngularMomentumP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VibrationalQuantumNumbersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VibrationalQuantumNumbersType, 0, sizeof(ns2__VibrationalQuantumNumbersType), 0, soap_copy_ns2__VibrationalQuantumNumbersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__VibrationalQuantumNumbersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VibrationalQuantumNumbersType);
	if (this->soap_out(soap, tag?tag:"ns2:VibrationalQuantumNumbersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VibrationalQuantumNumbersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VibrationalQuantumNumbersType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VibrationalQuantumNumbersType * SOAP_FMAC4 soap_get_ns2__VibrationalQuantumNumbersType(struct soap *soap, ns2__VibrationalQuantumNumbersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VibrationalQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__VibrationalQuantumNumbersType * SOAP_FMAC2 soap_instantiate_ns2__VibrationalQuantumNumbersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VibrationalQuantumNumbersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VibrationalQuantumNumbersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalQuantumNumbersType);
		if (size)
			*size = sizeof(ns2__VibrationalQuantumNumbersType);
		((ns2__VibrationalQuantumNumbersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalQuantumNumbersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VibrationalQuantumNumbersType);
		for (int i = 0; i < n; i++)
			((ns2__VibrationalQuantumNumbersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VibrationalQuantumNumbersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VibrationalQuantumNumbersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VibrationalQuantumNumbersType %p -> %p\n", q, p));
	*(ns2__VibrationalQuantumNumbersType*)p = *(ns2__VibrationalQuantumNumbersType*)q;
}

void ns2__VibrationalHomeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VibrationalHomeType::Polyad = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__VibrationalComponentType(soap, &this->ns2__VibrationalHomeType::VibrationalComponent);
	/* transient soap skipped */
}

void ns2__VibrationalHomeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CharacterisationType(soap, &this->ns2__VibrationalHomeType::Polyad);
	soap_serialize_std__vectorTemplateOfPointerTons2__VibrationalComponentType(soap, &this->ns2__VibrationalHomeType::VibrationalComponent);
	/* transient soap skipped */
}

int ns2__VibrationalHomeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VibrationalHomeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VibrationalHomeType(struct soap *soap, const char *tag, int id, const ns2__VibrationalHomeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VibrationalHomeType), type))
		return soap->error;
	if (soap_out_PointerTons2__CharacterisationType(soap, "ns2:Polyad", -1, &(a->ns2__VibrationalHomeType::Polyad), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VibrationalComponentType(soap, "ns2:VibrationalComponent", -1, &(a->ns2__VibrationalHomeType::VibrationalComponent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VibrationalHomeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VibrationalHomeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VibrationalHomeType * SOAP_FMAC4 soap_in_ns2__VibrationalHomeType(struct soap *soap, const char *tag, ns2__VibrationalHomeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VibrationalHomeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VibrationalHomeType, sizeof(ns2__VibrationalHomeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VibrationalHomeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VibrationalHomeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Polyad1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Polyad1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CharacterisationType(soap, "ns2:Polyad", &(a->ns2__VibrationalHomeType::Polyad), "ns2:CharacterisationType"))
				{	soap_flag_Polyad1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__VibrationalComponentType(soap, "ns2:VibrationalComponent", &(a->ns2__VibrationalHomeType::VibrationalComponent), "ns2:VibrationalComponentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VibrationalHomeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VibrationalHomeType, 0, sizeof(ns2__VibrationalHomeType), 0, soap_copy_ns2__VibrationalHomeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__VibrationalHomeType::VibrationalComponent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__VibrationalHomeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VibrationalHomeType);
	if (this->soap_out(soap, tag?tag:"ns2:VibrationalHomeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VibrationalHomeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VibrationalHomeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VibrationalHomeType * SOAP_FMAC4 soap_get_ns2__VibrationalHomeType(struct soap *soap, ns2__VibrationalHomeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VibrationalHomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__VibrationalHomeType * SOAP_FMAC2 soap_instantiate_ns2__VibrationalHomeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VibrationalHomeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VibrationalHomeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalHomeType);
		if (size)
			*size = sizeof(ns2__VibrationalHomeType);
		((ns2__VibrationalHomeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalHomeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VibrationalHomeType);
		for (int i = 0; i < n; i++)
			((ns2__VibrationalHomeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VibrationalHomeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VibrationalHomeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VibrationalHomeType %p -> %p\n", q, p));
	*(ns2__VibrationalHomeType*)p = *(ns2__VibrationalHomeType*)q;
}

void ns2__VibrationalCharacterisationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VibrationalCharacterisationType::VibrationalSpeciesNotation = NULL;
	this->ns2__VibrationalCharacterisationType::VibronicSpeciesNotation = NULL;
	/* transient soap skipped */
}

void ns2__VibrationalCharacterisationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__VibrationalCharacterisationType::VibrationalSpeciesNotation);
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__VibrationalCharacterisationType::VibronicSpeciesNotation);
	/* transient soap skipped */
}

int ns2__VibrationalCharacterisationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VibrationalCharacterisationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VibrationalCharacterisationType(struct soap *soap, const char *tag, int id, const ns2__VibrationalCharacterisationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VibrationalCharacterisationType), type))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:VibrationalSpeciesNotation", -1, &(a->ns2__VibrationalCharacterisationType::VibrationalSpeciesNotation), ""))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:VibronicSpeciesNotation", -1, &(a->ns2__VibrationalCharacterisationType::VibronicSpeciesNotation), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VibrationalCharacterisationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VibrationalCharacterisationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VibrationalCharacterisationType * SOAP_FMAC4 soap_in_ns2__VibrationalCharacterisationType(struct soap *soap, const char *tag, ns2__VibrationalCharacterisationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VibrationalCharacterisationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VibrationalCharacterisationType, sizeof(ns2__VibrationalCharacterisationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VibrationalCharacterisationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VibrationalCharacterisationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_VibrationalSpeciesNotation1 = 1;
	size_t soap_flag_VibronicSpeciesNotation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VibrationalSpeciesNotation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:VibrationalSpeciesNotation", &(a->ns2__VibrationalCharacterisationType::VibrationalSpeciesNotation), "ns2:SymbolType"))
				{	soap_flag_VibrationalSpeciesNotation1--;
					continue;
				}
			if (soap_flag_VibronicSpeciesNotation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:VibronicSpeciesNotation", &(a->ns2__VibrationalCharacterisationType::VibronicSpeciesNotation), "ns2:SymbolType"))
				{	soap_flag_VibronicSpeciesNotation1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VibrationalCharacterisationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VibrationalCharacterisationType, 0, sizeof(ns2__VibrationalCharacterisationType), 0, soap_copy_ns2__VibrationalCharacterisationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__VibrationalCharacterisationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VibrationalCharacterisationType);
	if (this->soap_out(soap, tag?tag:"ns2:VibrationalCharacterisationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VibrationalCharacterisationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VibrationalCharacterisationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VibrationalCharacterisationType * SOAP_FMAC4 soap_get_ns2__VibrationalCharacterisationType(struct soap *soap, ns2__VibrationalCharacterisationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VibrationalCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__VibrationalCharacterisationType * SOAP_FMAC2 soap_instantiate_ns2__VibrationalCharacterisationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VibrationalCharacterisationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VibrationalCharacterisationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalCharacterisationType);
		if (size)
			*size = sizeof(ns2__VibrationalCharacterisationType);
		((ns2__VibrationalCharacterisationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalCharacterisationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VibrationalCharacterisationType);
		for (int i = 0; i < n; i++)
			((ns2__VibrationalCharacterisationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VibrationalCharacterisationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VibrationalCharacterisationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VibrationalCharacterisationType %p -> %p\n", q, p));
	*(ns2__VibrationalCharacterisationType*)p = *(ns2__VibrationalCharacterisationType*)q;
}

void ns2__VibrationalComponentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VibrationalComponentType::Description = NULL;
	this->ns2__VibrationalComponentType::SerialQuantumNumber = NULL;
	this->ns2__VibrationalComponentType::MixingCoefficient = NULL;
	this->ns2__VibrationalComponentType::VibrationalCharacterisation = NULL;
	this->ns2__VibrationalComponentType::VibrationalQuantumNumbers = NULL;
	this->ns2__VibrationalComponentType::RotationalHome = NULL;
	this->ns2__VibrationalComponentType::Comment = NULL;
	/* transient soap skipped */
}

void ns2__VibrationalComponentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__VibrationalComponentType::Description);
	soap_serialize_PointerTostd__string(soap, &this->ns2__VibrationalComponentType::SerialQuantumNumber);
	soap_serialize_PointerTons2__MixingCoefficientType(soap, &this->ns2__VibrationalComponentType::MixingCoefficient);
	soap_serialize_PointerTons2__VibrationalCharacterisationType(soap, &this->ns2__VibrationalComponentType::VibrationalCharacterisation);
	soap_serialize_PointerTons2__VibrationalQuantumNumbersType(soap, &this->ns2__VibrationalComponentType::VibrationalQuantumNumbers);
	soap_serialize_PointerTons2__RotationalHomeType(soap, &this->ns2__VibrationalComponentType::RotationalHome);
	soap_serialize_PointerToxsd__token(soap, &this->ns2__VibrationalComponentType::Comment);
	/* transient soap skipped */
}

int ns2__VibrationalComponentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VibrationalComponentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VibrationalComponentType(struct soap *soap, const char *tag, int id, const ns2__VibrationalComponentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VibrationalComponentType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__VibrationalComponentType::Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:SerialQuantumNumber", -1, &(a->ns2__VibrationalComponentType::SerialQuantumNumber), ""))
		return soap->error;
	if (soap_out_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", -1, &(a->ns2__VibrationalComponentType::MixingCoefficient), ""))
		return soap->error;
	if (soap_out_PointerTons2__VibrationalCharacterisationType(soap, "ns2:VibrationalCharacterisation", -1, &(a->ns2__VibrationalComponentType::VibrationalCharacterisation), ""))
		return soap->error;
	if (soap_out_PointerTons2__VibrationalQuantumNumbersType(soap, "ns2:VibrationalQuantumNumbers", -1, &(a->ns2__VibrationalComponentType::VibrationalQuantumNumbers), ""))
		return soap->error;
	if (soap_out_PointerTons2__RotationalHomeType(soap, "ns2:RotationalHome", -1, &(a->ns2__VibrationalComponentType::RotationalHome), ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "ns2:Comment", -1, &(a->ns2__VibrationalComponentType::Comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VibrationalComponentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VibrationalComponentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VibrationalComponentType * SOAP_FMAC4 soap_in_ns2__VibrationalComponentType(struct soap *soap, const char *tag, ns2__VibrationalComponentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VibrationalComponentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VibrationalComponentType, sizeof(ns2__VibrationalComponentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VibrationalComponentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VibrationalComponentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_SerialQuantumNumber1 = 1;
	size_t soap_flag_MixingCoefficient1 = 1;
	size_t soap_flag_VibrationalCharacterisation1 = 1;
	size_t soap_flag_VibrationalQuantumNumbers1 = 1;
	size_t soap_flag_RotationalHome1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__VibrationalComponentType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_SerialQuantumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:SerialQuantumNumber", &(a->ns2__VibrationalComponentType::SerialQuantumNumber), "xsd:string"))
				{	soap_flag_SerialQuantumNumber1--;
					continue;
				}
			if (soap_flag_MixingCoefficient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", &(a->ns2__VibrationalComponentType::MixingCoefficient), "ns2:MixingCoefficientType"))
				{	soap_flag_MixingCoefficient1--;
					continue;
				}
			if (soap_flag_VibrationalCharacterisation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VibrationalCharacterisationType(soap, "ns2:VibrationalCharacterisation", &(a->ns2__VibrationalComponentType::VibrationalCharacterisation), "ns2:VibrationalCharacterisationType"))
				{	soap_flag_VibrationalCharacterisation1--;
					continue;
				}
			if (soap_flag_VibrationalQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VibrationalQuantumNumbersType(soap, "ns2:VibrationalQuantumNumbers", &(a->ns2__VibrationalComponentType::VibrationalQuantumNumbers), "ns2:VibrationalQuantumNumbersType"))
				{	soap_flag_VibrationalQuantumNumbers1--;
					continue;
				}
			if (soap_flag_RotationalHome1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RotationalHomeType(soap, "ns2:RotationalHome", &(a->ns2__VibrationalComponentType::RotationalHome), "ns2:RotationalHomeType"))
				{	soap_flag_RotationalHome1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "ns2:Comment", &(a->ns2__VibrationalComponentType::Comment), "xsd:token"))
				{	soap_flag_Comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VibrationalComponentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VibrationalComponentType, 0, sizeof(ns2__VibrationalComponentType), 0, soap_copy_ns2__VibrationalComponentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__VibrationalComponentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VibrationalComponentType);
	if (this->soap_out(soap, tag?tag:"ns2:VibrationalComponentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VibrationalComponentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VibrationalComponentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VibrationalComponentType * SOAP_FMAC4 soap_get_ns2__VibrationalComponentType(struct soap *soap, ns2__VibrationalComponentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VibrationalComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__VibrationalComponentType * SOAP_FMAC2 soap_instantiate_ns2__VibrationalComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VibrationalComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VibrationalComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalComponentType);
		if (size)
			*size = sizeof(ns2__VibrationalComponentType);
		((ns2__VibrationalComponentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__VibrationalComponentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VibrationalComponentType);
		for (int i = 0; i < n; i++)
			((ns2__VibrationalComponentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VibrationalComponentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VibrationalComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VibrationalComponentType %p -> %p\n", q, p));
	*(ns2__VibrationalComponentType*)p = *(ns2__VibrationalComponentType*)q;
}

void ns2__TotalSpinMomentumSType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__AngularMomentumType(soap, &this->ns2__TotalSpinMomentumSType::__item);
	this->ns2__TotalSpinMomentumSType::electronicSpinId = NULL;
	/* transient soap skipped */
}

void ns2__TotalSpinMomentumSType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__TotalSpinMomentumSType::__item, SOAP_TYPE_ns2__AngularMomentumType);
	soap_serialize_ns2__AngularMomentumType(soap, &this->ns2__TotalSpinMomentumSType::__item);
	/* transient soap skipped */
}

int ns2__TotalSpinMomentumSType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TotalSpinMomentumSType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TotalSpinMomentumSType(struct soap *soap, const char *tag, int id, const ns2__TotalSpinMomentumSType *a, const char *type)
{
	if (((ns2__TotalSpinMomentumSType*)a)->electronicSpinId)
		soap_set_attr(soap, "electronicSpinId", ((ns2__TotalSpinMomentumSType*)a)->electronicSpinId->c_str(), 1);
	return soap_out_ns2__AngularMomentumType(soap, tag, id, &a->ns2__TotalSpinMomentumSType::__item, "");
}

void *ns2__TotalSpinMomentumSType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TotalSpinMomentumSType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TotalSpinMomentumSType * SOAP_FMAC4 soap_in_ns2__TotalSpinMomentumSType(struct soap *soap, const char *tag, ns2__TotalSpinMomentumSType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__TotalSpinMomentumSType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TotalSpinMomentumSType, sizeof(ns2__TotalSpinMomentumSType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__TotalSpinMomentumSType)
			return (ns2__TotalSpinMomentumSType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "electronicSpinId", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__TotalSpinMomentumSType*)a)->electronicSpinId = soap_new_std__string(soap, -1);
				((ns2__TotalSpinMomentumSType*)a)->electronicSpinId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_ns2__AngularMomentumType(soap, tag, &(a->ns2__TotalSpinMomentumSType::__item), "ns2:TotalSpinMomentumSType"))
		return NULL;
	return a;
}

int ns2__TotalSpinMomentumSType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__TotalSpinMomentumSType);
	if (this->soap_out(soap, tag?tag:"ns2:TotalSpinMomentumSType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TotalSpinMomentumSType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TotalSpinMomentumSType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TotalSpinMomentumSType * SOAP_FMAC4 soap_get_ns2__TotalSpinMomentumSType(struct soap *soap, ns2__TotalSpinMomentumSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TotalSpinMomentumSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__TotalSpinMomentumSType * SOAP_FMAC2 soap_instantiate_ns2__TotalSpinMomentumSType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TotalSpinMomentumSType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__TotalSpinMomentumSType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__TotalSpinMomentumSType);
		if (size)
			*size = sizeof(ns2__TotalSpinMomentumSType);
		((ns2__TotalSpinMomentumSType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__TotalSpinMomentumSType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__TotalSpinMomentumSType);
		for (int i = 0; i < n; i++)
			((ns2__TotalSpinMomentumSType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__TotalSpinMomentumSType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__TotalSpinMomentumSType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__TotalSpinMomentumSType %p -> %p\n", q, p));
	*(ns2__TotalSpinMomentumSType*)p = *(ns2__TotalSpinMomentumSType*)q;
}

void ns2__SymbolType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__SimpleSymbolType(soap, &this->ns2__SymbolType::Symbol);
	this->ns2__SymbolType::LatexExpression = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__SymbolType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__SimpleSymbolType(soap, &this->ns2__SymbolType::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SymbolType::LatexExpression);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__SymbolType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SymbolType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SymbolType(struct soap *soap, const char *tag, int id, const ns2__SymbolType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SymbolType), "ns2:SymbolType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__SimpleSymbolType(soap, "ns2:Symbol", -1, &(a->ns2__SymbolType::Symbol), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:LatexExpression", -1, &(a->ns2__SymbolType::LatexExpression), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SymbolType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SymbolType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SymbolType * SOAP_FMAC4 soap_in_ns2__SymbolType(struct soap *soap, const char *tag, ns2__SymbolType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SymbolType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SymbolType, sizeof(ns2__SymbolType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SymbolType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SymbolType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_LatexExpression1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__SimpleSymbolType(soap, "ns2:Symbol", &(a->ns2__SymbolType::Symbol), "ns2:SimpleSymbolType"))
					continue;
			if (soap_flag_LatexExpression1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:LatexExpression", &(a->ns2__SymbolType::LatexExpression), "xsd:string"))
				{	soap_flag_LatexExpression1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SymbolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SymbolType, 0, sizeof(ns2__SymbolType), 0, soap_copy_ns2__SymbolType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SymbolType::Symbol.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SymbolType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SymbolType);
	if (this->soap_out(soap, tag?tag:"ns2:SymbolType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SymbolType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SymbolType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SymbolType * SOAP_FMAC4 soap_get_ns2__SymbolType(struct soap *soap, ns2__SymbolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SymbolType * SOAP_FMAC2 soap_instantiate_ns2__SymbolType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SymbolType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SymbolType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SymbolType);
		if (size)
			*size = sizeof(ns2__SymbolType);
		((ns2__SymbolType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SymbolType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SymbolType);
		for (int i = 0; i < n; i++)
			((ns2__SymbolType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SymbolType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SymbolType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SymbolType %p -> %p\n", q, p));
	*(ns2__SymbolType*)p = *(ns2__SymbolType*)q;
}

void ns2__StateEnergyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__StateEnergyType::energyOrigin);
	this->ns2__DataType::Value = NULL;
	this->ns2__DataType::Accuracy = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__StateEnergyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueType(soap, &this->ns2__DataType::Value);
	soap_serialize_PointerTostd__string(soap, &this->ns2__DataType::Accuracy);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__StateEnergyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__StateEnergyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StateEnergyType(struct soap *soap, const char *tag, int id, const ns2__StateEnergyType *a, const char *type)
{
	soap_set_attr(soap, "energyOrigin", ((ns2__StateEnergyType*)a)->energyOrigin.c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StateEnergyType), "ns2:StateEnergyType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__DataType::Value)
	{	if (soap_out_PointerTons2__ValueType(soap, "ns2:Value", -1, &a->ns2__DataType::Value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Value"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Accuracy", -1, &(a->ns2__DataType::Accuracy), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__StateEnergyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__StateEnergyType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__StateEnergyType * SOAP_FMAC4 soap_in_ns2__StateEnergyType(struct soap *soap, const char *tag, ns2__StateEnergyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__StateEnergyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StateEnergyType, sizeof(ns2__StateEnergyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__StateEnergyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__StateEnergyType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "energyOrigin", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__StateEnergyType*)a)->energyOrigin.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments3 = 1;
	size_t soap_flag_Value2 = 1;
	size_t soap_flag_Accuracy2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueType(soap, "ns2:Value", &(a->ns2__DataType::Value), "ns2:ValueType"))
				{	soap_flag_Value2--;
					continue;
				}
			if (soap_flag_Accuracy2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Accuracy", &(a->ns2__DataType::Accuracy), "xsd:string"))
				{	soap_flag_Accuracy2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__StateEnergyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StateEnergyType, 0, sizeof(ns2__StateEnergyType), 0, soap_copy_ns2__StateEnergyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__StateEnergyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__StateEnergyType);
	if (this->soap_out(soap, tag?tag:"ns2:StateEnergyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__StateEnergyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__StateEnergyType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__StateEnergyType * SOAP_FMAC4 soap_get_ns2__StateEnergyType(struct soap *soap, ns2__StateEnergyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StateEnergyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__StateEnergyType * SOAP_FMAC2 soap_instantiate_ns2__StateEnergyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__StateEnergyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__StateEnergyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__StateEnergyType);
		if (size)
			*size = sizeof(ns2__StateEnergyType);
		((ns2__StateEnergyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__StateEnergyType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__StateEnergyType);
		for (int i = 0; i < n; i++)
			((ns2__StateEnergyType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__StateEnergyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__StateEnergyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__StateEnergyType %p -> %p\n", q, p));
	*(ns2__StateEnergyType*)p = *(ns2__StateEnergyType*)q;
}

void ns2__SimpleSymbolType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SimpleSymbolType::CentralSymbol = NULL;
	soap_default_std__string(soap, &this->ns2__SimpleSymbolType::RightCoefficient);
	soap_default_std__string(soap, &this->ns2__SimpleSymbolType::LeftCoefficient);
	/* transient soap skipped */
}

void ns2__SimpleSymbolType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CentralSymbolType(soap, &this->ns2__SimpleSymbolType::CentralSymbol);
	soap_embedded(soap, &this->ns2__SimpleSymbolType::RightCoefficient, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__SimpleSymbolType::RightCoefficient);
	soap_embedded(soap, &this->ns2__SimpleSymbolType::LeftCoefficient, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__SimpleSymbolType::LeftCoefficient);
	/* transient soap skipped */
}

int ns2__SimpleSymbolType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SimpleSymbolType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SimpleSymbolType(struct soap *soap, const char *tag, int id, const ns2__SimpleSymbolType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SimpleSymbolType), type))
		return soap->error;
	if (a->ns2__SimpleSymbolType::CentralSymbol)
	{	if (soap_out_PointerTons2__CentralSymbolType(soap, "ns2:CentralSymbol", -1, &a->ns2__SimpleSymbolType::CentralSymbol, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:CentralSymbol"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:RightCoefficient", -1, &(a->ns2__SimpleSymbolType::RightCoefficient), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:LeftCoefficient", -1, &(a->ns2__SimpleSymbolType::LeftCoefficient), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SimpleSymbolType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SimpleSymbolType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SimpleSymbolType * SOAP_FMAC4 soap_in_ns2__SimpleSymbolType(struct soap *soap, const char *tag, ns2__SimpleSymbolType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SimpleSymbolType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SimpleSymbolType, sizeof(ns2__SimpleSymbolType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SimpleSymbolType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SimpleSymbolType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CentralSymbol1 = 1;
	size_t soap_flag_RightCoefficient1 = 1;
	size_t soap_flag_LeftCoefficient1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CentralSymbol1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CentralSymbolType(soap, "ns2:CentralSymbol", &(a->ns2__SimpleSymbolType::CentralSymbol), "ns2:CentralSymbolType"))
				{	soap_flag_CentralSymbol1--;
					continue;
				}
			if (soap_flag_RightCoefficient1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:RightCoefficient", &(a->ns2__SimpleSymbolType::RightCoefficient), "xsd:string"))
				{	soap_flag_RightCoefficient1--;
					continue;
				}
			if (soap_flag_LeftCoefficient1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:LeftCoefficient", &(a->ns2__SimpleSymbolType::LeftCoefficient), "xsd:string"))
				{	soap_flag_LeftCoefficient1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SimpleSymbolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SimpleSymbolType, 0, sizeof(ns2__SimpleSymbolType), 0, soap_copy_ns2__SimpleSymbolType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CentralSymbol1 > 0 || soap_flag_RightCoefficient1 > 0 || soap_flag_LeftCoefficient1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SimpleSymbolType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SimpleSymbolType);
	if (this->soap_out(soap, tag?tag:"ns2:SimpleSymbolType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SimpleSymbolType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SimpleSymbolType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SimpleSymbolType * SOAP_FMAC4 soap_get_ns2__SimpleSymbolType(struct soap *soap, ns2__SimpleSymbolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SimpleSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SimpleSymbolType * SOAP_FMAC2 soap_instantiate_ns2__SimpleSymbolType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SimpleSymbolType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SimpleSymbolType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SimpleSymbolType);
		if (size)
			*size = sizeof(ns2__SimpleSymbolType);
		((ns2__SimpleSymbolType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SimpleSymbolType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SimpleSymbolType);
		for (int i = 0; i < n; i++)
			((ns2__SimpleSymbolType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SimpleSymbolType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SimpleSymbolType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SimpleSymbolType %p -> %p\n", q, p));
	*(ns2__SimpleSymbolType*)p = *(ns2__SimpleSymbolType*)q;
}

void ns2__MagneticQuantumNumberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__MagneticQuantumNumberType::Label);
	soap_default_ns2__AngularMomentumProjectionType(soap, &this->ns2__MagneticQuantumNumberType::Value);
	this->ns2__MagneticQuantumNumberType::Comment = NULL;
	this->ns2__MagneticQuantumNumberType::quantumNumberID = NULL;
	/* transient soap skipped */
}

void ns2__MagneticQuantumNumberType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MagneticQuantumNumberType::Label, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MagneticQuantumNumberType::Label);
	soap_embedded(soap, &this->ns2__MagneticQuantumNumberType::Value, SOAP_TYPE_ns2__AngularMomentumProjectionType);
	soap_serialize_ns2__AngularMomentumProjectionType(soap, &this->ns2__MagneticQuantumNumberType::Value);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MagneticQuantumNumberType::Comment);
	/* transient soap skipped */
}

int ns2__MagneticQuantumNumberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MagneticQuantumNumberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MagneticQuantumNumberType(struct soap *soap, const char *tag, int id, const ns2__MagneticQuantumNumberType *a, const char *type)
{
	if (((ns2__MagneticQuantumNumberType*)a)->quantumNumberID)
		soap_set_attr(soap, "quantumNumberID", ((ns2__MagneticQuantumNumberType*)a)->quantumNumberID->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MagneticQuantumNumberType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Label", -1, &(a->ns2__MagneticQuantumNumberType::Label), ""))
		return soap->error;
	if (soap_out_ns2__AngularMomentumProjectionType(soap, "ns2:Value", -1, &(a->ns2__MagneticQuantumNumberType::Value), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__MagneticQuantumNumberType::Comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MagneticQuantumNumberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MagneticQuantumNumberType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MagneticQuantumNumberType * SOAP_FMAC4 soap_in_ns2__MagneticQuantumNumberType(struct soap *soap, const char *tag, ns2__MagneticQuantumNumberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MagneticQuantumNumberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MagneticQuantumNumberType, sizeof(ns2__MagneticQuantumNumberType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MagneticQuantumNumberType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MagneticQuantumNumberType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "quantumNumberID", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__MagneticQuantumNumberType*)a)->quantumNumberID = soap_new_std__string(soap, -1);
				((ns2__MagneticQuantumNumberType*)a)->quantumNumberID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Label1 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Label", &(a->ns2__MagneticQuantumNumberType::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__AngularMomentumProjectionType(soap, "ns2:Value", &(a->ns2__MagneticQuantumNumberType::Value), "ns2:AngularMomentumProjectionType"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__MagneticQuantumNumberType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MagneticQuantumNumberType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MagneticQuantumNumberType, 0, sizeof(ns2__MagneticQuantumNumberType), 0, soap_copy_ns2__MagneticQuantumNumberType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Label1 > 0 || soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MagneticQuantumNumberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MagneticQuantumNumberType);
	if (this->soap_out(soap, tag?tag:"ns2:MagneticQuantumNumberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MagneticQuantumNumberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MagneticQuantumNumberType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MagneticQuantumNumberType * SOAP_FMAC4 soap_get_ns2__MagneticQuantumNumberType(struct soap *soap, ns2__MagneticQuantumNumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MagneticQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MagneticQuantumNumberType * SOAP_FMAC2 soap_instantiate_ns2__MagneticQuantumNumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MagneticQuantumNumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MagneticQuantumNumberType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MagneticQuantumNumberType);
		if (size)
			*size = sizeof(ns2__MagneticQuantumNumberType);
		((ns2__MagneticQuantumNumberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MagneticQuantumNumberType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MagneticQuantumNumberType);
		for (int i = 0; i < n; i++)
			((ns2__MagneticQuantumNumberType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MagneticQuantumNumberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MagneticQuantumNumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MagneticQuantumNumberType %p -> %p\n", q, p));
	*(ns2__MagneticQuantumNumberType*)p = *(ns2__MagneticQuantumNumberType*)q;
}

void ns2__MolecularQuantumNumberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__MolecularQuantumNumberType::Label);
	soap_default_ns2__AngularMomentumType(soap, &this->ns2__MolecularQuantumNumberType::Value);
	this->ns2__MolecularQuantumNumberType::Comment = NULL;
	this->ns2__MolecularQuantumNumberType::quantumNumberID = NULL;
	/* transient soap skipped */
}

void ns2__MolecularQuantumNumberType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MolecularQuantumNumberType::Label, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MolecularQuantumNumberType::Label);
	soap_embedded(soap, &this->ns2__MolecularQuantumNumberType::Value, SOAP_TYPE_ns2__AngularMomentumType);
	soap_serialize_ns2__AngularMomentumType(soap, &this->ns2__MolecularQuantumNumberType::Value);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MolecularQuantumNumberType::Comment);
	/* transient soap skipped */
}

int ns2__MolecularQuantumNumberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularQuantumNumberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularQuantumNumberType(struct soap *soap, const char *tag, int id, const ns2__MolecularQuantumNumberType *a, const char *type)
{
	if (((ns2__MolecularQuantumNumberType*)a)->quantumNumberID)
		soap_set_attr(soap, "quantumNumberID", ((ns2__MolecularQuantumNumberType*)a)->quantumNumberID->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularQuantumNumberType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Label", -1, &(a->ns2__MolecularQuantumNumberType::Label), ""))
		return soap->error;
	if (soap_out_ns2__AngularMomentumType(soap, "ns2:Value", -1, &(a->ns2__MolecularQuantumNumberType::Value), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__MolecularQuantumNumberType::Comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularQuantumNumberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularQuantumNumberType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularQuantumNumberType * SOAP_FMAC4 soap_in_ns2__MolecularQuantumNumberType(struct soap *soap, const char *tag, ns2__MolecularQuantumNumberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularQuantumNumberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularQuantumNumberType, sizeof(ns2__MolecularQuantumNumberType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularQuantumNumberType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularQuantumNumberType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "quantumNumberID", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__MolecularQuantumNumberType*)a)->quantumNumberID = soap_new_std__string(soap, -1);
				((ns2__MolecularQuantumNumberType*)a)->quantumNumberID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Label1 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Label", &(a->ns2__MolecularQuantumNumberType::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__AngularMomentumType(soap, "ns2:Value", &(a->ns2__MolecularQuantumNumberType::Value), "ns2:AngularMomentumType"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__MolecularQuantumNumberType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularQuantumNumberType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularQuantumNumberType, 0, sizeof(ns2__MolecularQuantumNumberType), 0, soap_copy_ns2__MolecularQuantumNumberType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Label1 > 0 || soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MolecularQuantumNumberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularQuantumNumberType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularQuantumNumberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularQuantumNumberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularQuantumNumberType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularQuantumNumberType * SOAP_FMAC4 soap_get_ns2__MolecularQuantumNumberType(struct soap *soap, ns2__MolecularQuantumNumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularQuantumNumberType * SOAP_FMAC2 soap_instantiate_ns2__MolecularQuantumNumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularQuantumNumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularQuantumNumberType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:ComplexMolecularQuantumNumberType"))
	{	cp->type = SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ComplexMolecularQuantumNumberType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ComplexMolecularQuantumNumberType);
			((ns2__ComplexMolecularQuantumNumberType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ComplexMolecularQuantumNumberType[n]);
			if (size)
				*size = n * sizeof(ns2__ComplexMolecularQuantumNumberType);
			for (int i = 0; i < n; i++)
				((ns2__ComplexMolecularQuantumNumberType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ComplexMolecularQuantumNumberType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularQuantumNumberType);
		if (size)
			*size = sizeof(ns2__MolecularQuantumNumberType);
		((ns2__MolecularQuantumNumberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularQuantumNumberType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularQuantumNumberType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularQuantumNumberType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularQuantumNumberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularQuantumNumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularQuantumNumberType %p -> %p\n", q, p));
	*(ns2__MolecularQuantumNumberType*)p = *(ns2__MolecularQuantumNumberType*)q;
}

void ns2__RoVibronicSplittingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(soap, &this->ns2__RoVibronicSplittingType::__RoVibronicSplittingType_sequence);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__RoVibronicSplittingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(soap, &this->ns2__RoVibronicSplittingType::__RoVibronicSplittingType_sequence);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__RoVibronicSplittingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RoVibronicSplittingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RoVibronicSplittingType(struct soap *soap, const char *tag, int id, const ns2__RoVibronicSplittingType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RoVibronicSplittingType), "ns2:RoVibronicSplittingType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(soap, "-RoVibronicSplittingType-sequence", -1, &(a->ns2__RoVibronicSplittingType::__RoVibronicSplittingType_sequence), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RoVibronicSplittingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RoVibronicSplittingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RoVibronicSplittingType * SOAP_FMAC4 soap_in_ns2__RoVibronicSplittingType(struct soap *soap, const char *tag, ns2__RoVibronicSplittingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RoVibronicSplittingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RoVibronicSplittingType, sizeof(ns2__RoVibronicSplittingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RoVibronicSplittingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RoVibronicSplittingType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(soap, "-RoVibronicSplittingType-sequence", &(a->ns2__RoVibronicSplittingType::__RoVibronicSplittingType_sequence), "-ns2:RoVibronicSplittingType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RoVibronicSplittingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RoVibronicSplittingType, 0, sizeof(ns2__RoVibronicSplittingType), 0, soap_copy_ns2__RoVibronicSplittingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__RoVibronicSplittingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RoVibronicSplittingType);
	if (this->soap_out(soap, tag?tag:"ns2:RoVibronicSplittingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RoVibronicSplittingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RoVibronicSplittingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RoVibronicSplittingType * SOAP_FMAC4 soap_get_ns2__RoVibronicSplittingType(struct soap *soap, ns2__RoVibronicSplittingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RoVibronicSplittingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RoVibronicSplittingType * SOAP_FMAC2 soap_instantiate_ns2__RoVibronicSplittingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RoVibronicSplittingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RoVibronicSplittingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RoVibronicSplittingType);
		if (size)
			*size = sizeof(ns2__RoVibronicSplittingType);
		((ns2__RoVibronicSplittingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RoVibronicSplittingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RoVibronicSplittingType);
		for (int i = 0; i < n; i++)
			((ns2__RoVibronicSplittingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RoVibronicSplittingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RoVibronicSplittingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RoVibronicSplittingType %p -> %p\n", q, p));
	*(ns2__RoVibronicSplittingType*)p = *(ns2__RoVibronicSplittingType*)q;
}

void ns2__PseudoStatisticalWeightType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->ns2__PseudoStatisticalWeightType::Value);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__PseudoStatisticalWeightType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__PseudoStatisticalWeightType::Value, SOAP_TYPE_xsd__positiveInteger);
	soap_serialize_xsd__positiveInteger(soap, &this->ns2__PseudoStatisticalWeightType::Value);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__PseudoStatisticalWeightType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PseudoStatisticalWeightType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PseudoStatisticalWeightType(struct soap *soap, const char *tag, int id, const ns2__PseudoStatisticalWeightType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PseudoStatisticalWeightType), "ns2:PseudoStatisticalWeightType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__positiveInteger(soap, "ns2:Value", -1, &(a->ns2__PseudoStatisticalWeightType::Value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PseudoStatisticalWeightType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PseudoStatisticalWeightType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PseudoStatisticalWeightType * SOAP_FMAC4 soap_in_ns2__PseudoStatisticalWeightType(struct soap *soap, const char *tag, ns2__PseudoStatisticalWeightType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PseudoStatisticalWeightType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PseudoStatisticalWeightType, sizeof(ns2__PseudoStatisticalWeightType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PseudoStatisticalWeightType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PseudoStatisticalWeightType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns2:Value", &(a->ns2__PseudoStatisticalWeightType::Value), "xsd:positiveInteger"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PseudoStatisticalWeightType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PseudoStatisticalWeightType, 0, sizeof(ns2__PseudoStatisticalWeightType), 0, soap_copy_ns2__PseudoStatisticalWeightType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PseudoStatisticalWeightType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PseudoStatisticalWeightType);
	if (this->soap_out(soap, tag?tag:"ns2:PseudoStatisticalWeightType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PseudoStatisticalWeightType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PseudoStatisticalWeightType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PseudoStatisticalWeightType * SOAP_FMAC4 soap_get_ns2__PseudoStatisticalWeightType(struct soap *soap, ns2__PseudoStatisticalWeightType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PseudoStatisticalWeightType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PseudoStatisticalWeightType * SOAP_FMAC2 soap_instantiate_ns2__PseudoStatisticalWeightType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PseudoStatisticalWeightType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PseudoStatisticalWeightType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PseudoStatisticalWeightType);
		if (size)
			*size = sizeof(ns2__PseudoStatisticalWeightType);
		((ns2__PseudoStatisticalWeightType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PseudoStatisticalWeightType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PseudoStatisticalWeightType);
		for (int i = 0; i < n; i++)
			((ns2__PseudoStatisticalWeightType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PseudoStatisticalWeightType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PseudoStatisticalWeightType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PseudoStatisticalWeightType %p -> %p\n", q, p));
	*(ns2__PseudoStatisticalWeightType*)p = *(ns2__PseudoStatisticalWeightType*)q;
}

void ns2__RotationalHomeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RotationalHomeType::Description = NULL;
	this->ns2__RotationalHomeType::RotationalCharacterisation = NULL;
	this->ns2__RotationalHomeType::Comment = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__RotationalComponentType(soap, &this->ns2__RotationalHomeType::RotationalComponent);
	/* transient soap skipped */
}

void ns2__RotationalHomeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__RotationalHomeType::Description);
	soap_serialize_PointerTons2__RotationalCharacterisationType(soap, &this->ns2__RotationalHomeType::RotationalCharacterisation);
	soap_serialize_PointerTostd__string(soap, &this->ns2__RotationalHomeType::Comment);
	soap_serialize_std__vectorTemplateOfPointerTons2__RotationalComponentType(soap, &this->ns2__RotationalHomeType::RotationalComponent);
	/* transient soap skipped */
}

int ns2__RotationalHomeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RotationalHomeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RotationalHomeType(struct soap *soap, const char *tag, int id, const ns2__RotationalHomeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RotationalHomeType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__RotationalHomeType::Description), ""))
		return soap->error;
	if (soap_out_PointerTons2__RotationalCharacterisationType(soap, "ns2:RotationalCharacterisation", -1, &(a->ns2__RotationalHomeType::RotationalCharacterisation), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__RotationalHomeType::Comment), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__RotationalComponentType(soap, "ns2:RotationalComponent", -1, &(a->ns2__RotationalHomeType::RotationalComponent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RotationalHomeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RotationalHomeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RotationalHomeType * SOAP_FMAC4 soap_in_ns2__RotationalHomeType(struct soap *soap, const char *tag, ns2__RotationalHomeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RotationalHomeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RotationalHomeType, sizeof(ns2__RotationalHomeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RotationalHomeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RotationalHomeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_RotationalCharacterisation1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__RotationalHomeType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_RotationalCharacterisation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RotationalCharacterisationType(soap, "ns2:RotationalCharacterisation", &(a->ns2__RotationalHomeType::RotationalCharacterisation), "ns2:RotationalCharacterisationType"))
				{	soap_flag_RotationalCharacterisation1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__RotationalHomeType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__RotationalComponentType(soap, "ns2:RotationalComponent", &(a->ns2__RotationalHomeType::RotationalComponent), "ns2:RotationalComponentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RotationalHomeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RotationalHomeType, 0, sizeof(ns2__RotationalHomeType), 0, soap_copy_ns2__RotationalHomeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__RotationalHomeType::RotationalComponent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RotationalHomeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RotationalHomeType);
	if (this->soap_out(soap, tag?tag:"ns2:RotationalHomeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RotationalHomeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RotationalHomeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RotationalHomeType * SOAP_FMAC4 soap_get_ns2__RotationalHomeType(struct soap *soap, ns2__RotationalHomeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RotationalHomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RotationalHomeType * SOAP_FMAC2 soap_instantiate_ns2__RotationalHomeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RotationalHomeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RotationalHomeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RotationalHomeType);
		if (size)
			*size = sizeof(ns2__RotationalHomeType);
		((ns2__RotationalHomeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RotationalHomeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RotationalHomeType);
		for (int i = 0; i < n; i++)
			((ns2__RotationalHomeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RotationalHomeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RotationalHomeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RotationalHomeType %p -> %p\n", q, p));
	*(ns2__RotationalHomeType*)p = *(ns2__RotationalHomeType*)q;
}

void ns2__RotationalComponentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RotationalComponentType::__union_RotationalComponentType = 0;
	this->ns2__RotationalComponentType::MixingCoefficient = NULL;
	this->ns2__RotationalComponentType::SerialQuantumNumber = NULL;
	/* transient soap skipped */
}

void ns2__RotationalComponentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_RotationalComponentType(soap, this->ns2__RotationalComponentType::__union_RotationalComponentType, &this->ns2__RotationalComponentType::union_RotationalComponentType);
	soap_serialize_PointerTons2__MixingCoefficientType(soap, &this->ns2__RotationalComponentType::MixingCoefficient);
	soap_serialize_PointerTostd__string(soap, &this->ns2__RotationalComponentType::SerialQuantumNumber);
	/* transient soap skipped */
}

int ns2__RotationalComponentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RotationalComponentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RotationalComponentType(struct soap *soap, const char *tag, int id, const ns2__RotationalComponentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RotationalComponentType), type))
		return soap->error;
	if (soap_out__ns2__union_RotationalComponentType(soap, a->ns2__RotationalComponentType::__union_RotationalComponentType, &a->ns2__RotationalComponentType::union_RotationalComponentType))
		return soap->error;
	if (soap_out_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", -1, &(a->ns2__RotationalComponentType::MixingCoefficient), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:SerialQuantumNumber", -1, &(a->ns2__RotationalComponentType::SerialQuantumNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RotationalComponentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RotationalComponentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RotationalComponentType * SOAP_FMAC4 soap_in_ns2__RotationalComponentType(struct soap *soap, const char *tag, ns2__RotationalComponentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RotationalComponentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RotationalComponentType, sizeof(ns2__RotationalComponentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RotationalComponentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RotationalComponentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_union_RotationalComponentType1 = 1;
	size_t soap_flag_MixingCoefficient1 = 1;
	size_t soap_flag_SerialQuantumNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_RotationalComponentType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_RotationalComponentType(soap, &a->ns2__RotationalComponentType::__union_RotationalComponentType, &a->ns2__RotationalComponentType::union_RotationalComponentType))
				{	soap_flag_union_RotationalComponentType1 = 0;
					continue;
				}
			if (soap_flag_MixingCoefficient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", &(a->ns2__RotationalComponentType::MixingCoefficient), "ns2:MixingCoefficientType"))
				{	soap_flag_MixingCoefficient1--;
					continue;
				}
			if (soap_flag_SerialQuantumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:SerialQuantumNumber", &(a->ns2__RotationalComponentType::SerialQuantumNumber), "xsd:string"))
				{	soap_flag_SerialQuantumNumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RotationalComponentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RotationalComponentType, 0, sizeof(ns2__RotationalComponentType), 0, soap_copy_ns2__RotationalComponentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_RotationalComponentType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RotationalComponentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RotationalComponentType);
	if (this->soap_out(soap, tag?tag:"ns2:RotationalComponentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RotationalComponentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RotationalComponentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RotationalComponentType * SOAP_FMAC4 soap_get_ns2__RotationalComponentType(struct soap *soap, ns2__RotationalComponentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RotationalComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RotationalComponentType * SOAP_FMAC2 soap_instantiate_ns2__RotationalComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RotationalComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RotationalComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RotationalComponentType);
		if (size)
			*size = sizeof(ns2__RotationalComponentType);
		((ns2__RotationalComponentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RotationalComponentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RotationalComponentType);
		for (int i = 0; i < n; i++)
			((ns2__RotationalComponentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RotationalComponentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RotationalComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RotationalComponentType %p -> %p\n", q, p));
	*(ns2__RotationalComponentType*)p = *(ns2__RotationalComponentType*)q;
}

void ns2__RotationalCharacterisationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RotationalCharacterisationType::RovibrationalSpeciesNotation = NULL;
	this->ns2__RotationalCharacterisationType::RovibronicSpeciesNotation = NULL;
	this->ns2__RotationalCharacterisationType::RovibronicAngularMomentumP = NULL;
	this->ns2__RotationalCharacterisationType::PermutationSymmetry = NULL;
	this->ns2__RotationalCharacterisationType::InversionSymmetry = NULL;
	/* transient soap skipped */
}

void ns2__RotationalCharacterisationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__RotationalCharacterisationType::RovibrationalSpeciesNotation);
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__RotationalCharacterisationType::RovibronicSpeciesNotation);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__RotationalCharacterisationType::RovibronicAngularMomentumP);
	soap_serialize_PointerTons2__PermutationSymmetryType(soap, &this->ns2__RotationalCharacterisationType::PermutationSymmetry);
	soap_serialize_PointerTons2__PermutationSymmetryType(soap, &this->ns2__RotationalCharacterisationType::InversionSymmetry);
	/* transient soap skipped */
}

int ns2__RotationalCharacterisationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RotationalCharacterisationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RotationalCharacterisationType(struct soap *soap, const char *tag, int id, const ns2__RotationalCharacterisationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RotationalCharacterisationType), type))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:RovibrationalSpeciesNotation", -1, &(a->ns2__RotationalCharacterisationType::RovibrationalSpeciesNotation), ""))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:RovibronicSpeciesNotation", -1, &(a->ns2__RotationalCharacterisationType::RovibronicSpeciesNotation), ""))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:RovibronicAngularMomentumP", -1, &(a->ns2__RotationalCharacterisationType::RovibronicAngularMomentumP), ""))
		return soap->error;
	if (soap_out_PointerTons2__PermutationSymmetryType(soap, "ns2:PermutationSymmetry", -1, &(a->ns2__RotationalCharacterisationType::PermutationSymmetry), ""))
		return soap->error;
	if (soap_out_PointerTons2__PermutationSymmetryType(soap, "ns2:InversionSymmetry", -1, &(a->ns2__RotationalCharacterisationType::InversionSymmetry), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RotationalCharacterisationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RotationalCharacterisationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RotationalCharacterisationType * SOAP_FMAC4 soap_in_ns2__RotationalCharacterisationType(struct soap *soap, const char *tag, ns2__RotationalCharacterisationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RotationalCharacterisationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RotationalCharacterisationType, sizeof(ns2__RotationalCharacterisationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RotationalCharacterisationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RotationalCharacterisationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RovibrationalSpeciesNotation1 = 1;
	size_t soap_flag_RovibronicSpeciesNotation1 = 1;
	size_t soap_flag_RovibronicAngularMomentumP1 = 1;
	size_t soap_flag_PermutationSymmetry1 = 1;
	size_t soap_flag_InversionSymmetry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RovibrationalSpeciesNotation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:RovibrationalSpeciesNotation", &(a->ns2__RotationalCharacterisationType::RovibrationalSpeciesNotation), "ns2:SymbolType"))
				{	soap_flag_RovibrationalSpeciesNotation1--;
					continue;
				}
			if (soap_flag_RovibronicSpeciesNotation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:RovibronicSpeciesNotation", &(a->ns2__RotationalCharacterisationType::RovibronicSpeciesNotation), "ns2:SymbolType"))
				{	soap_flag_RovibronicSpeciesNotation1--;
					continue;
				}
			if (soap_flag_RovibronicAngularMomentumP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:RovibronicAngularMomentumP", &(a->ns2__RotationalCharacterisationType::RovibronicAngularMomentumP), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_RovibronicAngularMomentumP1--;
					continue;
				}
			if (soap_flag_PermutationSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PermutationSymmetryType(soap, "ns2:PermutationSymmetry", &(a->ns2__RotationalCharacterisationType::PermutationSymmetry), "ns2:PermutationSymmetryType"))
				{	soap_flag_PermutationSymmetry1--;
					continue;
				}
			if (soap_flag_InversionSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PermutationSymmetryType(soap, "ns2:InversionSymmetry", &(a->ns2__RotationalCharacterisationType::InversionSymmetry), "ns2:PermutationSymmetryType"))
				{	soap_flag_InversionSymmetry1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RotationalCharacterisationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RotationalCharacterisationType, 0, sizeof(ns2__RotationalCharacterisationType), 0, soap_copy_ns2__RotationalCharacterisationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__RotationalCharacterisationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RotationalCharacterisationType);
	if (this->soap_out(soap, tag?tag:"ns2:RotationalCharacterisationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RotationalCharacterisationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RotationalCharacterisationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RotationalCharacterisationType * SOAP_FMAC4 soap_get_ns2__RotationalCharacterisationType(struct soap *soap, ns2__RotationalCharacterisationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RotationalCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RotationalCharacterisationType * SOAP_FMAC2 soap_instantiate_ns2__RotationalCharacterisationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RotationalCharacterisationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RotationalCharacterisationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RotationalCharacterisationType);
		if (size)
			*size = sizeof(ns2__RotationalCharacterisationType);
		((ns2__RotationalCharacterisationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RotationalCharacterisationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RotationalCharacterisationType);
		for (int i = 0; i < n; i++)
			((ns2__RotationalCharacterisationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RotationalCharacterisationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RotationalCharacterisationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RotationalCharacterisationType %p -> %p\n", q, p));
	*(ns2__RotationalCharacterisationType*)p = *(ns2__RotationalCharacterisationType*)q;
}

void ns2__NonLinearPolyatomicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NonLinearPolyatomicType::__union_NonLinearPolyatomicType = 0;
	/* transient soap skipped */
}

void ns2__NonLinearPolyatomicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_NonLinearPolyatomicType(soap, this->ns2__NonLinearPolyatomicType::__union_NonLinearPolyatomicType, &this->ns2__NonLinearPolyatomicType::union_NonLinearPolyatomicType);
	/* transient soap skipped */
}

int ns2__NonLinearPolyatomicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NonLinearPolyatomicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NonLinearPolyatomicType(struct soap *soap, const char *tag, int id, const ns2__NonLinearPolyatomicType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NonLinearPolyatomicType), type))
		return soap->error;
	if (soap_out__ns2__union_NonLinearPolyatomicType(soap, a->ns2__NonLinearPolyatomicType::__union_NonLinearPolyatomicType, &a->ns2__NonLinearPolyatomicType::union_NonLinearPolyatomicType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NonLinearPolyatomicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NonLinearPolyatomicType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NonLinearPolyatomicType * SOAP_FMAC4 soap_in_ns2__NonLinearPolyatomicType(struct soap *soap, const char *tag, ns2__NonLinearPolyatomicType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NonLinearPolyatomicType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NonLinearPolyatomicType, sizeof(ns2__NonLinearPolyatomicType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns2__union_NonLinearPolyatomicType(soap, &a->__union_NonLinearPolyatomicType, &a->union_NonLinearPolyatomicType))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NonLinearPolyatomicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NonLinearPolyatomicType, 0, sizeof(ns2__NonLinearPolyatomicType), 0, soap_copy_ns2__NonLinearPolyatomicType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__NonLinearPolyatomicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NonLinearPolyatomicType);
	if (this->soap_out(soap, tag?tag:"ns2:NonLinearPolyatomicType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NonLinearPolyatomicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NonLinearPolyatomicType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NonLinearPolyatomicType * SOAP_FMAC4 soap_get_ns2__NonLinearPolyatomicType(struct soap *soap, ns2__NonLinearPolyatomicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NonLinearPolyatomicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NonLinearPolyatomicType * SOAP_FMAC2 soap_instantiate_ns2__NonLinearPolyatomicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NonLinearPolyatomicType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NonLinearPolyatomicType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearPolyatomicType);
		if (size)
			*size = sizeof(ns2__NonLinearPolyatomicType);
		((ns2__NonLinearPolyatomicType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NonLinearPolyatomicType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NonLinearPolyatomicType);
		for (int i = 0; i < n; i++)
			((ns2__NonLinearPolyatomicType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NonLinearPolyatomicType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NonLinearPolyatomicType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NonLinearPolyatomicType %p -> %p\n", q, p));
	*(ns2__NonLinearPolyatomicType*)p = *(ns2__NonLinearPolyatomicType*)q;
}

void ns2__MoleculesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__MoleculeType(soap, &this->ns2__MoleculesType::Molecule);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__MoleculesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__MoleculeType(soap, &this->ns2__MoleculesType::Molecule);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__MoleculesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MoleculesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MoleculesType(struct soap *soap, const char *tag, int id, const ns2__MoleculesType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MoleculesType), "ns2:MoleculesType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__MoleculeType(soap, "ns2:Molecule", -1, &(a->ns2__MoleculesType::Molecule), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MoleculesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MoleculesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MoleculesType * SOAP_FMAC4 soap_in_ns2__MoleculesType(struct soap *soap, const char *tag, ns2__MoleculesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MoleculesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MoleculesType, sizeof(ns2__MoleculesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MoleculesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MoleculesType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MoleculeType(soap, "ns2:Molecule", &(a->ns2__MoleculesType::Molecule), "ns2:MoleculeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MoleculesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MoleculesType, 0, sizeof(ns2__MoleculesType), 0, soap_copy_ns2__MoleculesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__MoleculesType::Molecule.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MoleculesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MoleculesType);
	if (this->soap_out(soap, tag?tag:"ns2:MoleculesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MoleculesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MoleculesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MoleculesType * SOAP_FMAC4 soap_get_ns2__MoleculesType(struct soap *soap, ns2__MoleculesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MoleculesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MoleculesType * SOAP_FMAC2 soap_instantiate_ns2__MoleculesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MoleculesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MoleculesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculesType);
		if (size)
			*size = sizeof(ns2__MoleculesType);
		((ns2__MoleculesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MoleculesType);
		for (int i = 0; i < n; i++)
			((ns2__MoleculesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MoleculesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MoleculesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MoleculesType %p -> %p\n", q, p));
	*(ns2__MoleculesType*)p = *(ns2__MoleculesType*)q;
}

void ns2__MoleculeNuclearSpinsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MoleculeNuclearSpinsType::AtomArray = NULL;
	this->ns2__MoleculeNuclearSpinsType::BondArray = NULL;
	/* transient soap skipped */
}

void ns2__MoleculeNuclearSpinsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AtomArrayType(soap, &this->ns2__MoleculeNuclearSpinsType::AtomArray);
	soap_serialize_PointerTons2__BondArrayType(soap, &this->ns2__MoleculeNuclearSpinsType::BondArray);
	/* transient soap skipped */
}

int ns2__MoleculeNuclearSpinsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MoleculeNuclearSpinsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MoleculeNuclearSpinsType(struct soap *soap, const char *tag, int id, const ns2__MoleculeNuclearSpinsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MoleculeNuclearSpinsType), type))
		return soap->error;
	if (a->ns2__MoleculeNuclearSpinsType::AtomArray)
	{	if (soap_out_PointerTons2__AtomArrayType(soap, "ns2:AtomArray", -1, &a->ns2__MoleculeNuclearSpinsType::AtomArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:AtomArray"))
		return soap->error;
	if (soap_out_PointerTons2__BondArrayType(soap, "ns2:BondArray", -1, &(a->ns2__MoleculeNuclearSpinsType::BondArray), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MoleculeNuclearSpinsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MoleculeNuclearSpinsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MoleculeNuclearSpinsType * SOAP_FMAC4 soap_in_ns2__MoleculeNuclearSpinsType(struct soap *soap, const char *tag, ns2__MoleculeNuclearSpinsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MoleculeNuclearSpinsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MoleculeNuclearSpinsType, sizeof(ns2__MoleculeNuclearSpinsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MoleculeNuclearSpinsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MoleculeNuclearSpinsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AtomArray1 = 1;
	size_t soap_flag_BondArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AtomArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomArrayType(soap, "ns2:AtomArray", &(a->ns2__MoleculeNuclearSpinsType::AtomArray), "ns2:AtomArrayType"))
				{	soap_flag_AtomArray1--;
					continue;
				}
			if (soap_flag_BondArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BondArrayType(soap, "ns2:BondArray", &(a->ns2__MoleculeNuclearSpinsType::BondArray), "ns2:BondArrayType"))
				{	soap_flag_BondArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MoleculeNuclearSpinsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MoleculeNuclearSpinsType, 0, sizeof(ns2__MoleculeNuclearSpinsType), 0, soap_copy_ns2__MoleculeNuclearSpinsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AtomArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MoleculeNuclearSpinsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MoleculeNuclearSpinsType);
	if (this->soap_out(soap, tag?tag:"ns2:MoleculeNuclearSpinsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MoleculeNuclearSpinsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MoleculeNuclearSpinsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MoleculeNuclearSpinsType * SOAP_FMAC4 soap_get_ns2__MoleculeNuclearSpinsType(struct soap *soap, ns2__MoleculeNuclearSpinsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MoleculeNuclearSpinsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MoleculeNuclearSpinsType * SOAP_FMAC2 soap_instantiate_ns2__MoleculeNuclearSpinsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MoleculeNuclearSpinsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MoleculeNuclearSpinsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculeNuclearSpinsType);
		if (size)
			*size = sizeof(ns2__MoleculeNuclearSpinsType);
		((ns2__MoleculeNuclearSpinsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculeNuclearSpinsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MoleculeNuclearSpinsType);
		for (int i = 0; i < n; i++)
			((ns2__MoleculeNuclearSpinsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MoleculeNuclearSpinsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MoleculeNuclearSpinsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MoleculeNuclearSpinsType %p -> %p\n", q, p));
	*(ns2__MoleculeNuclearSpinsType*)p = *(ns2__MoleculeNuclearSpinsType*)q;
}

void ns2__MoleculeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MoleculeType::MolecularChemicalSpecies = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__MolecularStateType(soap, &this->ns2__MoleculeType::MolecularState);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__MoleculeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularChemicalSpeciesType(soap, &this->ns2__MoleculeType::MolecularChemicalSpecies);
	soap_serialize_std__vectorTemplateOfPointerTons2__MolecularStateType(soap, &this->ns2__MoleculeType::MolecularState);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__MoleculeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MoleculeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MoleculeType(struct soap *soap, const char *tag, int id, const ns2__MoleculeType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MoleculeType), "ns2:MoleculeType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__MoleculeType::MolecularChemicalSpecies)
	{	if (soap_out_PointerTons2__MolecularChemicalSpeciesType(soap, "ns2:MolecularChemicalSpecies", -1, &a->ns2__MoleculeType::MolecularChemicalSpecies, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MolecularChemicalSpecies"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__MolecularStateType(soap, "ns2:MolecularState", -1, &(a->ns2__MoleculeType::MolecularState), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MoleculeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MoleculeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MoleculeType * SOAP_FMAC4 soap_in_ns2__MoleculeType(struct soap *soap, const char *tag, ns2__MoleculeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MoleculeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MoleculeType, sizeof(ns2__MoleculeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MoleculeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MoleculeType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_MolecularChemicalSpecies1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_MolecularChemicalSpecies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularChemicalSpeciesType(soap, "ns2:MolecularChemicalSpecies", &(a->ns2__MoleculeType::MolecularChemicalSpecies), "ns2:MolecularChemicalSpeciesType"))
				{	soap_flag_MolecularChemicalSpecies1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MolecularStateType(soap, "ns2:MolecularState", &(a->ns2__MoleculeType::MolecularState), "ns2:MolecularStateType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MoleculeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MoleculeType, 0, sizeof(ns2__MoleculeType), 0, soap_copy_ns2__MoleculeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MolecularChemicalSpecies1 > 0 || a->ns2__MoleculeType::MolecularState.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MoleculeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MoleculeType);
	if (this->soap_out(soap, tag?tag:"ns2:MoleculeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MoleculeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MoleculeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MoleculeType * SOAP_FMAC4 soap_get_ns2__MoleculeType(struct soap *soap, ns2__MoleculeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MoleculeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MoleculeType * SOAP_FMAC2 soap_instantiate_ns2__MoleculeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MoleculeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MoleculeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculeType);
		if (size)
			*size = sizeof(ns2__MoleculeType);
		((ns2__MoleculeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MoleculeType);
		for (int i = 0; i < n; i++)
			((ns2__MoleculeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MoleculeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MoleculeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MoleculeType %p -> %p\n", q, p));
	*(ns2__MoleculeType*)p = *(ns2__MoleculeType*)q;
}

void ns2__MolecularStateCharacterisation_oldType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MolecularStateCharacterisation_oldType::StateEnergy = NULL;
	this->ns2__MolecularStateCharacterisation_oldType::TotalStatisticalWeight = NULL;
	this->ns2__MolecularStateCharacterisation_oldType::NuclearStatisticalWeight = NULL;
	this->ns2__MolecularStateCharacterisation_oldType::PseudoStatisticalWeight = NULL;
	this->ns2__MolecularStateCharacterisation_oldType::PseudoNuclearStatisticalWeight = NULL;
	this->ns2__MolecularStateCharacterisation_oldType::NuclearSpinSymmetry = NULL;
	this->ns2__MolecularStateCharacterisation_oldType::LifeTime = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, &this->ns2__MolecularStateCharacterisation_oldType::Parameters);
	/* transient soap skipped */
}

void ns2__MolecularStateCharacterisation_oldType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__StateEnergyType(soap, &this->ns2__MolecularStateCharacterisation_oldType::StateEnergy);
	soap_serialize_PointerToxsd__positiveInteger(soap, &this->ns2__MolecularStateCharacterisation_oldType::TotalStatisticalWeight);
	soap_serialize_PointerToxsd__positiveInteger(soap, &this->ns2__MolecularStateCharacterisation_oldType::NuclearStatisticalWeight);
	soap_serialize_PointerTons2__PseudoStatisticalWeightType(soap, &this->ns2__MolecularStateCharacterisation_oldType::PseudoStatisticalWeight);
	soap_serialize_PointerTons2__PseudoStatisticalWeightType(soap, &this->ns2__MolecularStateCharacterisation_oldType::PseudoNuclearStatisticalWeight);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MolecularStateCharacterisation_oldType::NuclearSpinSymmetry);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__MolecularStateCharacterisation_oldType::LifeTime);
	soap_serialize_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, &this->ns2__MolecularStateCharacterisation_oldType::Parameters);
	/* transient soap skipped */
}

int ns2__MolecularStateCharacterisation_oldType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularStateCharacterisation_oldType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularStateCharacterisation_oldType(struct soap *soap, const char *tag, int id, const ns2__MolecularStateCharacterisation_oldType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType), type))
		return soap->error;
	if (soap_out_PointerTons2__StateEnergyType(soap, "ns2:StateEnergy", -1, &(a->ns2__MolecularStateCharacterisation_oldType::StateEnergy), ""))
		return soap->error;
	if (soap_out_PointerToxsd__positiveInteger(soap, "ns2:TotalStatisticalWeight", -1, &(a->ns2__MolecularStateCharacterisation_oldType::TotalStatisticalWeight), ""))
		return soap->error;
	if (soap_out_PointerToxsd__positiveInteger(soap, "ns2:NuclearStatisticalWeight", -1, &(a->ns2__MolecularStateCharacterisation_oldType::NuclearStatisticalWeight), ""))
		return soap->error;
	if (soap_out_PointerTons2__PseudoStatisticalWeightType(soap, "ns2:PseudoStatisticalWeight", -1, &(a->ns2__MolecularStateCharacterisation_oldType::PseudoStatisticalWeight), ""))
		return soap->error;
	if (soap_out_PointerTons2__PseudoStatisticalWeightType(soap, "ns2:PseudoNuclearStatisticalWeight", -1, &(a->ns2__MolecularStateCharacterisation_oldType::PseudoNuclearStatisticalWeight), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:NuclearSpinSymmetry", -1, &(a->ns2__MolecularStateCharacterisation_oldType::NuclearSpinSymmetry), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:LifeTime", -1, &(a->ns2__MolecularStateCharacterisation_oldType::LifeTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, "ns2:Parameters", -1, &(a->ns2__MolecularStateCharacterisation_oldType::Parameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularStateCharacterisation_oldType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularStateCharacterisation_oldType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularStateCharacterisation_oldType * SOAP_FMAC4 soap_in_ns2__MolecularStateCharacterisation_oldType(struct soap *soap, const char *tag, ns2__MolecularStateCharacterisation_oldType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularStateCharacterisation_oldType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType, sizeof(ns2__MolecularStateCharacterisation_oldType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularStateCharacterisation_oldType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StateEnergy1 = 1;
	size_t soap_flag_TotalStatisticalWeight1 = 1;
	size_t soap_flag_NuclearStatisticalWeight1 = 1;
	size_t soap_flag_PseudoStatisticalWeight1 = 1;
	size_t soap_flag_PseudoNuclearStatisticalWeight1 = 1;
	size_t soap_flag_NuclearSpinSymmetry1 = 1;
	size_t soap_flag_LifeTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StateEnergy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__StateEnergyType(soap, "ns2:StateEnergy", &(a->ns2__MolecularStateCharacterisation_oldType::StateEnergy), "ns2:StateEnergyType"))
				{	soap_flag_StateEnergy1--;
					continue;
				}
			if (soap_flag_TotalStatisticalWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__positiveInteger(soap, "ns2:TotalStatisticalWeight", &(a->ns2__MolecularStateCharacterisation_oldType::TotalStatisticalWeight), "xsd:positiveInteger"))
				{	soap_flag_TotalStatisticalWeight1--;
					continue;
				}
			if (soap_flag_NuclearStatisticalWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__positiveInteger(soap, "ns2:NuclearStatisticalWeight", &(a->ns2__MolecularStateCharacterisation_oldType::NuclearStatisticalWeight), "xsd:positiveInteger"))
				{	soap_flag_NuclearStatisticalWeight1--;
					continue;
				}
			if (soap_flag_PseudoStatisticalWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PseudoStatisticalWeightType(soap, "ns2:PseudoStatisticalWeight", &(a->ns2__MolecularStateCharacterisation_oldType::PseudoStatisticalWeight), "ns2:PseudoStatisticalWeightType"))
				{	soap_flag_PseudoStatisticalWeight1--;
					continue;
				}
			if (soap_flag_PseudoNuclearStatisticalWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PseudoStatisticalWeightType(soap, "ns2:PseudoNuclearStatisticalWeight", &(a->ns2__MolecularStateCharacterisation_oldType::PseudoNuclearStatisticalWeight), "ns2:PseudoStatisticalWeightType"))
				{	soap_flag_PseudoNuclearStatisticalWeight1--;
					continue;
				}
			if (soap_flag_NuclearSpinSymmetry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:NuclearSpinSymmetry", &(a->ns2__MolecularStateCharacterisation_oldType::NuclearSpinSymmetry), "xsd:string"))
				{	soap_flag_NuclearSpinSymmetry1--;
					continue;
				}
			if (soap_flag_LifeTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:LifeTime", &(a->ns2__MolecularStateCharacterisation_oldType::LifeTime), "ns2:DataType"))
				{	soap_flag_LifeTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, "ns2:Parameters", &(a->ns2__MolecularStateCharacterisation_oldType::Parameters), "ns2:CharacterisationType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularStateCharacterisation_oldType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType, 0, sizeof(ns2__MolecularStateCharacterisation_oldType), 0, soap_copy_ns2__MolecularStateCharacterisation_oldType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__MolecularStateCharacterisation_oldType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularStateCharacterisation-oldType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularStateCharacterisation_oldType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularStateCharacterisation_oldType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularStateCharacterisation_oldType * SOAP_FMAC4 soap_get_ns2__MolecularStateCharacterisation_oldType(struct soap *soap, ns2__MolecularStateCharacterisation_oldType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularStateCharacterisation_oldType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularStateCharacterisation_oldType * SOAP_FMAC2 soap_instantiate_ns2__MolecularStateCharacterisation_oldType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularStateCharacterisation_oldType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularStateCharacterisation_oldType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateCharacterisation_oldType);
		if (size)
			*size = sizeof(ns2__MolecularStateCharacterisation_oldType);
		((ns2__MolecularStateCharacterisation_oldType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateCharacterisation_oldType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularStateCharacterisation_oldType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularStateCharacterisation_oldType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularStateCharacterisation_oldType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularStateCharacterisation_oldType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularStateCharacterisation_oldType %p -> %p\n", q, p));
	*(ns2__MolecularStateCharacterisation_oldType*)p = *(ns2__MolecularStateCharacterisation_oldType*)q;
}

void ns2__MolecularStateCharacterisationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MolecularStateCharacterisationType::StateEnergy = NULL;
	this->ns2__MolecularStateCharacterisationType::TotalStatisticalWeight = NULL;
	this->ns2__MolecularStateCharacterisationType::NuclearStatisticalWeight = NULL;
	this->ns2__MolecularStateCharacterisationType::NuclearSpinSymmetry = NULL;
	this->ns2__MolecularStateCharacterisationType::LifeTime = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, &this->ns2__MolecularStateCharacterisationType::Parameters);
	/* transient soap skipped */
}

void ns2__MolecularStateCharacterisationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__StateEnergyType(soap, &this->ns2__MolecularStateCharacterisationType::StateEnergy);
	soap_serialize_PointerToxsd__positiveInteger(soap, &this->ns2__MolecularStateCharacterisationType::TotalStatisticalWeight);
	soap_serialize_PointerToxsd__positiveInteger(soap, &this->ns2__MolecularStateCharacterisationType::NuclearStatisticalWeight);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MolecularStateCharacterisationType::NuclearSpinSymmetry);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__MolecularStateCharacterisationType::LifeTime);
	soap_serialize_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, &this->ns2__MolecularStateCharacterisationType::Parameters);
	/* transient soap skipped */
}

int ns2__MolecularStateCharacterisationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularStateCharacterisationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularStateCharacterisationType(struct soap *soap, const char *tag, int id, const ns2__MolecularStateCharacterisationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularStateCharacterisationType), type))
		return soap->error;
	if (soap_out_PointerTons2__StateEnergyType(soap, "ns2:StateEnergy", -1, &(a->ns2__MolecularStateCharacterisationType::StateEnergy), ""))
		return soap->error;
	if (soap_out_PointerToxsd__positiveInteger(soap, "ns2:TotalStatisticalWeight", -1, &(a->ns2__MolecularStateCharacterisationType::TotalStatisticalWeight), ""))
		return soap->error;
	if (soap_out_PointerToxsd__positiveInteger(soap, "ns2:NuclearStatisticalWeight", -1, &(a->ns2__MolecularStateCharacterisationType::NuclearStatisticalWeight), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:NuclearSpinSymmetry", -1, &(a->ns2__MolecularStateCharacterisationType::NuclearSpinSymmetry), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:LifeTime", -1, &(a->ns2__MolecularStateCharacterisationType::LifeTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, "ns2:Parameters", -1, &(a->ns2__MolecularStateCharacterisationType::Parameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularStateCharacterisationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularStateCharacterisationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularStateCharacterisationType * SOAP_FMAC4 soap_in_ns2__MolecularStateCharacterisationType(struct soap *soap, const char *tag, ns2__MolecularStateCharacterisationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularStateCharacterisationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularStateCharacterisationType, sizeof(ns2__MolecularStateCharacterisationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularStateCharacterisationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularStateCharacterisationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StateEnergy1 = 1;
	size_t soap_flag_TotalStatisticalWeight1 = 1;
	size_t soap_flag_NuclearStatisticalWeight1 = 1;
	size_t soap_flag_NuclearSpinSymmetry1 = 1;
	size_t soap_flag_LifeTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StateEnergy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__StateEnergyType(soap, "ns2:StateEnergy", &(a->ns2__MolecularStateCharacterisationType::StateEnergy), "ns2:StateEnergyType"))
				{	soap_flag_StateEnergy1--;
					continue;
				}
			if (soap_flag_TotalStatisticalWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__positiveInteger(soap, "ns2:TotalStatisticalWeight", &(a->ns2__MolecularStateCharacterisationType::TotalStatisticalWeight), "xsd:positiveInteger"))
				{	soap_flag_TotalStatisticalWeight1--;
					continue;
				}
			if (soap_flag_NuclearStatisticalWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__positiveInteger(soap, "ns2:NuclearStatisticalWeight", &(a->ns2__MolecularStateCharacterisationType::NuclearStatisticalWeight), "xsd:positiveInteger"))
				{	soap_flag_NuclearStatisticalWeight1--;
					continue;
				}
			if (soap_flag_NuclearSpinSymmetry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:NuclearSpinSymmetry", &(a->ns2__MolecularStateCharacterisationType::NuclearSpinSymmetry), "xsd:string"))
				{	soap_flag_NuclearSpinSymmetry1--;
					continue;
				}
			if (soap_flag_LifeTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:LifeTime", &(a->ns2__MolecularStateCharacterisationType::LifeTime), "ns2:DataType"))
				{	soap_flag_LifeTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, "ns2:Parameters", &(a->ns2__MolecularStateCharacterisationType::Parameters), "ns2:CharacterisationType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularStateCharacterisationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularStateCharacterisationType, 0, sizeof(ns2__MolecularStateCharacterisationType), 0, soap_copy_ns2__MolecularStateCharacterisationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__MolecularStateCharacterisationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularStateCharacterisationType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularStateCharacterisationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularStateCharacterisationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularStateCharacterisationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularStateCharacterisationType * SOAP_FMAC4 soap_get_ns2__MolecularStateCharacterisationType(struct soap *soap, ns2__MolecularStateCharacterisationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularStateCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularStateCharacterisationType * SOAP_FMAC2 soap_instantiate_ns2__MolecularStateCharacterisationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularStateCharacterisationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularStateCharacterisationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateCharacterisationType);
		if (size)
			*size = sizeof(ns2__MolecularStateCharacterisationType);
		((ns2__MolecularStateCharacterisationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateCharacterisationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularStateCharacterisationType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularStateCharacterisationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularStateCharacterisationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularStateCharacterisationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularStateCharacterisationType %p -> %p\n", q, p));
	*(ns2__MolecularStateCharacterisationType*)p = *(ns2__MolecularStateCharacterisationType*)q;
}

void ns2__MolecularStateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__MolecularStateType::Description);
	this->ns2__MolecularStateType::MolecularStateCharacterisation = NULL;
	this->ns2__MolecularStateType::TotalSpinMomentumS = NULL;
	this->ns2__MolecularStateType::TotalMagneticQuantumNumberS = NULL;
	this->ns2__MolecularStateType::Parity = NULL;
	this->ns2__MolecularStateType::Comment = NULL;
	this->ns2__MolecularStateType::ElectronicHome = NULL;
	soap_default__ns2__stateID(soap, &this->ns2__MolecularStateType::ns2__stateID);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__MolecularStateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MolecularStateType::Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MolecularStateType::Description);
	soap_serialize_PointerTons2__MolecularStateCharacterisationType(soap, &this->ns2__MolecularStateType::MolecularStateCharacterisation);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__MolecularStateType::TotalSpinMomentumS);
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__MolecularStateType::TotalMagneticQuantumNumberS);
	soap_serialize_PointerTons2__ParityType(soap, &this->ns2__MolecularStateType::Parity);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MolecularStateType::Comment);
	soap_serialize_PointerTons2__ElectronicHomeType(soap, &this->ns2__MolecularStateType::ElectronicHome);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__MolecularStateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularStateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularStateType(struct soap *soap, const char *tag, int id, const ns2__MolecularStateType *a, const char *type)
{
	soap_set_attr(soap, "ns2:stateID", ((ns2__MolecularStateType*)a)->ns2__stateID.c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularStateType), "ns2:MolecularStateType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "ns2:Description", -1, &(a->ns2__MolecularStateType::Description), ""))
		return soap->error;
	if (soap_out_PointerTons2__MolecularStateCharacterisationType(soap, "ns2:MolecularStateCharacterisation", -1, &(a->ns2__MolecularStateType::MolecularStateCharacterisation), ""))
		return soap->error;
	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalSpinMomentumS", -1, &(a->ns2__MolecularStateType::TotalSpinMomentumS), ""))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberS", -1, &(a->ns2__MolecularStateType::TotalMagneticQuantumNumberS), ""))
		return soap->error;
	if (soap_out_PointerTons2__ParityType(soap, "ns2:Parity", -1, &(a->ns2__MolecularStateType::Parity), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__MolecularStateType::Comment), ""))
		return soap->error;
	if (soap_out_PointerTons2__ElectronicHomeType(soap, "ns2:ElectronicHome", -1, &(a->ns2__MolecularStateType::ElectronicHome), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularStateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularStateType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularStateType * SOAP_FMAC4 soap_in_ns2__MolecularStateType(struct soap *soap, const char *tag, ns2__MolecularStateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularStateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularStateType, sizeof(ns2__MolecularStateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularStateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularStateType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:stateID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__MolecularStateType*)a)->ns2__stateID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_MolecularStateCharacterisation1 = 1;
	size_t soap_flag_TotalSpinMomentumS1 = 1;
	size_t soap_flag_TotalMagneticQuantumNumberS1 = 1;
	size_t soap_flag_Parity1 = 1;
	size_t soap_flag_Comment1 = 1;
	size_t soap_flag_ElectronicHome1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Description", &(a->ns2__MolecularStateType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_MolecularStateCharacterisation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularStateCharacterisationType(soap, "ns2:MolecularStateCharacterisation", &(a->ns2__MolecularStateType::MolecularStateCharacterisation), "ns2:MolecularStateCharacterisationType"))
				{	soap_flag_MolecularStateCharacterisation1--;
					continue;
				}
			if (soap_flag_TotalSpinMomentumS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalSpinMomentumS", &(a->ns2__MolecularStateType::TotalSpinMomentumS), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalSpinMomentumS1--;
					continue;
				}
			if (soap_flag_TotalMagneticQuantumNumberS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:TotalMagneticQuantumNumberS", &(a->ns2__MolecularStateType::TotalMagneticQuantumNumberS), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_TotalMagneticQuantumNumberS1--;
					continue;
				}
			if (soap_flag_Parity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParityType(soap, "ns2:Parity", &(a->ns2__MolecularStateType::Parity), "ns2:ParityType"))
				{	soap_flag_Parity1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__MolecularStateType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			if (soap_flag_ElectronicHome1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ElectronicHomeType(soap, "ns2:ElectronicHome", &(a->ns2__MolecularStateType::ElectronicHome), "ns2:ElectronicHomeType"))
				{	soap_flag_ElectronicHome1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularStateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularStateType, 0, sizeof(ns2__MolecularStateType), 0, soap_copy_ns2__MolecularStateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MolecularStateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularStateType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularStateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularStateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularStateType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularStateType * SOAP_FMAC4 soap_get_ns2__MolecularStateType(struct soap *soap, ns2__MolecularStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularStateType * SOAP_FMAC2 soap_instantiate_ns2__MolecularStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateType);
		if (size)
			*size = sizeof(ns2__MolecularStateType);
		((ns2__MolecularStateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularStateType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularStateType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularStateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularStateType %p -> %p\n", q, p));
	*(ns2__MolecularStateType*)p = *(ns2__MolecularStateType*)q;
}

void ns2__MolecularPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MolecularPropertiesType::MolecularWeight = NULL;
	soap_default_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(soap, &this->ns2__MolecularPropertiesType::__MolecularPropertiesType_sequence);
	/* transient soap skipped */
}

void ns2__MolecularPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__MolecularPropertiesType::MolecularWeight);
	soap_serialize_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(soap, &this->ns2__MolecularPropertiesType::__MolecularPropertiesType_sequence);
	/* transient soap skipped */
}

int ns2__MolecularPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularPropertiesType(struct soap *soap, const char *tag, int id, const ns2__MolecularPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularPropertiesType), type))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:MolecularWeight", -1, &(a->ns2__MolecularPropertiesType::MolecularWeight), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(soap, "-MolecularPropertiesType-sequence", -1, &(a->ns2__MolecularPropertiesType::__MolecularPropertiesType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularPropertiesType * SOAP_FMAC4 soap_in_ns2__MolecularPropertiesType(struct soap *soap, const char *tag, ns2__MolecularPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularPropertiesType, sizeof(ns2__MolecularPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MolecularWeight1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MolecularWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:MolecularWeight", &(a->ns2__MolecularPropertiesType::MolecularWeight), "ns2:DataType"))
				{	soap_flag_MolecularWeight1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(soap, "-MolecularPropertiesType-sequence", &(a->ns2__MolecularPropertiesType::__MolecularPropertiesType_sequence), "-ns2:MolecularPropertiesType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularPropertiesType, 0, sizeof(ns2__MolecularPropertiesType), 0, soap_copy_ns2__MolecularPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__MolecularPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularPropertiesType * SOAP_FMAC4 soap_get_ns2__MolecularPropertiesType(struct soap *soap, ns2__MolecularPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__MolecularPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularPropertiesType);
		if (size)
			*size = sizeof(ns2__MolecularPropertiesType);
		((ns2__MolecularPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularPropertiesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularPropertiesType %p -> %p\n", q, p));
	*(ns2__MolecularPropertiesType*)p = *(ns2__MolecularPropertiesType*)q;
}

void ns2__MolecularProjectionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MolecularProjectionType::TotalMolecularProjectionN = NULL;
	this->ns2__MolecularProjectionType::AsymmetricProjection = NULL;
	this->ns2__MolecularProjectionType::HinderedMotion = NULL;
	/* transient soap skipped */
}

void ns2__MolecularProjectionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__MolecularProjectionType::TotalMolecularProjectionN);
	soap_serialize_PointerTons2__AsymmetricProjectionType(soap, &this->ns2__MolecularProjectionType::AsymmetricProjection);
	soap_serialize_PointerTons2__HinderedMotionType(soap, &this->ns2__MolecularProjectionType::HinderedMotion);
	/* transient soap skipped */
}

int ns2__MolecularProjectionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularProjectionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularProjectionType(struct soap *soap, const char *tag, int id, const ns2__MolecularProjectionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularProjectionType), type))
		return soap->error;
	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionN", -1, &(a->ns2__MolecularProjectionType::TotalMolecularProjectionN), ""))
		return soap->error;
	if (soap_out_PointerTons2__AsymmetricProjectionType(soap, "ns2:AsymmetricProjection", -1, &(a->ns2__MolecularProjectionType::AsymmetricProjection), ""))
		return soap->error;
	if (soap_out_PointerTons2__HinderedMotionType(soap, "ns2:HinderedMotion", -1, &(a->ns2__MolecularProjectionType::HinderedMotion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularProjectionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularProjectionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularProjectionType * SOAP_FMAC4 soap_in_ns2__MolecularProjectionType(struct soap *soap, const char *tag, ns2__MolecularProjectionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularProjectionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularProjectionType, sizeof(ns2__MolecularProjectionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularProjectionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularProjectionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalMolecularProjectionN1 = 1;
	size_t soap_flag_AsymmetricProjection1 = 1;
	size_t soap_flag_HinderedMotion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalMolecularProjectionN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionN", &(a->ns2__MolecularProjectionType::TotalMolecularProjectionN), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalMolecularProjectionN1--;
					continue;
				}
			if (soap_flag_AsymmetricProjection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AsymmetricProjectionType(soap, "ns2:AsymmetricProjection", &(a->ns2__MolecularProjectionType::AsymmetricProjection), "ns2:AsymmetricProjectionType"))
				{	soap_flag_AsymmetricProjection1--;
					continue;
				}
			if (soap_flag_HinderedMotion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HinderedMotionType(soap, "ns2:HinderedMotion", &(a->ns2__MolecularProjectionType::HinderedMotion), "ns2:HinderedMotionType"))
				{	soap_flag_HinderedMotion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularProjectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularProjectionType, 0, sizeof(ns2__MolecularProjectionType), 0, soap_copy_ns2__MolecularProjectionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__MolecularProjectionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularProjectionType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularProjectionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularProjectionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularProjectionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularProjectionType * SOAP_FMAC4 soap_get_ns2__MolecularProjectionType(struct soap *soap, ns2__MolecularProjectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularProjectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularProjectionType * SOAP_FMAC2 soap_instantiate_ns2__MolecularProjectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularProjectionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularProjectionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularProjectionType);
		if (size)
			*size = sizeof(ns2__MolecularProjectionType);
		((ns2__MolecularProjectionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularProjectionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularProjectionType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularProjectionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularProjectionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularProjectionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularProjectionType %p -> %p\n", q, p));
	*(ns2__MolecularProjectionType*)p = *(ns2__MolecularProjectionType*)q;
}

void ns2__MolecularChemicalSpeciesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MolecularChemicalSpeciesType::OrdinaryStructuralFormula = NULL;
	soap_default_std__string(soap, &this->ns2__MolecularChemicalSpeciesType::StoichiometricFormula);
	this->ns2__MolecularChemicalSpeciesType::IonCharge = NULL;
	this->ns2__MolecularChemicalSpeciesType::ChemicalName = NULL;
	this->ns2__MolecularChemicalSpeciesType::IUPACName = NULL;
	this->ns2__MolecularChemicalSpeciesType::URLFigure = NULL;
	this->ns2__MolecularChemicalSpeciesType::InChI = NULL;
	this->ns2__MolecularChemicalSpeciesType::InChIKey = NULL;
	this->ns2__MolecularChemicalSpeciesType::CASRegistryNumber = NULL;
	this->ns2__MolecularChemicalSpeciesType::CNPIGroup = NULL;
	this->ns2__MolecularChemicalSpeciesType::MoleculeNuclearSpins = NULL;
	this->ns2__MolecularChemicalSpeciesType::StableMolecularProperties = NULL;
	this->ns2__MolecularChemicalSpeciesType::Comment = NULL;
	/* transient soap skipped */
}

void ns2__MolecularChemicalSpeciesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__MolecularChemicalSpeciesType::OrdinaryStructuralFormula);
	soap_embedded(soap, &this->ns2__MolecularChemicalSpeciesType::StoichiometricFormula, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MolecularChemicalSpeciesType::StoichiometricFormula);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__MolecularChemicalSpeciesType::IonCharge);
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__MolecularChemicalSpeciesType::ChemicalName);
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__MolecularChemicalSpeciesType::IUPACName);
	soap_serialize_PointerToxsd__anyURI(soap, &this->ns2__MolecularChemicalSpeciesType::URLFigure);
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__MolecularChemicalSpeciesType::InChI);
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__MolecularChemicalSpeciesType::InChIKey);
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__MolecularChemicalSpeciesType::CASRegistryNumber);
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__MolecularChemicalSpeciesType::CNPIGroup);
	soap_serialize_PointerTons2__MoleculeNuclearSpinsType(soap, &this->ns2__MolecularChemicalSpeciesType::MoleculeNuclearSpins);
	soap_serialize_PointerTons2__MolecularPropertiesType(soap, &this->ns2__MolecularChemicalSpeciesType::StableMolecularProperties);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MolecularChemicalSpeciesType::Comment);
	/* transient soap skipped */
}

int ns2__MolecularChemicalSpeciesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MolecularChemicalSpeciesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MolecularChemicalSpeciesType(struct soap *soap, const char *tag, int id, const ns2__MolecularChemicalSpeciesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MolecularChemicalSpeciesType), type))
		return soap->error;
	if (a->ns2__MolecularChemicalSpeciesType::OrdinaryStructuralFormula)
	{	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:OrdinaryStructuralFormula", -1, &a->ns2__MolecularChemicalSpeciesType::OrdinaryStructuralFormula, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:OrdinaryStructuralFormula"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:StoichiometricFormula", -1, &(a->ns2__MolecularChemicalSpeciesType::StoichiometricFormula), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:IonCharge", -1, &(a->ns2__MolecularChemicalSpeciesType::IonCharge), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:ChemicalName", -1, &(a->ns2__MolecularChemicalSpeciesType::ChemicalName), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:IUPACName", -1, &(a->ns2__MolecularChemicalSpeciesType::IUPACName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "ns2:URLFigure", -1, &(a->ns2__MolecularChemicalSpeciesType::URLFigure), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:InChI", -1, &(a->ns2__MolecularChemicalSpeciesType::InChI), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:InChIKey", -1, &(a->ns2__MolecularChemicalSpeciesType::InChIKey), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:CASRegistryNumber", -1, &(a->ns2__MolecularChemicalSpeciesType::CASRegistryNumber), ""))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:CNPIGroup", -1, &(a->ns2__MolecularChemicalSpeciesType::CNPIGroup), ""))
		return soap->error;
	if (soap_out_PointerTons2__MoleculeNuclearSpinsType(soap, "ns2:MoleculeNuclearSpins", -1, &(a->ns2__MolecularChemicalSpeciesType::MoleculeNuclearSpins), ""))
		return soap->error;
	if (soap_out_PointerTons2__MolecularPropertiesType(soap, "ns2:StableMolecularProperties", -1, &(a->ns2__MolecularChemicalSpeciesType::StableMolecularProperties), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__MolecularChemicalSpeciesType::Comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MolecularChemicalSpeciesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MolecularChemicalSpeciesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MolecularChemicalSpeciesType * SOAP_FMAC4 soap_in_ns2__MolecularChemicalSpeciesType(struct soap *soap, const char *tag, ns2__MolecularChemicalSpeciesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MolecularChemicalSpeciesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MolecularChemicalSpeciesType, sizeof(ns2__MolecularChemicalSpeciesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MolecularChemicalSpeciesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MolecularChemicalSpeciesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OrdinaryStructuralFormula1 = 1;
	size_t soap_flag_StoichiometricFormula1 = 1;
	size_t soap_flag_IonCharge1 = 1;
	size_t soap_flag_ChemicalName1 = 1;
	size_t soap_flag_IUPACName1 = 1;
	size_t soap_flag_URLFigure1 = 1;
	size_t soap_flag_InChI1 = 1;
	size_t soap_flag_InChIKey1 = 1;
	size_t soap_flag_CASRegistryNumber1 = 1;
	size_t soap_flag_CNPIGroup1 = 1;
	size_t soap_flag_MoleculeNuclearSpins1 = 1;
	size_t soap_flag_StableMolecularProperties1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OrdinaryStructuralFormula1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:OrdinaryStructuralFormula", &(a->ns2__MolecularChemicalSpeciesType::OrdinaryStructuralFormula), "ns2:ReferencedTextType"))
				{	soap_flag_OrdinaryStructuralFormula1--;
					continue;
				}
			if (soap_flag_StoichiometricFormula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:StoichiometricFormula", &(a->ns2__MolecularChemicalSpeciesType::StoichiometricFormula), "xsd:string"))
				{	soap_flag_StoichiometricFormula1--;
					continue;
				}
			if (soap_flag_IonCharge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "ns2:IonCharge", &(a->ns2__MolecularChemicalSpeciesType::IonCharge), "xsd:integer"))
				{	soap_flag_IonCharge1--;
					continue;
				}
			if (soap_flag_ChemicalName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:ChemicalName", &(a->ns2__MolecularChemicalSpeciesType::ChemicalName), "ns2:ReferencedTextType"))
				{	soap_flag_ChemicalName1--;
					continue;
				}
			if (soap_flag_IUPACName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:IUPACName", &(a->ns2__MolecularChemicalSpeciesType::IUPACName), "ns2:ReferencedTextType"))
				{	soap_flag_IUPACName1--;
					continue;
				}
			if (soap_flag_URLFigure1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "ns2:URLFigure", &(a->ns2__MolecularChemicalSpeciesType::URLFigure), "xsd:anyURI"))
				{	soap_flag_URLFigure1--;
					continue;
				}
			if (soap_flag_InChI1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:InChI", &(a->ns2__MolecularChemicalSpeciesType::InChI), "ns2:ReferencedTextType"))
				{	soap_flag_InChI1--;
					continue;
				}
			if (soap_flag_InChIKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:InChIKey", &(a->ns2__MolecularChemicalSpeciesType::InChIKey), "ns2:ReferencedTextType"))
				{	soap_flag_InChIKey1--;
					continue;
				}
			if (soap_flag_CASRegistryNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:CASRegistryNumber", &(a->ns2__MolecularChemicalSpeciesType::CASRegistryNumber), "ns2:ReferencedTextType"))
				{	soap_flag_CASRegistryNumber1--;
					continue;
				}
			if (soap_flag_CNPIGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:CNPIGroup", &(a->ns2__MolecularChemicalSpeciesType::CNPIGroup), "ns2:SymbolType"))
				{	soap_flag_CNPIGroup1--;
					continue;
				}
			if (soap_flag_MoleculeNuclearSpins1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MoleculeNuclearSpinsType(soap, "ns2:MoleculeNuclearSpins", &(a->ns2__MolecularChemicalSpeciesType::MoleculeNuclearSpins), "ns2:MoleculeNuclearSpinsType"))
				{	soap_flag_MoleculeNuclearSpins1--;
					continue;
				}
			if (soap_flag_StableMolecularProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularPropertiesType(soap, "ns2:StableMolecularProperties", &(a->ns2__MolecularChemicalSpeciesType::StableMolecularProperties), "ns2:MolecularPropertiesType"))
				{	soap_flag_StableMolecularProperties1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__MolecularChemicalSpeciesType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MolecularChemicalSpeciesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MolecularChemicalSpeciesType, 0, sizeof(ns2__MolecularChemicalSpeciesType), 0, soap_copy_ns2__MolecularChemicalSpeciesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OrdinaryStructuralFormula1 > 0 || soap_flag_StoichiometricFormula1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MolecularChemicalSpeciesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MolecularChemicalSpeciesType);
	if (this->soap_out(soap, tag?tag:"ns2:MolecularChemicalSpeciesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MolecularChemicalSpeciesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MolecularChemicalSpeciesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MolecularChemicalSpeciesType * SOAP_FMAC4 soap_get_ns2__MolecularChemicalSpeciesType(struct soap *soap, ns2__MolecularChemicalSpeciesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MolecularChemicalSpeciesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MolecularChemicalSpeciesType * SOAP_FMAC2 soap_instantiate_ns2__MolecularChemicalSpeciesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MolecularChemicalSpeciesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MolecularChemicalSpeciesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularChemicalSpeciesType);
		if (size)
			*size = sizeof(ns2__MolecularChemicalSpeciesType);
		((ns2__MolecularChemicalSpeciesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularChemicalSpeciesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MolecularChemicalSpeciesType);
		for (int i = 0; i < n; i++)
			((ns2__MolecularChemicalSpeciesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MolecularChemicalSpeciesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MolecularChemicalSpeciesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MolecularChemicalSpeciesType %p -> %p\n", q, p));
	*(ns2__MolecularChemicalSpeciesType*)p = *(ns2__MolecularChemicalSpeciesType*)q;
}

void ns2__ElectronicHomeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ElectronicComponentType(soap, &this->ns2__ElectronicHomeType::ElectronicComponent);
	/* transient soap skipped */
}

void ns2__ElectronicHomeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ElectronicComponentType(soap, &this->ns2__ElectronicHomeType::ElectronicComponent);
	/* transient soap skipped */
}

int ns2__ElectronicHomeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ElectronicHomeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ElectronicHomeType(struct soap *soap, const char *tag, int id, const ns2__ElectronicHomeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ElectronicHomeType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ElectronicComponentType(soap, "ns2:ElectronicComponent", -1, &(a->ns2__ElectronicHomeType::ElectronicComponent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ElectronicHomeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ElectronicHomeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ElectronicHomeType * SOAP_FMAC4 soap_in_ns2__ElectronicHomeType(struct soap *soap, const char *tag, ns2__ElectronicHomeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ElectronicHomeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ElectronicHomeType, sizeof(ns2__ElectronicHomeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ElectronicHomeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ElectronicHomeType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ElectronicComponentType(soap, "ns2:ElectronicComponent", &(a->ns2__ElectronicHomeType::ElectronicComponent), "ns2:ElectronicComponentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ElectronicHomeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ElectronicHomeType, 0, sizeof(ns2__ElectronicHomeType), 0, soap_copy_ns2__ElectronicHomeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ElectronicHomeType::ElectronicComponent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ElectronicHomeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ElectronicHomeType);
	if (this->soap_out(soap, tag?tag:"ns2:ElectronicHomeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ElectronicHomeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ElectronicHomeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ElectronicHomeType * SOAP_FMAC4 soap_get_ns2__ElectronicHomeType(struct soap *soap, ns2__ElectronicHomeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ElectronicHomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ElectronicHomeType * SOAP_FMAC2 soap_instantiate_ns2__ElectronicHomeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ElectronicHomeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ElectronicHomeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ElectronicHomeType);
		if (size)
			*size = sizeof(ns2__ElectronicHomeType);
		((ns2__ElectronicHomeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ElectronicHomeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ElectronicHomeType);
		for (int i = 0; i < n; i++)
			((ns2__ElectronicHomeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ElectronicHomeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ElectronicHomeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ElectronicHomeType %p -> %p\n", q, p));
	*(ns2__ElectronicHomeType*)p = *(ns2__ElectronicHomeType*)q;
}

void ns2__ElectronicComponentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ElectronicComponentType::Description = NULL;
	this->ns2__ElectronicComponentType::SerialQuantumNumber = NULL;
	this->ns2__ElectronicComponentType::MixingCoefficient = NULL;
	this->ns2__ElectronicComponentType::ElectronicCharacterisation = NULL;
	this->ns2__ElectronicComponentType::TotalMolecularProjectionL = NULL;
	this->ns2__ElectronicComponentType::VibrationalHome = NULL;
	this->ns2__ElectronicComponentType::Comment = NULL;
	/* transient soap skipped */
}

void ns2__ElectronicComponentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__token(soap, &this->ns2__ElectronicComponentType::Description);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ElectronicComponentType::SerialQuantumNumber);
	soap_serialize_PointerTons2__MixingCoefficientType(soap, &this->ns2__ElectronicComponentType::MixingCoefficient);
	soap_serialize_PointerTons2__ElectronicCharacterisationType(soap, &this->ns2__ElectronicComponentType::ElectronicCharacterisation);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__ElectronicComponentType::TotalMolecularProjectionL);
	soap_serialize_PointerTons2__VibrationalHomeType(soap, &this->ns2__ElectronicComponentType::VibrationalHome);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ElectronicComponentType::Comment);
	/* transient soap skipped */
}

int ns2__ElectronicComponentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ElectronicComponentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ElectronicComponentType(struct soap *soap, const char *tag, int id, const ns2__ElectronicComponentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ElectronicComponentType), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "ns2:Description", -1, &(a->ns2__ElectronicComponentType::Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:SerialQuantumNumber", -1, &(a->ns2__ElectronicComponentType::SerialQuantumNumber), ""))
		return soap->error;
	if (soap_out_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", -1, &(a->ns2__ElectronicComponentType::MixingCoefficient), ""))
		return soap->error;
	if (soap_out_PointerTons2__ElectronicCharacterisationType(soap, "ns2:ElectronicCharacterisation", -1, &(a->ns2__ElectronicComponentType::ElectronicCharacterisation), ""))
		return soap->error;
	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionL", -1, &(a->ns2__ElectronicComponentType::TotalMolecularProjectionL), ""))
		return soap->error;
	if (soap_out_PointerTons2__VibrationalHomeType(soap, "ns2:VibrationalHome", -1, &(a->ns2__ElectronicComponentType::VibrationalHome), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__ElectronicComponentType::Comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ElectronicComponentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ElectronicComponentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ElectronicComponentType * SOAP_FMAC4 soap_in_ns2__ElectronicComponentType(struct soap *soap, const char *tag, ns2__ElectronicComponentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ElectronicComponentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ElectronicComponentType, sizeof(ns2__ElectronicComponentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ElectronicComponentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ElectronicComponentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_SerialQuantumNumber1 = 1;
	size_t soap_flag_MixingCoefficient1 = 1;
	size_t soap_flag_ElectronicCharacterisation1 = 1;
	size_t soap_flag_TotalMolecularProjectionL1 = 1;
	size_t soap_flag_VibrationalHome1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "ns2:Description", &(a->ns2__ElectronicComponentType::Description), "xsd:token"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_SerialQuantumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:SerialQuantumNumber", &(a->ns2__ElectronicComponentType::SerialQuantumNumber), "xsd:string"))
				{	soap_flag_SerialQuantumNumber1--;
					continue;
				}
			if (soap_flag_MixingCoefficient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", &(a->ns2__ElectronicComponentType::MixingCoefficient), "ns2:MixingCoefficientType"))
				{	soap_flag_MixingCoefficient1--;
					continue;
				}
			if (soap_flag_ElectronicCharacterisation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ElectronicCharacterisationType(soap, "ns2:ElectronicCharacterisation", &(a->ns2__ElectronicComponentType::ElectronicCharacterisation), "ns2:ElectronicCharacterisationType"))
				{	soap_flag_ElectronicCharacterisation1--;
					continue;
				}
			if (soap_flag_TotalMolecularProjectionL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:TotalMolecularProjectionL", &(a->ns2__ElectronicComponentType::TotalMolecularProjectionL), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_TotalMolecularProjectionL1--;
					continue;
				}
			if (soap_flag_VibrationalHome1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VibrationalHomeType(soap, "ns2:VibrationalHome", &(a->ns2__ElectronicComponentType::VibrationalHome), "ns2:VibrationalHomeType"))
				{	soap_flag_VibrationalHome1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__ElectronicComponentType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ElectronicComponentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ElectronicComponentType, 0, sizeof(ns2__ElectronicComponentType), 0, soap_copy_ns2__ElectronicComponentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ElectronicComponentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ElectronicComponentType);
	if (this->soap_out(soap, tag?tag:"ns2:ElectronicComponentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ElectronicComponentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ElectronicComponentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ElectronicComponentType * SOAP_FMAC4 soap_get_ns2__ElectronicComponentType(struct soap *soap, ns2__ElectronicComponentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ElectronicComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ElectronicComponentType * SOAP_FMAC2 soap_instantiate_ns2__ElectronicComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ElectronicComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ElectronicComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ElectronicComponentType);
		if (size)
			*size = sizeof(ns2__ElectronicComponentType);
		((ns2__ElectronicComponentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ElectronicComponentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ElectronicComponentType);
		for (int i = 0; i < n; i++)
			((ns2__ElectronicComponentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ElectronicComponentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ElectronicComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ElectronicComponentType %p -> %p\n", q, p));
	*(ns2__ElectronicComponentType*)p = *(ns2__ElectronicComponentType*)q;
}

void ns2__ElectronicCharacterisationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ElectronicCharacterisationType::TermSymbol = NULL;
	this->ns2__ElectronicCharacterisationType::Configuration = NULL;
	this->ns2__ElectronicCharacterisationType::Conformation = NULL;
	this->ns2__ElectronicCharacterisationType::SymmetryGroup = NULL;
	/* transient soap skipped */
}

void ns2__ElectronicCharacterisationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__ElectronicCharacterisationType::TermSymbol);
	soap_serialize_PointerTons2__ReferencedTextType(soap, &this->ns2__ElectronicCharacterisationType::Configuration);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ElectronicCharacterisationType::Conformation);
	soap_serialize_PointerTons2__SymbolType(soap, &this->ns2__ElectronicCharacterisationType::SymmetryGroup);
	/* transient soap skipped */
}

int ns2__ElectronicCharacterisationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ElectronicCharacterisationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ElectronicCharacterisationType(struct soap *soap, const char *tag, int id, const ns2__ElectronicCharacterisationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ElectronicCharacterisationType), type))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:TermSymbol", -1, &(a->ns2__ElectronicCharacterisationType::TermSymbol), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferencedTextType(soap, "ns2:Configuration", -1, &(a->ns2__ElectronicCharacterisationType::Configuration), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Conformation", -1, &(a->ns2__ElectronicCharacterisationType::Conformation), ""))
		return soap->error;
	if (soap_out_PointerTons2__SymbolType(soap, "ns2:SymmetryGroup", -1, &(a->ns2__ElectronicCharacterisationType::SymmetryGroup), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ElectronicCharacterisationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ElectronicCharacterisationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ElectronicCharacterisationType * SOAP_FMAC4 soap_in_ns2__ElectronicCharacterisationType(struct soap *soap, const char *tag, ns2__ElectronicCharacterisationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ElectronicCharacterisationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ElectronicCharacterisationType, sizeof(ns2__ElectronicCharacterisationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ElectronicCharacterisationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ElectronicCharacterisationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TermSymbol1 = 1;
	size_t soap_flag_Configuration1 = 1;
	size_t soap_flag_Conformation1 = 1;
	size_t soap_flag_SymmetryGroup1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TermSymbol1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:TermSymbol", &(a->ns2__ElectronicCharacterisationType::TermSymbol), "ns2:SymbolType"))
				{	soap_flag_TermSymbol1--;
					continue;
				}
			if (soap_flag_Configuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferencedTextType(soap, "ns2:Configuration", &(a->ns2__ElectronicCharacterisationType::Configuration), "ns2:ReferencedTextType"))
				{	soap_flag_Configuration1--;
					continue;
				}
			if (soap_flag_Conformation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Conformation", &(a->ns2__ElectronicCharacterisationType::Conformation), "xsd:string"))
				{	soap_flag_Conformation1--;
					continue;
				}
			if (soap_flag_SymmetryGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SymbolType(soap, "ns2:SymmetryGroup", &(a->ns2__ElectronicCharacterisationType::SymmetryGroup), "ns2:SymbolType"))
				{	soap_flag_SymmetryGroup1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ElectronicCharacterisationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ElectronicCharacterisationType, 0, sizeof(ns2__ElectronicCharacterisationType), 0, soap_copy_ns2__ElectronicCharacterisationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ElectronicCharacterisationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ElectronicCharacterisationType);
	if (this->soap_out(soap, tag?tag:"ns2:ElectronicCharacterisationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ElectronicCharacterisationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ElectronicCharacterisationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ElectronicCharacterisationType * SOAP_FMAC4 soap_get_ns2__ElectronicCharacterisationType(struct soap *soap, ns2__ElectronicCharacterisationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ElectronicCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ElectronicCharacterisationType * SOAP_FMAC2 soap_instantiate_ns2__ElectronicCharacterisationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ElectronicCharacterisationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ElectronicCharacterisationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ElectronicCharacterisationType);
		if (size)
			*size = sizeof(ns2__ElectronicCharacterisationType);
		((ns2__ElectronicCharacterisationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ElectronicCharacterisationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ElectronicCharacterisationType);
		for (int i = 0; i < n; i++)
			((ns2__ElectronicCharacterisationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ElectronicCharacterisationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ElectronicCharacterisationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ElectronicCharacterisationType %p -> %p\n", q, p));
	*(ns2__ElectronicCharacterisationType*)p = *(ns2__ElectronicCharacterisationType*)q;
}

void ns2__DiatomAndLinearPolyatomicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DiatomAndLinearPolyatomicType::__union_DiatomAndLinearPolyatomicType = 0;
	/* transient soap skipped */
}

void ns2__DiatomAndLinearPolyatomicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_DiatomAndLinearPolyatomicType(soap, this->ns2__DiatomAndLinearPolyatomicType::__union_DiatomAndLinearPolyatomicType, &this->ns2__DiatomAndLinearPolyatomicType::union_DiatomAndLinearPolyatomicType);
	/* transient soap skipped */
}

int ns2__DiatomAndLinearPolyatomicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DiatomAndLinearPolyatomicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DiatomAndLinearPolyatomicType(struct soap *soap, const char *tag, int id, const ns2__DiatomAndLinearPolyatomicType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType), type))
		return soap->error;
	if (soap_out__ns2__union_DiatomAndLinearPolyatomicType(soap, a->ns2__DiatomAndLinearPolyatomicType::__union_DiatomAndLinearPolyatomicType, &a->ns2__DiatomAndLinearPolyatomicType::union_DiatomAndLinearPolyatomicType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DiatomAndLinearPolyatomicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DiatomAndLinearPolyatomicType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DiatomAndLinearPolyatomicType * SOAP_FMAC4 soap_in_ns2__DiatomAndLinearPolyatomicType(struct soap *soap, const char *tag, ns2__DiatomAndLinearPolyatomicType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DiatomAndLinearPolyatomicType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType, sizeof(ns2__DiatomAndLinearPolyatomicType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns2__union_DiatomAndLinearPolyatomicType(soap, &a->__union_DiatomAndLinearPolyatomicType, &a->union_DiatomAndLinearPolyatomicType))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DiatomAndLinearPolyatomicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType, 0, sizeof(ns2__DiatomAndLinearPolyatomicType), 0, soap_copy_ns2__DiatomAndLinearPolyatomicType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__DiatomAndLinearPolyatomicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType);
	if (this->soap_out(soap, tag?tag:"ns2:DiatomAndLinearPolyatomicType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DiatomAndLinearPolyatomicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DiatomAndLinearPolyatomicType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DiatomAndLinearPolyatomicType * SOAP_FMAC4 soap_get_ns2__DiatomAndLinearPolyatomicType(struct soap *soap, ns2__DiatomAndLinearPolyatomicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DiatomAndLinearPolyatomicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DiatomAndLinearPolyatomicType * SOAP_FMAC2 soap_instantiate_ns2__DiatomAndLinearPolyatomicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DiatomAndLinearPolyatomicType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DiatomAndLinearPolyatomicType);
		if (size)
			*size = sizeof(ns2__DiatomAndLinearPolyatomicType);
		((ns2__DiatomAndLinearPolyatomicType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DiatomAndLinearPolyatomicType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DiatomAndLinearPolyatomicType);
		for (int i = 0; i < n; i++)
			((ns2__DiatomAndLinearPolyatomicType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DiatomAndLinearPolyatomicType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DiatomAndLinearPolyatomicType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DiatomAndLinearPolyatomicType %p -> %p\n", q, p));
	*(ns2__DiatomAndLinearPolyatomicType*)p = *(ns2__DiatomAndLinearPolyatomicType*)q;
}

void ns2__ComplexMolecularQuantumNumberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ComplexMolecularQuantumNumberType::modesType = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::vibrationLNu_i = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::vibrationSymmetry = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::vibrationInversion = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::vibrationSymmetryIndex = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::nuclearSpinRefs2 = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::nuclearSpinRef = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::spinSumRef = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::electronicSpinRef = NULL;
	this->ns2__ComplexMolecularQuantumNumberType::quantumNumberRef = NULL;
	soap_default_std__string(soap, &this->ns2__MolecularQuantumNumberType::Label);
	soap_default_ns2__AngularMomentumType(soap, &this->ns2__MolecularQuantumNumberType::Value);
	this->ns2__MolecularQuantumNumberType::Comment = NULL;
	this->ns2__MolecularQuantumNumberType::quantumNumberID = NULL;
	/* transient soap skipped */
}

void ns2__ComplexMolecularQuantumNumberType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MolecularQuantumNumberType::Label, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MolecularQuantumNumberType::Label);
	soap_embedded(soap, &this->ns2__MolecularQuantumNumberType::Value, SOAP_TYPE_ns2__AngularMomentumType);
	soap_serialize_ns2__AngularMomentumType(soap, &this->ns2__MolecularQuantumNumberType::Value);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MolecularQuantumNumberType::Comment);
	/* transient soap skipped */
}

int ns2__ComplexMolecularQuantumNumberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ComplexMolecularQuantumNumberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ComplexMolecularQuantumNumberType(struct soap *soap, const char *tag, int id, const ns2__ComplexMolecularQuantumNumberType *a, const char *type)
{
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->modesType)
		soap_set_attr(soap, "modesType", soap_ns2__ModesListType2s(soap, *((ns2__ComplexMolecularQuantumNumberType*)a)->modesType), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationLNu_i)
		soap_set_attr(soap, "vibrationLNu-i", ((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationLNu_i->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetry)
		soap_set_attr(soap, "vibrationSymmetry", ((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetry->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationInversion)
		soap_set_attr(soap, "vibrationInversion", ((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationInversion->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetryIndex)
		soap_set_attr(soap, "vibrationSymmetryIndex", ((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetryIndex->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRefs2)
		soap_set_attr(soap, "nuclearSpinRefs2", ((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRefs2->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRef)
		soap_set_attr(soap, "nuclearSpinRef", ((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRef->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->spinSumRef)
		soap_set_attr(soap, "spinSumRef", ((ns2__ComplexMolecularQuantumNumberType*)a)->spinSumRef->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->electronicSpinRef)
		soap_set_attr(soap, "electronicSpinRef", ((ns2__ComplexMolecularQuantumNumberType*)a)->electronicSpinRef->c_str(), 1);
	if (((ns2__ComplexMolecularQuantumNumberType*)a)->quantumNumberRef)
		soap_set_attr(soap, "quantumNumberRef", ((ns2__ComplexMolecularQuantumNumberType*)a)->quantumNumberRef->c_str(), 1);
	if (((ns2__MolecularQuantumNumberType*)a)->quantumNumberID)
		soap_set_attr(soap, "quantumNumberID", ((ns2__MolecularQuantumNumberType*)a)->quantumNumberID->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType), "ns2:ComplexMolecularQuantumNumberType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Label", -1, &(a->ns2__MolecularQuantumNumberType::Label), ""))
		return soap->error;
	if (soap_out_ns2__AngularMomentumType(soap, "ns2:Value", -1, &(a->ns2__MolecularQuantumNumberType::Value), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comment", -1, &(a->ns2__MolecularQuantumNumberType::Comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ComplexMolecularQuantumNumberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ComplexMolecularQuantumNumberType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ComplexMolecularQuantumNumberType * SOAP_FMAC4 soap_in_ns2__ComplexMolecularQuantumNumberType(struct soap *soap, const char *tag, ns2__ComplexMolecularQuantumNumberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ComplexMolecularQuantumNumberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType, sizeof(ns2__ComplexMolecularQuantumNumberType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ComplexMolecularQuantumNumberType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "modesType", 0);
		if (t)
		{
			if (!(((ns2__ComplexMolecularQuantumNumberType*)a)->modesType = (enum ns2__ModesListType *)soap_malloc(soap, sizeof(enum ns2__ModesListType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ModesListType(soap, t, ((ns2__ComplexMolecularQuantumNumberType*)a)->modesType))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "vibrationLNu-i", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationLNu_i = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationLNu_i->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "vibrationSymmetry", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetry = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetry->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "vibrationInversion", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationInversion = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationInversion->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "vibrationSymmetryIndex", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetryIndex = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->vibrationSymmetryIndex->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "nuclearSpinRefs2", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRefs2 = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRefs2->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "nuclearSpinRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRef = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->nuclearSpinRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "spinSumRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->spinSumRef = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->spinSumRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "electronicSpinRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->electronicSpinRef = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->electronicSpinRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "quantumNumberRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ComplexMolecularQuantumNumberType*)a)->quantumNumberRef = soap_new_std__string(soap, -1);
				((ns2__ComplexMolecularQuantumNumberType*)a)->quantumNumberRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "quantumNumberID", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__MolecularQuantumNumberType*)a)->quantumNumberID = soap_new_std__string(soap, -1);
				((ns2__MolecularQuantumNumberType*)a)->quantumNumberID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Label2 = 1;
	size_t soap_flag_Value2 = 1;
	size_t soap_flag_Comment2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Label", &(a->ns2__MolecularQuantumNumberType::Label), "xsd:string"))
				{	soap_flag_Label2--;
					continue;
				}
			if (soap_flag_Value2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__AngularMomentumType(soap, "ns2:Value", &(a->ns2__MolecularQuantumNumberType::Value), "ns2:AngularMomentumType"))
				{	soap_flag_Value2--;
					continue;
				}
			if (soap_flag_Comment2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comment", &(a->ns2__MolecularQuantumNumberType::Comment), "xsd:string"))
				{	soap_flag_Comment2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ComplexMolecularQuantumNumberType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType, 0, sizeof(ns2__ComplexMolecularQuantumNumberType), 0, soap_copy_ns2__ComplexMolecularQuantumNumberType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Label2 > 0 || soap_flag_Value2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ComplexMolecularQuantumNumberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType);
	if (this->soap_out(soap, tag?tag:"ns2:ComplexMolecularQuantumNumberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ComplexMolecularQuantumNumberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ComplexMolecularQuantumNumberType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ComplexMolecularQuantumNumberType * SOAP_FMAC4 soap_get_ns2__ComplexMolecularQuantumNumberType(struct soap *soap, ns2__ComplexMolecularQuantumNumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ComplexMolecularQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ComplexMolecularQuantumNumberType * SOAP_FMAC2 soap_instantiate_ns2__ComplexMolecularQuantumNumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ComplexMolecularQuantumNumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ComplexMolecularQuantumNumberType);
		if (size)
			*size = sizeof(ns2__ComplexMolecularQuantumNumberType);
		((ns2__ComplexMolecularQuantumNumberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ComplexMolecularQuantumNumberType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ComplexMolecularQuantumNumberType);
		for (int i = 0; i < n; i++)
			((ns2__ComplexMolecularQuantumNumberType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ComplexMolecularQuantumNumberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ComplexMolecularQuantumNumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ComplexMolecularQuantumNumberType %p -> %p\n", q, p));
	*(ns2__ComplexMolecularQuantumNumberType*)p = *(ns2__ComplexMolecularQuantumNumberType*)q;
}

void ns2__CentralSymbolType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__CentralSymbolType::__item);
	this->ns2__CentralSymbolType::UpperLeftValue = NULL;
	this->ns2__CentralSymbolType::LowerLeftValue = NULL;
	this->ns2__CentralSymbolType::UpperRightValue = NULL;
	this->ns2__CentralSymbolType::LowerRightValue = NULL;
	/* transient soap skipped */
}

void ns2__CentralSymbolType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__CentralSymbolType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CentralSymbolType::__item);
	/* transient soap skipped */
}

int ns2__CentralSymbolType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CentralSymbolType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CentralSymbolType(struct soap *soap, const char *tag, int id, const ns2__CentralSymbolType *a, const char *type)
{
	if (((ns2__CentralSymbolType*)a)->UpperLeftValue)
		soap_set_attr(soap, "UpperLeftValue", ((ns2__CentralSymbolType*)a)->UpperLeftValue->c_str(), 1);
	if (((ns2__CentralSymbolType*)a)->LowerLeftValue)
		soap_set_attr(soap, "LowerLeftValue", ((ns2__CentralSymbolType*)a)->LowerLeftValue->c_str(), 1);
	if (((ns2__CentralSymbolType*)a)->UpperRightValue)
		soap_set_attr(soap, "UpperRightValue", ((ns2__CentralSymbolType*)a)->UpperRightValue->c_str(), 1);
	if (((ns2__CentralSymbolType*)a)->LowerRightValue)
		soap_set_attr(soap, "LowerRightValue", ((ns2__CentralSymbolType*)a)->LowerRightValue->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->ns2__CentralSymbolType::__item, "");
}

void *ns2__CentralSymbolType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CentralSymbolType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CentralSymbolType * SOAP_FMAC4 soap_in_ns2__CentralSymbolType(struct soap *soap, const char *tag, ns2__CentralSymbolType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__CentralSymbolType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CentralSymbolType, sizeof(ns2__CentralSymbolType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CentralSymbolType)
			return (ns2__CentralSymbolType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "UpperLeftValue", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__CentralSymbolType*)a)->UpperLeftValue = soap_new_std__string(soap, -1);
				((ns2__CentralSymbolType*)a)->UpperLeftValue->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LowerLeftValue", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__CentralSymbolType*)a)->LowerLeftValue = soap_new_std__string(soap, -1);
				((ns2__CentralSymbolType*)a)->LowerLeftValue->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "UpperRightValue", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__CentralSymbolType*)a)->UpperRightValue = soap_new_std__string(soap, -1);
				((ns2__CentralSymbolType*)a)->UpperRightValue->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LowerRightValue", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__CentralSymbolType*)a)->LowerRightValue = soap_new_std__string(soap, -1);
				((ns2__CentralSymbolType*)a)->LowerRightValue->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->ns2__CentralSymbolType::__item), "ns2:CentralSymbolType"))
		return NULL;
	return a;
}

int ns2__CentralSymbolType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CentralSymbolType);
	if (this->soap_out(soap, tag?tag:"ns2:CentralSymbolType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CentralSymbolType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CentralSymbolType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CentralSymbolType * SOAP_FMAC4 soap_get_ns2__CentralSymbolType(struct soap *soap, ns2__CentralSymbolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CentralSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CentralSymbolType * SOAP_FMAC2 soap_instantiate_ns2__CentralSymbolType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CentralSymbolType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CentralSymbolType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CentralSymbolType);
		if (size)
			*size = sizeof(ns2__CentralSymbolType);
		((ns2__CentralSymbolType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CentralSymbolType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CentralSymbolType);
		for (int i = 0; i < n; i++)
			((ns2__CentralSymbolType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CentralSymbolType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CentralSymbolType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CentralSymbolType %p -> %p\n", q, p));
	*(ns2__CentralSymbolType*)p = *(ns2__CentralSymbolType*)q;
}

void ns2__C2SymmetriesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__C2SymmetryType(soap, &this->ns2__C2SymmetriesType::C2bSymmetry);
	soap_default_ns2__C2SymmetryType(soap, &this->ns2__C2SymmetriesType::C2cSymmetry);
	soap_default_ns2__C2SymmetryType(soap, &this->ns2__C2SymmetriesType::C2aSymmetry);
	/* transient soap skipped */
}

void ns2__C2SymmetriesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__C2SymmetriesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__C2SymmetriesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__C2SymmetriesType(struct soap *soap, const char *tag, int id, const ns2__C2SymmetriesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__C2SymmetriesType), type))
		return soap->error;
	if (soap_out_ns2__C2SymmetryType(soap, "ns2:C2bSymmetry", -1, &(a->ns2__C2SymmetriesType::C2bSymmetry), ""))
		return soap->error;
	if (soap_out_ns2__C2SymmetryType(soap, "ns2:C2cSymmetry", -1, &(a->ns2__C2SymmetriesType::C2cSymmetry), ""))
		return soap->error;
	if (soap_out_ns2__C2SymmetryType(soap, "ns2:C2aSymmetry", -1, &(a->ns2__C2SymmetriesType::C2aSymmetry), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__C2SymmetriesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__C2SymmetriesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__C2SymmetriesType * SOAP_FMAC4 soap_in_ns2__C2SymmetriesType(struct soap *soap, const char *tag, ns2__C2SymmetriesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__C2SymmetriesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__C2SymmetriesType, sizeof(ns2__C2SymmetriesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__C2SymmetriesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__C2SymmetriesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_C2bSymmetry1 = 1;
	size_t soap_flag_C2cSymmetry1 = 1;
	size_t soap_flag_C2aSymmetry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_C2bSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__C2SymmetryType(soap, "ns2:C2bSymmetry", &(a->ns2__C2SymmetriesType::C2bSymmetry), "ns2:C2SymmetryType"))
				{	soap_flag_C2bSymmetry1--;
					continue;
				}
			if (soap_flag_C2cSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__C2SymmetryType(soap, "ns2:C2cSymmetry", &(a->ns2__C2SymmetriesType::C2cSymmetry), "ns2:C2SymmetryType"))
				{	soap_flag_C2cSymmetry1--;
					continue;
				}
			if (soap_flag_C2aSymmetry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__C2SymmetryType(soap, "ns2:C2aSymmetry", &(a->ns2__C2SymmetriesType::C2aSymmetry), "ns2:C2SymmetryType"))
				{	soap_flag_C2aSymmetry1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__C2SymmetriesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__C2SymmetriesType, 0, sizeof(ns2__C2SymmetriesType), 0, soap_copy_ns2__C2SymmetriesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_C2bSymmetry1 > 0 || soap_flag_C2cSymmetry1 > 0 || soap_flag_C2aSymmetry1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__C2SymmetriesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__C2SymmetriesType);
	if (this->soap_out(soap, tag?tag:"ns2:C2SymmetriesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__C2SymmetriesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__C2SymmetriesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__C2SymmetriesType * SOAP_FMAC4 soap_get_ns2__C2SymmetriesType(struct soap *soap, ns2__C2SymmetriesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__C2SymmetriesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__C2SymmetriesType * SOAP_FMAC2 soap_instantiate_ns2__C2SymmetriesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__C2SymmetriesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__C2SymmetriesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__C2SymmetriesType);
		if (size)
			*size = sizeof(ns2__C2SymmetriesType);
		((ns2__C2SymmetriesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__C2SymmetriesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__C2SymmetriesType);
		for (int i = 0; i < n; i++)
			((ns2__C2SymmetriesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__C2SymmetriesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__C2SymmetriesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__C2SymmetriesType %p -> %p\n", q, p));
	*(ns2__C2SymmetriesType*)p = *(ns2__C2SymmetriesType*)q;
}

void ns2__BondArrayType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__ns2__BondArrayType_sequence(soap, &this->ns2__BondArrayType::__BondArrayType_sequence);
	/* transient soap skipped */
}

void ns2__BondArrayType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__ns2__BondArrayType_sequence(soap, &this->ns2__BondArrayType::__BondArrayType_sequence);
	/* transient soap skipped */
}

int ns2__BondArrayType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BondArrayType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BondArrayType(struct soap *soap, const char *tag, int id, const ns2__BondArrayType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BondArrayType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__ns2__BondArrayType_sequence(soap, "-BondArrayType-sequence", -1, &(a->ns2__BondArrayType::__BondArrayType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__BondArrayType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BondArrayType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BondArrayType * SOAP_FMAC4 soap_in_ns2__BondArrayType(struct soap *soap, const char *tag, ns2__BondArrayType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BondArrayType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BondArrayType, sizeof(ns2__BondArrayType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__BondArrayType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__BondArrayType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__BondArrayType_sequence(soap, "-BondArrayType-sequence", &(a->ns2__BondArrayType::__BondArrayType_sequence), "-ns2:BondArrayType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BondArrayType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BondArrayType, 0, sizeof(ns2__BondArrayType), 0, soap_copy_ns2__BondArrayType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__BondArrayType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__BondArrayType);
	if (this->soap_out(soap, tag?tag:"ns2:BondArrayType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BondArrayType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BondArrayType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BondArrayType * SOAP_FMAC4 soap_get_ns2__BondArrayType(struct soap *soap, ns2__BondArrayType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BondArrayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__BondArrayType * SOAP_FMAC2 soap_instantiate_ns2__BondArrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BondArrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__BondArrayType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__BondArrayType);
		if (size)
			*size = sizeof(ns2__BondArrayType);
		((ns2__BondArrayType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__BondArrayType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__BondArrayType);
		for (int i = 0; i < n; i++)
			((ns2__BondArrayType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__BondArrayType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__BondArrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__BondArrayType %p -> %p\n", q, p));
	*(ns2__BondArrayType*)p = *(ns2__BondArrayType*)q;
}

void ns2__BondType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BondType::atomRefs2 = NULL;
	this->ns2__BondType::order = NULL;
	/* transient soap skipped */
}

void ns2__BondType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__BondType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BondType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BondType(struct soap *soap, const char *tag, int id, const ns2__BondType *a, const char *type)
{
	if (((ns2__BondType*)a)->atomRefs2)
		soap_set_attr(soap, "atomRefs2", ((ns2__BondType*)a)->atomRefs2->c_str(), 1);
	if (((ns2__BondType*)a)->order)
		soap_set_attr(soap, "order", ((ns2__BondType*)a)->order->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BondType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__BondType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BondType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BondType * SOAP_FMAC4 soap_in_ns2__BondType(struct soap *soap, const char *tag, ns2__BondType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BondType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BondType, sizeof(ns2__BondType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__BondType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__BondType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "atomRefs2", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__BondType*)a)->atomRefs2 = soap_new_std__string(soap, -1);
				((ns2__BondType*)a)->atomRefs2->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "order", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__BondType*)a)->order = soap_new_std__string(soap, -1);
				((ns2__BondType*)a)->order->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BondType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BondType, 0, sizeof(ns2__BondType), 0, soap_copy_ns2__BondType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__BondType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__BondType);
	if (this->soap_out(soap, tag?tag:"ns2:BondType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BondType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BondType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BondType * SOAP_FMAC4 soap_get_ns2__BondType(struct soap *soap, ns2__BondType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BondType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__BondType * SOAP_FMAC2 soap_instantiate_ns2__BondType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BondType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__BondType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__BondType);
		if (size)
			*size = sizeof(ns2__BondType);
		((ns2__BondType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__BondType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__BondType);
		for (int i = 0; i < n; i++)
			((ns2__BondType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__BondType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__BondType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__BondType %p -> %p\n", q, p));
	*(ns2__BondType*)p = *(ns2__BondType*)q;
}

void ns2__AtomNType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomNType::nuclearSpinID = NULL;
	this->ns2__AtomNType::elementSymbol = NULL;
	this->ns2__AtomNType::isotope = NULL;
	this->ns2__AtomNType::nuclearSpin = NULL;
	this->ns2__AtomNType::hydrogenCount = NULL;
	this->ns2__AtomNType::count = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__AtomNType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__AtomNType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomNType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomNType(struct soap *soap, const char *tag, int id, const ns2__AtomNType *a, const char *type)
{
	if (((ns2__AtomNType*)a)->nuclearSpinID)
		soap_set_attr(soap, "nuclearSpinID", ((ns2__AtomNType*)a)->nuclearSpinID->c_str(), 1);
	if (((ns2__AtomNType*)a)->elementSymbol)
		soap_set_attr(soap, "elementSymbol", ((ns2__AtomNType*)a)->elementSymbol->c_str(), 1);
	if (((ns2__AtomNType*)a)->isotope)
		soap_set_attr(soap, "isotope", ((ns2__AtomNType*)a)->isotope->c_str(), 1);
	if (((ns2__AtomNType*)a)->nuclearSpin)
		soap_set_attr(soap, "nuclearSpin", ((ns2__AtomNType*)a)->nuclearSpin->c_str(), 1);
	if (((ns2__AtomNType*)a)->hydrogenCount)
		soap_set_attr(soap, "hydrogenCount", ((ns2__AtomNType*)a)->hydrogenCount->c_str(), 1);
	if (((ns2__AtomNType*)a)->count)
		soap_set_attr(soap, "count", ((ns2__AtomNType*)a)->count->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomNType), "ns2:AtomNType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomNType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomNType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomNType * SOAP_FMAC4 soap_in_ns2__AtomNType(struct soap *soap, const char *tag, ns2__AtomNType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomNType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomNType, sizeof(ns2__AtomNType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomNType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomNType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "nuclearSpinID", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AtomNType*)a)->nuclearSpinID = soap_new_std__string(soap, -1);
				((ns2__AtomNType*)a)->nuclearSpinID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "elementSymbol", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AtomNType*)a)->elementSymbol = soap_new_std__string(soap, -1);
				((ns2__AtomNType*)a)->elementSymbol->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "isotope", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AtomNType*)a)->isotope = soap_new_std__string(soap, -1);
				((ns2__AtomNType*)a)->isotope->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "nuclearSpin", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AtomNType*)a)->nuclearSpin = soap_new_std__string(soap, -1);
				((ns2__AtomNType*)a)->nuclearSpin->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hydrogenCount", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AtomNType*)a)->hydrogenCount = soap_new_std__string(soap, -1);
				((ns2__AtomNType*)a)->hydrogenCount->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__AtomNType*)a)->count = soap_new_std__string(soap, -1);
				((ns2__AtomNType*)a)->count->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomNType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomNType, 0, sizeof(ns2__AtomNType), 0, soap_copy_ns2__AtomNType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomNType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomNType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomNType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomNType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomNType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomNType * SOAP_FMAC4 soap_get_ns2__AtomNType(struct soap *soap, ns2__AtomNType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomNType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomNType * SOAP_FMAC2 soap_instantiate_ns2__AtomNType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomNType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomNType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomNType);
		if (size)
			*size = sizeof(ns2__AtomNType);
		((ns2__AtomNType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomNType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomNType);
		for (int i = 0; i < n; i++)
			((ns2__AtomNType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomNType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomNType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomNType %p -> %p\n", q, p));
	*(ns2__AtomNType*)p = *(ns2__AtomNType*)q;
}

void ns2__AtomArrayType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__ns2__AtomArrayType_sequence(soap, &this->ns2__AtomArrayType::__AtomArrayType_sequence);
	/* transient soap skipped */
}

void ns2__AtomArrayType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__ns2__AtomArrayType_sequence(soap, &this->ns2__AtomArrayType::__AtomArrayType_sequence);
	/* transient soap skipped */
}

int ns2__AtomArrayType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomArrayType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomArrayType(struct soap *soap, const char *tag, int id, const ns2__AtomArrayType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomArrayType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__ns2__AtomArrayType_sequence(soap, "-AtomArrayType-sequence", -1, &(a->ns2__AtomArrayType::__AtomArrayType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomArrayType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomArrayType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomArrayType * SOAP_FMAC4 soap_in_ns2__AtomArrayType(struct soap *soap, const char *tag, ns2__AtomArrayType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomArrayType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomArrayType, sizeof(ns2__AtomArrayType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomArrayType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomArrayType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__AtomArrayType_sequence(soap, "-AtomArrayType-sequence", &(a->ns2__AtomArrayType::__AtomArrayType_sequence), "-ns2:AtomArrayType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomArrayType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomArrayType, 0, sizeof(ns2__AtomArrayType), 0, soap_copy_ns2__AtomArrayType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomArrayType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomArrayType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomArrayType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomArrayType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomArrayType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomArrayType * SOAP_FMAC4 soap_get_ns2__AtomArrayType(struct soap *soap, ns2__AtomArrayType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomArrayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomArrayType * SOAP_FMAC2 soap_instantiate_ns2__AtomArrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomArrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomArrayType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomArrayType);
		if (size)
			*size = sizeof(ns2__AtomArrayType);
		((ns2__AtomArrayType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomArrayType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomArrayType);
		for (int i = 0; i < n; i++)
			((ns2__AtomArrayType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomArrayType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomArrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomArrayType %p -> %p\n", q, p));
	*(ns2__AtomArrayType*)p = *(ns2__AtomArrayType*)q;
}

void ns2__HinderedMotionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HinderedMotionType::HinderedK1 = NULL;
	this->ns2__HinderedMotionType::HinderedK2 = NULL;
	/* transient soap skipped */
}

void ns2__HinderedMotionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HinderedMotionType::HinderedK1);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__HinderedMotionType::HinderedK2);
	/* transient soap skipped */
}

int ns2__HinderedMotionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HinderedMotionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HinderedMotionType(struct soap *soap, const char *tag, int id, const ns2__HinderedMotionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HinderedMotionType), type))
		return soap->error;
	if (a->ns2__HinderedMotionType::HinderedK1)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:HinderedK1", -1, &a->ns2__HinderedMotionType::HinderedK1, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HinderedK1"))
		return soap->error;
	if (a->ns2__HinderedMotionType::HinderedK2)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:HinderedK2", -1, &a->ns2__HinderedMotionType::HinderedK2, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HinderedK2"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HinderedMotionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HinderedMotionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HinderedMotionType * SOAP_FMAC4 soap_in_ns2__HinderedMotionType(struct soap *soap, const char *tag, ns2__HinderedMotionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HinderedMotionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HinderedMotionType, sizeof(ns2__HinderedMotionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HinderedMotionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HinderedMotionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_HinderedK11 = 1;
	size_t soap_flag_HinderedK21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HinderedK11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:HinderedK1", &(a->ns2__HinderedMotionType::HinderedK1), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_HinderedK11--;
					continue;
				}
			if (soap_flag_HinderedK21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:HinderedK2", &(a->ns2__HinderedMotionType::HinderedK2), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_HinderedK21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HinderedMotionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HinderedMotionType, 0, sizeof(ns2__HinderedMotionType), 0, soap_copy_ns2__HinderedMotionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HinderedK11 > 0 || soap_flag_HinderedK21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HinderedMotionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HinderedMotionType);
	if (this->soap_out(soap, tag?tag:"ns2:HinderedMotionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HinderedMotionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HinderedMotionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HinderedMotionType * SOAP_FMAC4 soap_get_ns2__HinderedMotionType(struct soap *soap, ns2__HinderedMotionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HinderedMotionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HinderedMotionType * SOAP_FMAC2 soap_instantiate_ns2__HinderedMotionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HinderedMotionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HinderedMotionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HinderedMotionType);
		if (size)
			*size = sizeof(ns2__HinderedMotionType);
		((ns2__HinderedMotionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HinderedMotionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HinderedMotionType);
		for (int i = 0; i < n; i++)
			((ns2__HinderedMotionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HinderedMotionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HinderedMotionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HinderedMotionType %p -> %p\n", q, p));
	*(ns2__HinderedMotionType*)p = *(ns2__HinderedMotionType*)q;
}

void ns2__AsymmetricProjectionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AsymmetricProjectionType::AsymmetricTau = NULL;
	this->ns2__AsymmetricProjectionType::AsymmetricKa = NULL;
	this->ns2__AsymmetricProjectionType::AsymmetricKc = NULL;
	/* transient soap skipped */
}

void ns2__AsymmetricProjectionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MagneticQuantumNumberType(soap, &this->ns2__AsymmetricProjectionType::AsymmetricTau);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__AsymmetricProjectionType::AsymmetricKa);
	soap_serialize_PointerTons2__MolecularQuantumNumberType(soap, &this->ns2__AsymmetricProjectionType::AsymmetricKc);
	/* transient soap skipped */
}

int ns2__AsymmetricProjectionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AsymmetricProjectionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AsymmetricProjectionType(struct soap *soap, const char *tag, int id, const ns2__AsymmetricProjectionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AsymmetricProjectionType), type))
		return soap->error;
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, "ns2:AsymmetricTau", -1, &(a->ns2__AsymmetricProjectionType::AsymmetricTau), ""))
		return soap->error;
	if (a->ns2__AsymmetricProjectionType::AsymmetricKa)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:AsymmetricKa", -1, &a->ns2__AsymmetricProjectionType::AsymmetricKa, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:AsymmetricKa"))
		return soap->error;
	if (a->ns2__AsymmetricProjectionType::AsymmetricKc)
	{	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, "ns2:AsymmetricKc", -1, &a->ns2__AsymmetricProjectionType::AsymmetricKc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:AsymmetricKc"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AsymmetricProjectionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AsymmetricProjectionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AsymmetricProjectionType * SOAP_FMAC4 soap_in_ns2__AsymmetricProjectionType(struct soap *soap, const char *tag, ns2__AsymmetricProjectionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AsymmetricProjectionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AsymmetricProjectionType, sizeof(ns2__AsymmetricProjectionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AsymmetricProjectionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AsymmetricProjectionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AsymmetricTau1 = 1;
	size_t soap_flag_AsymmetricKa1 = 1;
	size_t soap_flag_AsymmetricKc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AsymmetricTau1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MagneticQuantumNumberType(soap, "ns2:AsymmetricTau", &(a->ns2__AsymmetricProjectionType::AsymmetricTau), "ns2:MagneticQuantumNumberType"))
				{	soap_flag_AsymmetricTau1--;
					continue;
				}
			if (soap_flag_AsymmetricKa1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:AsymmetricKa", &(a->ns2__AsymmetricProjectionType::AsymmetricKa), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_AsymmetricKa1--;
					continue;
				}
			if (soap_flag_AsymmetricKc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MolecularQuantumNumberType(soap, "ns2:AsymmetricKc", &(a->ns2__AsymmetricProjectionType::AsymmetricKc), "ns2:MolecularQuantumNumberType"))
				{	soap_flag_AsymmetricKc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AsymmetricProjectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AsymmetricProjectionType, 0, sizeof(ns2__AsymmetricProjectionType), 0, soap_copy_ns2__AsymmetricProjectionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AsymmetricKa1 > 0 || soap_flag_AsymmetricKc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AsymmetricProjectionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AsymmetricProjectionType);
	if (this->soap_out(soap, tag?tag:"ns2:AsymmetricProjectionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AsymmetricProjectionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AsymmetricProjectionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AsymmetricProjectionType * SOAP_FMAC4 soap_get_ns2__AsymmetricProjectionType(struct soap *soap, ns2__AsymmetricProjectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AsymmetricProjectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AsymmetricProjectionType * SOAP_FMAC2 soap_instantiate_ns2__AsymmetricProjectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AsymmetricProjectionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AsymmetricProjectionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AsymmetricProjectionType);
		if (size)
			*size = sizeof(ns2__AsymmetricProjectionType);
		((ns2__AsymmetricProjectionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AsymmetricProjectionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AsymmetricProjectionType);
		for (int i = 0; i < n; i++)
			((ns2__AsymmetricProjectionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AsymmetricProjectionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AsymmetricProjectionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AsymmetricProjectionType %p -> %p\n", q, p));
	*(ns2__AsymmetricProjectionType*)p = *(ns2__AsymmetricProjectionType*)q;
}

void ns2__SuperShellType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->ns2__SuperShellType::PrincipalQuantumNumber);
	soap_default_double(soap, &this->ns2__SuperShellType::NumberOfElectrons);
	/* transient soap skipped */
}

void ns2__SuperShellType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__SuperShellType::PrincipalQuantumNumber, SOAP_TYPE_xsd__positiveInteger);
	soap_serialize_xsd__positiveInteger(soap, &this->ns2__SuperShellType::PrincipalQuantumNumber);
	soap_embedded(soap, &this->ns2__SuperShellType::NumberOfElectrons, SOAP_TYPE_double);
	/* transient soap skipped */
}

int ns2__SuperShellType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SuperShellType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SuperShellType(struct soap *soap, const char *tag, int id, const ns2__SuperShellType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SuperShellType), type))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "ns2:PrincipalQuantumNumber", -1, &(a->ns2__SuperShellType::PrincipalQuantumNumber), ""))
		return soap->error;
	if (soap_out_double(soap, "ns2:NumberOfElectrons", -1, &(a->ns2__SuperShellType::NumberOfElectrons), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SuperShellType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SuperShellType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SuperShellType * SOAP_FMAC4 soap_in_ns2__SuperShellType(struct soap *soap, const char *tag, ns2__SuperShellType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SuperShellType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SuperShellType, sizeof(ns2__SuperShellType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SuperShellType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SuperShellType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PrincipalQuantumNumber1 = 1;
	size_t soap_flag_NumberOfElectrons1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrincipalQuantumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns2:PrincipalQuantumNumber", &(a->ns2__SuperShellType::PrincipalQuantumNumber), "xsd:positiveInteger"))
				{	soap_flag_PrincipalQuantumNumber1--;
					continue;
				}
			if (soap_flag_NumberOfElectrons1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:NumberOfElectrons", &(a->ns2__SuperShellType::NumberOfElectrons), "xsd:double"))
				{	soap_flag_NumberOfElectrons1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SuperShellType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SuperShellType, 0, sizeof(ns2__SuperShellType), 0, soap_copy_ns2__SuperShellType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrincipalQuantumNumber1 > 0 || soap_flag_NumberOfElectrons1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SuperShellType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SuperShellType);
	if (this->soap_out(soap, tag?tag:"ns2:SuperShellType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SuperShellType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SuperShellType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SuperShellType * SOAP_FMAC4 soap_get_ns2__SuperShellType(struct soap *soap, ns2__SuperShellType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SuperShellType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SuperShellType * SOAP_FMAC2 soap_instantiate_ns2__SuperShellType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SuperShellType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SuperShellType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SuperShellType);
		if (size)
			*size = sizeof(ns2__SuperShellType);
		((ns2__SuperShellType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SuperShellType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SuperShellType);
		for (int i = 0; i < n; i++)
			((ns2__SuperShellType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SuperShellType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SuperShellType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SuperShellType %p -> %p\n", q, p));
	*(ns2__SuperShellType*)p = *(ns2__SuperShellType*)q;
}

void ns2__SuperConfigurationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__SuperShellType(soap, &this->ns2__SuperConfigurationType::SuperShell);
	/* transient soap skipped */
}

void ns2__SuperConfigurationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__SuperShellType(soap, &this->ns2__SuperConfigurationType::SuperShell);
	/* transient soap skipped */
}

int ns2__SuperConfigurationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SuperConfigurationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SuperConfigurationType(struct soap *soap, const char *tag, int id, const ns2__SuperConfigurationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SuperConfigurationType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__SuperShellType(soap, "ns2:SuperShell", -1, &(a->ns2__SuperConfigurationType::SuperShell), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SuperConfigurationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SuperConfigurationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SuperConfigurationType * SOAP_FMAC4 soap_in_ns2__SuperConfigurationType(struct soap *soap, const char *tag, ns2__SuperConfigurationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SuperConfigurationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SuperConfigurationType, sizeof(ns2__SuperConfigurationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SuperConfigurationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SuperConfigurationType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__SuperShellType(soap, "ns2:SuperShell", &(a->ns2__SuperConfigurationType::SuperShell), "ns2:SuperShellType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SuperConfigurationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SuperConfigurationType, 0, sizeof(ns2__SuperConfigurationType), 0, soap_copy_ns2__SuperConfigurationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SuperConfigurationType::SuperShell.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SuperConfigurationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SuperConfigurationType);
	if (this->soap_out(soap, tag?tag:"ns2:SuperConfigurationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SuperConfigurationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SuperConfigurationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SuperConfigurationType * SOAP_FMAC4 soap_get_ns2__SuperConfigurationType(struct soap *soap, ns2__SuperConfigurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SuperConfigurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SuperConfigurationType * SOAP_FMAC2 soap_instantiate_ns2__SuperConfigurationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SuperConfigurationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SuperConfigurationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SuperConfigurationType);
		if (size)
			*size = sizeof(ns2__SuperConfigurationType);
		((ns2__SuperConfigurationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SuperConfigurationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SuperConfigurationType);
		for (int i = 0; i < n; i++)
			((ns2__SuperConfigurationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SuperConfigurationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SuperConfigurationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SuperConfigurationType %p -> %p\n", q, p));
	*(ns2__SuperConfigurationType*)p = *(ns2__SuperConfigurationType*)q;
}

void ns2__ShellType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__PrincipalQuantumNumberType(soap, &this->ns2__ShellType::PrincipalQuantumNumber);
	this->ns2__ShellType::OrbitalAngularMomentum = NULL;
	soap_default_double(soap, &this->ns2__ShellType::NumberOfElectrons);
	this->ns2__ShellType::Parity = NULL;
	this->ns2__ShellType::Kappa = NULL;
	this->ns2__ShellType::TotalAngularMomentum = NULL;
	this->ns2__ShellType::ShellTerm = NULL;
	this->ns2__ShellType::shellID = NULL;
	/* transient soap skipped */
}

void ns2__ShellType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns2__PrincipalQuantumNumberType(soap, &this->ns2__ShellType::PrincipalQuantumNumber);
	soap_serialize_PointerTons2__OrbitalAngularMomentumType(soap, &this->ns2__ShellType::OrbitalAngularMomentum);
	soap_embedded(soap, &this->ns2__ShellType::NumberOfElectrons, SOAP_TYPE_double);
	soap_serialize_PointerTons2__ParityType(soap, &this->ns2__ShellType::Parity);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__ShellType::Kappa);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__ShellType::TotalAngularMomentum);
	soap_serialize_PointerTons2__TermType(soap, &this->ns2__ShellType::ShellTerm);
	/* transient soap skipped */
}

int ns2__ShellType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ShellType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShellType(struct soap *soap, const char *tag, int id, const ns2__ShellType *a, const char *type)
{
	if (((ns2__ShellType*)a)->shellID)
		soap_set_attr(soap, "shellID", ((ns2__ShellType*)a)->shellID->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShellType), type))
		return soap->error;
	if (soap_out_ns2__PrincipalQuantumNumberType(soap, "ns2:PrincipalQuantumNumber", -1, &(a->ns2__ShellType::PrincipalQuantumNumber), ""))
		return soap->error;
	if (a->ns2__ShellType::OrbitalAngularMomentum)
	{	if (soap_out_PointerTons2__OrbitalAngularMomentumType(soap, "ns2:OrbitalAngularMomentum", -1, &a->ns2__ShellType::OrbitalAngularMomentum, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:OrbitalAngularMomentum"))
		return soap->error;
	if (soap_out_double(soap, "ns2:NumberOfElectrons", -1, &(a->ns2__ShellType::NumberOfElectrons), ""))
		return soap->error;
	if (soap_out_PointerTons2__ParityType(soap, "ns2:Parity", -1, &(a->ns2__ShellType::Parity), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:Kappa", -1, &(a->ns2__ShellType::Kappa), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:TotalAngularMomentum", -1, &(a->ns2__ShellType::TotalAngularMomentum), ""))
		return soap->error;
	if (soap_out_PointerTons2__TermType(soap, "ns2:ShellTerm", -1, &(a->ns2__ShellType::ShellTerm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ShellType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ShellType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ShellType * SOAP_FMAC4 soap_in_ns2__ShellType(struct soap *soap, const char *tag, ns2__ShellType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ShellType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShellType, sizeof(ns2__ShellType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ShellType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ShellType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "shellID", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__ShellType*)a)->shellID = soap_new_std__string(soap, -1);
				((ns2__ShellType*)a)->shellID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_PrincipalQuantumNumber1 = 1;
	size_t soap_flag_OrbitalAngularMomentum1 = 1;
	size_t soap_flag_NumberOfElectrons1 = 1;
	size_t soap_flag_Parity1 = 1;
	size_t soap_flag_Kappa1 = 1;
	size_t soap_flag_TotalAngularMomentum1 = 1;
	size_t soap_flag_ShellTerm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrincipalQuantumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__PrincipalQuantumNumberType(soap, "ns2:PrincipalQuantumNumber", &(a->ns2__ShellType::PrincipalQuantumNumber), "ns2:PrincipalQuantumNumberType"))
				{	soap_flag_PrincipalQuantumNumber1--;
					continue;
				}
			if (soap_flag_OrbitalAngularMomentum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OrbitalAngularMomentumType(soap, "ns2:OrbitalAngularMomentum", &(a->ns2__ShellType::OrbitalAngularMomentum), "ns2:OrbitalAngularMomentumType"))
				{	soap_flag_OrbitalAngularMomentum1--;
					continue;
				}
			if (soap_flag_NumberOfElectrons1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:NumberOfElectrons", &(a->ns2__ShellType::NumberOfElectrons), "xsd:double"))
				{	soap_flag_NumberOfElectrons1--;
					continue;
				}
			if (soap_flag_Parity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParityType(soap, "ns2:Parity", &(a->ns2__ShellType::Parity), "ns2:ParityType"))
				{	soap_flag_Parity1--;
					continue;
				}
			if (soap_flag_Kappa1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:Kappa", &(a->ns2__ShellType::Kappa), "ns2:AngularMomentumType"))
				{	soap_flag_Kappa1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:TotalAngularMomentum", &(a->ns2__ShellType::TotalAngularMomentum), "ns2:AngularMomentumType"))
				{	soap_flag_TotalAngularMomentum1--;
					continue;
				}
			if (soap_flag_ShellTerm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TermType(soap, "ns2:ShellTerm", &(a->ns2__ShellType::ShellTerm), "ns2:TermType"))
				{	soap_flag_ShellTerm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ShellType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShellType, 0, sizeof(ns2__ShellType), 0, soap_copy_ns2__ShellType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrincipalQuantumNumber1 > 0 || soap_flag_OrbitalAngularMomentum1 > 0 || soap_flag_NumberOfElectrons1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ShellType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ShellType);
	if (this->soap_out(soap, tag?tag:"ns2:ShellType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ShellType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ShellType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ShellType * SOAP_FMAC4 soap_get_ns2__ShellType(struct soap *soap, ns2__ShellType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShellType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ShellType * SOAP_FMAC2 soap_instantiate_ns2__ShellType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ShellType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ShellType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ShellType);
		if (size)
			*size = sizeof(ns2__ShellType);
		((ns2__ShellType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ShellType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ShellType);
		for (int i = 0; i < n; i++)
			((ns2__ShellType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ShellType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ShellType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ShellType %p -> %p\n", q, p));
	*(ns2__ShellType*)p = *(ns2__ShellType*)q;
}

void ns2__ShellPairType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ShellPairType::Shell1 = NULL;
	this->ns2__ShellPairType::Shell2 = NULL;
	this->ns2__ShellPairType::ShellPairTerm = NULL;
	soap_default_xsd__ID(soap, &this->ns2__ShellPairType::shellPairID);
	/* transient soap skipped */
}

void ns2__ShellPairType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ShellType(soap, &this->ns2__ShellPairType::Shell1);
	soap_serialize_PointerTons2__ShellType(soap, &this->ns2__ShellPairType::Shell2);
	soap_serialize_PointerTons2__TermType(soap, &this->ns2__ShellPairType::ShellPairTerm);
	/* transient soap skipped */
}

int ns2__ShellPairType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ShellPairType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShellPairType(struct soap *soap, const char *tag, int id, const ns2__ShellPairType *a, const char *type)
{
	soap_set_attr(soap, "shellPairID", ((ns2__ShellPairType*)a)->shellPairID.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShellPairType), type))
		return soap->error;
	if (a->ns2__ShellPairType::Shell1)
	{	if (soap_out_PointerTons2__ShellType(soap, "ns2:Shell1", -1, &a->ns2__ShellPairType::Shell1, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Shell1"))
		return soap->error;
	if (a->ns2__ShellPairType::Shell2)
	{	if (soap_out_PointerTons2__ShellType(soap, "ns2:Shell2", -1, &a->ns2__ShellPairType::Shell2, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Shell2"))
		return soap->error;
	if (a->ns2__ShellPairType::ShellPairTerm)
	{	if (soap_out_PointerTons2__TermType(soap, "ns2:ShellPairTerm", -1, &a->ns2__ShellPairType::ShellPairTerm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ShellPairTerm"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ShellPairType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ShellPairType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ShellPairType * SOAP_FMAC4 soap_in_ns2__ShellPairType(struct soap *soap, const char *tag, ns2__ShellPairType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ShellPairType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShellPairType, sizeof(ns2__ShellPairType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ShellPairType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ShellPairType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "shellPairID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__ShellPairType*)a)->shellPairID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Shell11 = 1;
	size_t soap_flag_Shell21 = 1;
	size_t soap_flag_ShellPairTerm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Shell11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShellType(soap, "ns2:Shell1", &(a->ns2__ShellPairType::Shell1), "ns2:ShellType"))
				{	soap_flag_Shell11--;
					continue;
				}
			if (soap_flag_Shell21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShellType(soap, "ns2:Shell2", &(a->ns2__ShellPairType::Shell2), "ns2:ShellType"))
				{	soap_flag_Shell21--;
					continue;
				}
			if (soap_flag_ShellPairTerm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TermType(soap, "ns2:ShellPairTerm", &(a->ns2__ShellPairType::ShellPairTerm), "ns2:TermType"))
				{	soap_flag_ShellPairTerm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ShellPairType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShellPairType, 0, sizeof(ns2__ShellPairType), 0, soap_copy_ns2__ShellPairType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Shell11 > 0 || soap_flag_Shell21 > 0 || soap_flag_ShellPairTerm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ShellPairType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ShellPairType);
	if (this->soap_out(soap, tag?tag:"ns2:ShellPairType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ShellPairType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ShellPairType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ShellPairType * SOAP_FMAC4 soap_get_ns2__ShellPairType(struct soap *soap, ns2__ShellPairType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShellPairType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ShellPairType * SOAP_FMAC2 soap_instantiate_ns2__ShellPairType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ShellPairType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ShellPairType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ShellPairType);
		if (size)
			*size = sizeof(ns2__ShellPairType);
		((ns2__ShellPairType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ShellPairType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ShellPairType);
		for (int i = 0; i < n; i++)
			((ns2__ShellPairType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ShellPairType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ShellPairType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ShellPairType %p -> %p\n", q, p));
	*(ns2__ShellPairType*)p = *(ns2__ShellPairType*)q;
}

void ns2__ShellsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ShellType(soap, &this->ns2__ShellsType::Shell);
	soap_default_std__vectorTemplateOf__ns2__ShellsType_sequence(soap, &this->ns2__ShellsType::__ShellsType_sequence);
	/* transient soap skipped */
}

void ns2__ShellsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ShellType(soap, &this->ns2__ShellsType::Shell);
	soap_serialize_std__vectorTemplateOf__ns2__ShellsType_sequence(soap, &this->ns2__ShellsType::__ShellsType_sequence);
	/* transient soap skipped */
}

int ns2__ShellsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ShellsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShellsType(struct soap *soap, const char *tag, int id, const ns2__ShellsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShellsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ShellType(soap, "ns2:Shell", -1, &(a->ns2__ShellsType::Shell), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__ns2__ShellsType_sequence(soap, "-ShellsType-sequence", -1, &(a->ns2__ShellsType::__ShellsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ShellsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ShellsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ShellsType * SOAP_FMAC4 soap_in_ns2__ShellsType(struct soap *soap, const char *tag, ns2__ShellsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ShellsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShellsType, sizeof(ns2__ShellsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ShellsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ShellsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ShellType(soap, "ns2:Shell", &(a->ns2__ShellsType::Shell), "ns2:ShellType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__ShellsType_sequence(soap, "-ShellsType-sequence", &(a->ns2__ShellsType::__ShellsType_sequence), "-ns2:ShellsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ShellsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShellsType, 0, sizeof(ns2__ShellsType), 0, soap_copy_ns2__ShellsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ShellsType::Shell.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ShellsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ShellsType);
	if (this->soap_out(soap, tag?tag:"ns2:ShellsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ShellsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ShellsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ShellsType * SOAP_FMAC4 soap_get_ns2__ShellsType(struct soap *soap, ns2__ShellsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShellsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ShellsType * SOAP_FMAC2 soap_instantiate_ns2__ShellsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ShellsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ShellsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ShellsType);
		if (size)
			*size = sizeof(ns2__ShellsType);
		((ns2__ShellsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ShellsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ShellsType);
		for (int i = 0; i < n; i++)
			((ns2__ShellsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ShellsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ShellsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ShellsType %p -> %p\n", q, p));
	*(ns2__ShellsType*)p = *(ns2__ShellsType*)q;
}

void ns2__ConfigurationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ConfigurationType::AtomicCore = NULL;
	this->ns2__ConfigurationType::Shells = NULL;
	this->ns2__ConfigurationType::ConfigurationLabel = NULL;
	/* transient soap skipped */
}

void ns2__ConfigurationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AtomicCoreType(soap, &this->ns2__ConfigurationType::AtomicCore);
	soap_serialize_PointerTons2__ShellsType(soap, &this->ns2__ConfigurationType::Shells);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ConfigurationType::ConfigurationLabel);
	/* transient soap skipped */
}

int ns2__ConfigurationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ConfigurationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConfigurationType(struct soap *soap, const char *tag, int id, const ns2__ConfigurationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConfigurationType), type))
		return soap->error;
	if (soap_out_PointerTons2__AtomicCoreType(soap, "ns2:AtomicCore", -1, &(a->ns2__ConfigurationType::AtomicCore), ""))
		return soap->error;
	if (soap_out_PointerTons2__ShellsType(soap, "ns2:Shells", -1, &(a->ns2__ConfigurationType::Shells), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:ConfigurationLabel", -1, &(a->ns2__ConfigurationType::ConfigurationLabel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ConfigurationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ConfigurationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ConfigurationType * SOAP_FMAC4 soap_in_ns2__ConfigurationType(struct soap *soap, const char *tag, ns2__ConfigurationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ConfigurationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConfigurationType, sizeof(ns2__ConfigurationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ConfigurationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ConfigurationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AtomicCore1 = 1;
	size_t soap_flag_Shells1 = 1;
	size_t soap_flag_ConfigurationLabel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AtomicCore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomicCoreType(soap, "ns2:AtomicCore", &(a->ns2__ConfigurationType::AtomicCore), "ns2:AtomicCoreType"))
				{	soap_flag_AtomicCore1--;
					continue;
				}
			if (soap_flag_Shells1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShellsType(soap, "ns2:Shells", &(a->ns2__ConfigurationType::Shells), "ns2:ShellsType"))
				{	soap_flag_Shells1--;
					continue;
				}
			if (soap_flag_ConfigurationLabel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:ConfigurationLabel", &(a->ns2__ConfigurationType::ConfigurationLabel), "xsd:string"))
				{	soap_flag_ConfigurationLabel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ConfigurationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConfigurationType, 0, sizeof(ns2__ConfigurationType), 0, soap_copy_ns2__ConfigurationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ConfigurationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ConfigurationType);
	if (this->soap_out(soap, tag?tag:"ns2:ConfigurationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ConfigurationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ConfigurationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ConfigurationType * SOAP_FMAC4 soap_get_ns2__ConfigurationType(struct soap *soap, ns2__ConfigurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConfigurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ConfigurationType * SOAP_FMAC2 soap_instantiate_ns2__ConfigurationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConfigurationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConfigurationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ConfigurationType);
		if (size)
			*size = sizeof(ns2__ConfigurationType);
		((ns2__ConfigurationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ConfigurationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ConfigurationType);
		for (int i = 0; i < n; i++)
			((ns2__ConfigurationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ConfigurationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConfigurationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ConfigurationType %p -> %p\n", q, p));
	*(ns2__ConfigurationType*)p = *(ns2__ConfigurationType*)q;
}

void ns2__AtomicQuantumNumbersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomicQuantumNumbersType::Parity = NULL;
	this->ns2__AtomicQuantumNumbersType::TotalAngularMomentum = NULL;
	this->ns2__AtomicQuantumNumbersType::Kappa = NULL;
	this->ns2__AtomicQuantumNumbersType::HyperfineMomentum = NULL;
	this->ns2__AtomicQuantumNumbersType::MagneticQuantumNumber = NULL;
	/* transient soap skipped */
}

void ns2__AtomicQuantumNumbersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParityType(soap, &this->ns2__AtomicQuantumNumbersType::Parity);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__AtomicQuantumNumbersType::TotalAngularMomentum);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__AtomicQuantumNumbersType::Kappa);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__AtomicQuantumNumbersType::HyperfineMomentum);
	soap_serialize_PointerTons2__AngularMomentumProjectionType(soap, &this->ns2__AtomicQuantumNumbersType::MagneticQuantumNumber);
	/* transient soap skipped */
}

int ns2__AtomicQuantumNumbersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomicQuantumNumbersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomicQuantumNumbersType(struct soap *soap, const char *tag, int id, const ns2__AtomicQuantumNumbersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomicQuantumNumbersType), type))
		return soap->error;
	if (soap_out_PointerTons2__ParityType(soap, "ns2:Parity", -1, &(a->ns2__AtomicQuantumNumbersType::Parity), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:TotalAngularMomentum", -1, &(a->ns2__AtomicQuantumNumbersType::TotalAngularMomentum), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:Kappa", -1, &(a->ns2__AtomicQuantumNumbersType::Kappa), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:HyperfineMomentum", -1, &(a->ns2__AtomicQuantumNumbersType::HyperfineMomentum), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumProjectionType(soap, "ns2:MagneticQuantumNumber", -1, &(a->ns2__AtomicQuantumNumbersType::MagneticQuantumNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomicQuantumNumbersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomicQuantumNumbersType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomicQuantumNumbersType * SOAP_FMAC4 soap_in_ns2__AtomicQuantumNumbersType(struct soap *soap, const char *tag, ns2__AtomicQuantumNumbersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomicQuantumNumbersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomicQuantumNumbersType, sizeof(ns2__AtomicQuantumNumbersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomicQuantumNumbersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomicQuantumNumbersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Parity1 = 1;
	size_t soap_flag_TotalAngularMomentum1 = 1;
	size_t soap_flag_Kappa1 = 1;
	size_t soap_flag_HyperfineMomentum1 = 1;
	size_t soap_flag_MagneticQuantumNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParityType(soap, "ns2:Parity", &(a->ns2__AtomicQuantumNumbersType::Parity), "ns2:ParityType"))
				{	soap_flag_Parity1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:TotalAngularMomentum", &(a->ns2__AtomicQuantumNumbersType::TotalAngularMomentum), "ns2:AngularMomentumType"))
				{	soap_flag_TotalAngularMomentum1--;
					continue;
				}
			if (soap_flag_Kappa1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:Kappa", &(a->ns2__AtomicQuantumNumbersType::Kappa), "ns2:AngularMomentumType"))
				{	soap_flag_Kappa1--;
					continue;
				}
			if (soap_flag_HyperfineMomentum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:HyperfineMomentum", &(a->ns2__AtomicQuantumNumbersType::HyperfineMomentum), "ns2:AngularMomentumType"))
				{	soap_flag_HyperfineMomentum1--;
					continue;
				}
			if (soap_flag_MagneticQuantumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumProjectionType(soap, "ns2:MagneticQuantumNumber", &(a->ns2__AtomicQuantumNumbersType::MagneticQuantumNumber), "ns2:AngularMomentumProjectionType"))
				{	soap_flag_MagneticQuantumNumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomicQuantumNumbersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomicQuantumNumbersType, 0, sizeof(ns2__AtomicQuantumNumbersType), 0, soap_copy_ns2__AtomicQuantumNumbersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomicQuantumNumbersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomicQuantumNumbersType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomicQuantumNumbersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomicQuantumNumbersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomicQuantumNumbersType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomicQuantumNumbersType * SOAP_FMAC4 soap_get_ns2__AtomicQuantumNumbersType(struct soap *soap, ns2__AtomicQuantumNumbersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomicQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomicQuantumNumbersType * SOAP_FMAC2 soap_instantiate_ns2__AtomicQuantumNumbersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomicQuantumNumbersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomicQuantumNumbersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicQuantumNumbersType);
		if (size)
			*size = sizeof(ns2__AtomicQuantumNumbersType);
		((ns2__AtomicQuantumNumbersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicQuantumNumbersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomicQuantumNumbersType);
		for (int i = 0; i < n; i++)
			((ns2__AtomicQuantumNumbersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomicQuantumNumbersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomicQuantumNumbersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomicQuantumNumbersType %p -> %p\n", q, p));
	*(ns2__AtomicQuantumNumbersType*)p = *(ns2__AtomicQuantumNumbersType*)q;
}

void ns2__AtomicComponentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomicComponentType::SuperConfiguration = NULL;
	this->ns2__AtomicComponentType::Configuration = NULL;
	this->ns2__AtomicComponentType::Term = NULL;
	this->ns2__AtomicComponentType::MixingCoefficient = NULL;
	this->ns2__AtomicComponentType::Comments = NULL;
	/* transient soap skipped */
}

void ns2__AtomicComponentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SuperConfigurationType(soap, &this->ns2__AtomicComponentType::SuperConfiguration);
	soap_serialize_PointerTons2__ConfigurationType(soap, &this->ns2__AtomicComponentType::Configuration);
	soap_serialize_PointerTons2__TermType(soap, &this->ns2__AtomicComponentType::Term);
	soap_serialize_PointerTons2__MixingCoefficientType(soap, &this->ns2__AtomicComponentType::MixingCoefficient);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AtomicComponentType::Comments);
	/* transient soap skipped */
}

int ns2__AtomicComponentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomicComponentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomicComponentType(struct soap *soap, const char *tag, int id, const ns2__AtomicComponentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomicComponentType), type))
		return soap->error;
	if (soap_out_PointerTons2__SuperConfigurationType(soap, "ns2:SuperConfiguration", -1, &(a->ns2__AtomicComponentType::SuperConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTons2__ConfigurationType(soap, "ns2:Configuration", -1, &(a->ns2__AtomicComponentType::Configuration), ""))
		return soap->error;
	if (soap_out_PointerTons2__TermType(soap, "ns2:Term", -1, &(a->ns2__AtomicComponentType::Term), ""))
		return soap->error;
	if (soap_out_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", -1, &(a->ns2__AtomicComponentType::MixingCoefficient), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__AtomicComponentType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomicComponentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomicComponentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomicComponentType * SOAP_FMAC4 soap_in_ns2__AtomicComponentType(struct soap *soap, const char *tag, ns2__AtomicComponentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomicComponentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomicComponentType, sizeof(ns2__AtomicComponentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomicComponentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomicComponentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SuperConfiguration1 = 1;
	size_t soap_flag_Configuration1 = 1;
	size_t soap_flag_Term1 = 1;
	size_t soap_flag_MixingCoefficient1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SuperConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SuperConfigurationType(soap, "ns2:SuperConfiguration", &(a->ns2__AtomicComponentType::SuperConfiguration), "ns2:SuperConfigurationType"))
				{	soap_flag_SuperConfiguration1--;
					continue;
				}
			if (soap_flag_Configuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConfigurationType(soap, "ns2:Configuration", &(a->ns2__AtomicComponentType::Configuration), "ns2:ConfigurationType"))
				{	soap_flag_Configuration1--;
					continue;
				}
			if (soap_flag_Term1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TermType(soap, "ns2:Term", &(a->ns2__AtomicComponentType::Term), "ns2:TermType"))
				{	soap_flag_Term1--;
					continue;
				}
			if (soap_flag_MixingCoefficient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MixingCoefficientType(soap, "ns2:MixingCoefficient", &(a->ns2__AtomicComponentType::MixingCoefficient), "ns2:MixingCoefficientType"))
				{	soap_flag_MixingCoefficient1--;
					continue;
				}
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__AtomicComponentType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomicComponentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomicComponentType, 0, sizeof(ns2__AtomicComponentType), 0, soap_copy_ns2__AtomicComponentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomicComponentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomicComponentType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomicComponentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomicComponentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomicComponentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomicComponentType * SOAP_FMAC4 soap_get_ns2__AtomicComponentType(struct soap *soap, ns2__AtomicComponentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomicComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomicComponentType * SOAP_FMAC2 soap_instantiate_ns2__AtomicComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomicComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomicComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicComponentType);
		if (size)
			*size = sizeof(ns2__AtomicComponentType);
		((ns2__AtomicComponentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicComponentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomicComponentType);
		for (int i = 0; i < n; i++)
			((ns2__AtomicComponentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomicComponentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomicComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomicComponentType %p -> %p\n", q, p));
	*(ns2__AtomicComponentType*)p = *(ns2__AtomicComponentType*)q;
}

void ns2__AtomicCoreType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomicCoreType::ElementCore = NULL;
	this->ns2__AtomicCoreType::Configuration = NULL;
	this->ns2__AtomicCoreType::Term = NULL;
	this->ns2__AtomicCoreType::TotalAngularMomentum = NULL;
	/* transient soap skipped */
}

void ns2__AtomicCoreType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ElementSymbolType(soap, &this->ns2__AtomicCoreType::ElementCore);
	soap_serialize_PointerTons2__ConfigurationType(soap, &this->ns2__AtomicCoreType::Configuration);
	soap_serialize_PointerTons2__TermType(soap, &this->ns2__AtomicCoreType::Term);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__AtomicCoreType::TotalAngularMomentum);
	/* transient soap skipped */
}

int ns2__AtomicCoreType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomicCoreType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomicCoreType(struct soap *soap, const char *tag, int id, const ns2__AtomicCoreType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomicCoreType), type))
		return soap->error;
	if (soap_out_PointerTons2__ElementSymbolType(soap, "ns2:ElementCore", -1, &(a->ns2__AtomicCoreType::ElementCore), ""))
		return soap->error;
	if (soap_out_PointerTons2__ConfigurationType(soap, "ns2:Configuration", -1, &(a->ns2__AtomicCoreType::Configuration), ""))
		return soap->error;
	if (soap_out_PointerTons2__TermType(soap, "ns2:Term", -1, &(a->ns2__AtomicCoreType::Term), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:TotalAngularMomentum", -1, &(a->ns2__AtomicCoreType::TotalAngularMomentum), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomicCoreType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomicCoreType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomicCoreType * SOAP_FMAC4 soap_in_ns2__AtomicCoreType(struct soap *soap, const char *tag, ns2__AtomicCoreType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomicCoreType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomicCoreType, sizeof(ns2__AtomicCoreType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomicCoreType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomicCoreType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ElementCore1 = 1;
	size_t soap_flag_Configuration1 = 1;
	size_t soap_flag_Term1 = 1;
	size_t soap_flag_TotalAngularMomentum1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ElementCore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__ElementSymbolType(soap, "ns2:ElementCore", &(a->ns2__AtomicCoreType::ElementCore), "ns2:ElementSymbolType"))
				{	soap_flag_ElementCore1--;
					continue;
				}
			if (soap_flag_Configuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConfigurationType(soap, "ns2:Configuration", &(a->ns2__AtomicCoreType::Configuration), "ns2:ConfigurationType"))
				{	soap_flag_Configuration1--;
					continue;
				}
			if (soap_flag_Term1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TermType(soap, "ns2:Term", &(a->ns2__AtomicCoreType::Term), "ns2:TermType"))
				{	soap_flag_Term1--;
					continue;
				}
			if (soap_flag_TotalAngularMomentum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:TotalAngularMomentum", &(a->ns2__AtomicCoreType::TotalAngularMomentum), "ns2:AngularMomentumType"))
				{	soap_flag_TotalAngularMomentum1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomicCoreType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomicCoreType, 0, sizeof(ns2__AtomicCoreType), 0, soap_copy_ns2__AtomicCoreType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomicCoreType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomicCoreType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomicCoreType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomicCoreType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomicCoreType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomicCoreType * SOAP_FMAC4 soap_get_ns2__AtomicCoreType(struct soap *soap, ns2__AtomicCoreType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomicCoreType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomicCoreType * SOAP_FMAC2 soap_instantiate_ns2__AtomicCoreType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomicCoreType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomicCoreType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicCoreType);
		if (size)
			*size = sizeof(ns2__AtomicCoreType);
		((ns2__AtomicCoreType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicCoreType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomicCoreType);
		for (int i = 0; i < n; i++)
			((ns2__AtomicCoreType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomicCoreType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomicCoreType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomicCoreType %p -> %p\n", q, p));
	*(ns2__AtomicCoreType*)p = *(ns2__AtomicCoreType*)q;
}

void ns2__AtomicCompositionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__AtomicComponentType(soap, &this->ns2__AtomicCompositionType::Component);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__AtomicCompositionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__AtomicComponentType(soap, &this->ns2__AtomicCompositionType::Component);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__AtomicCompositionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomicCompositionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomicCompositionType(struct soap *soap, const char *tag, int id, const ns2__AtomicCompositionType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomicCompositionType), "ns2:AtomicCompositionType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__AtomicComponentType(soap, "ns2:Component", -1, &(a->ns2__AtomicCompositionType::Component), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomicCompositionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomicCompositionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomicCompositionType * SOAP_FMAC4 soap_in_ns2__AtomicCompositionType(struct soap *soap, const char *tag, ns2__AtomicCompositionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomicCompositionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomicCompositionType, sizeof(ns2__AtomicCompositionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomicCompositionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomicCompositionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__AtomicComponentType(soap, "ns2:Component", &(a->ns2__AtomicCompositionType::Component), "ns2:AtomicComponentType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomicCompositionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomicCompositionType, 0, sizeof(ns2__AtomicCompositionType), 0, soap_copy_ns2__AtomicCompositionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AtomicCompositionType::Component.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AtomicCompositionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomicCompositionType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomicCompositionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomicCompositionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomicCompositionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomicCompositionType * SOAP_FMAC4 soap_get_ns2__AtomicCompositionType(struct soap *soap, ns2__AtomicCompositionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomicCompositionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomicCompositionType * SOAP_FMAC2 soap_instantiate_ns2__AtomicCompositionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomicCompositionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomicCompositionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicCompositionType);
		if (size)
			*size = sizeof(ns2__AtomicCompositionType);
		((ns2__AtomicCompositionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicCompositionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomicCompositionType);
		for (int i = 0; i < n; i++)
			((ns2__AtomicCompositionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomicCompositionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomicCompositionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomicCompositionType %p -> %p\n", q, p));
	*(ns2__AtomicCompositionType*)p = *(ns2__AtomicCompositionType*)q;
}

void ns2__AtomicNumericalDataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomicNumericalDataType::StateEnergy = NULL;
	this->ns2__AtomicNumericalDataType::IonizationEnergy = NULL;
	this->ns2__AtomicNumericalDataType::LandeFactor = NULL;
	this->ns2__AtomicNumericalDataType::QuantumDefect = NULL;
	this->ns2__AtomicNumericalDataType::TotalLifeTime = NULL;
	this->ns2__AtomicNumericalDataType::Polarizability = NULL;
	this->ns2__AtomicNumericalDataType::StatisticalWeight = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__AtomicNumericalDataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__AtomicNumericalDataType::StateEnergy);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__AtomicNumericalDataType::IonizationEnergy);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__AtomicNumericalDataType::LandeFactor);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__AtomicNumericalDataType::QuantumDefect);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__AtomicNumericalDataType::TotalLifeTime);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__AtomicNumericalDataType::Polarizability);
	soap_serialize_PointerTodouble(soap, &this->ns2__AtomicNumericalDataType::StatisticalWeight);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__AtomicNumericalDataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomicNumericalDataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomicNumericalDataType(struct soap *soap, const char *tag, int id, const ns2__AtomicNumericalDataType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomicNumericalDataType), "ns2:AtomicNumericalDataType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__DataType(soap, "ns2:StateEnergy", -1, &(a->ns2__AtomicNumericalDataType::StateEnergy), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:IonizationEnergy", -1, &(a->ns2__AtomicNumericalDataType::IonizationEnergy), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:LandeFactor", -1, &(a->ns2__AtomicNumericalDataType::LandeFactor), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:QuantumDefect", -1, &(a->ns2__AtomicNumericalDataType::QuantumDefect), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:TotalLifeTime", -1, &(a->ns2__AtomicNumericalDataType::TotalLifeTime), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:Polarizability", -1, &(a->ns2__AtomicNumericalDataType::Polarizability), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns2:StatisticalWeight", -1, &(a->ns2__AtomicNumericalDataType::StatisticalWeight), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomicNumericalDataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomicNumericalDataType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomicNumericalDataType * SOAP_FMAC4 soap_in_ns2__AtomicNumericalDataType(struct soap *soap, const char *tag, ns2__AtomicNumericalDataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomicNumericalDataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomicNumericalDataType, sizeof(ns2__AtomicNumericalDataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomicNumericalDataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomicNumericalDataType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_StateEnergy1 = 1;
	size_t soap_flag_IonizationEnergy1 = 1;
	size_t soap_flag_LandeFactor1 = 1;
	size_t soap_flag_QuantumDefect1 = 1;
	size_t soap_flag_TotalLifeTime1 = 1;
	size_t soap_flag_Polarizability1 = 1;
	size_t soap_flag_StatisticalWeight1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_StateEnergy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:StateEnergy", &(a->ns2__AtomicNumericalDataType::StateEnergy), "ns2:DataType"))
				{	soap_flag_StateEnergy1--;
					continue;
				}
			if (soap_flag_IonizationEnergy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:IonizationEnergy", &(a->ns2__AtomicNumericalDataType::IonizationEnergy), "ns2:DataType"))
				{	soap_flag_IonizationEnergy1--;
					continue;
				}
			if (soap_flag_LandeFactor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:LandeFactor", &(a->ns2__AtomicNumericalDataType::LandeFactor), "ns2:DataType"))
				{	soap_flag_LandeFactor1--;
					continue;
				}
			if (soap_flag_QuantumDefect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:QuantumDefect", &(a->ns2__AtomicNumericalDataType::QuantumDefect), "ns2:DataType"))
				{	soap_flag_QuantumDefect1--;
					continue;
				}
			if (soap_flag_TotalLifeTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:TotalLifeTime", &(a->ns2__AtomicNumericalDataType::TotalLifeTime), "ns2:DataType"))
				{	soap_flag_TotalLifeTime1--;
					continue;
				}
			if (soap_flag_Polarizability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Polarizability", &(a->ns2__AtomicNumericalDataType::Polarizability), "ns2:DataType"))
				{	soap_flag_Polarizability1--;
					continue;
				}
			if (soap_flag_StatisticalWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns2:StatisticalWeight", &(a->ns2__AtomicNumericalDataType::StatisticalWeight), "xsd:double"))
				{	soap_flag_StatisticalWeight1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomicNumericalDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomicNumericalDataType, 0, sizeof(ns2__AtomicNumericalDataType), 0, soap_copy_ns2__AtomicNumericalDataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomicNumericalDataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomicNumericalDataType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomicNumericalDataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomicNumericalDataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomicNumericalDataType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomicNumericalDataType * SOAP_FMAC4 soap_get_ns2__AtomicNumericalDataType(struct soap *soap, ns2__AtomicNumericalDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomicNumericalDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomicNumericalDataType * SOAP_FMAC2 soap_instantiate_ns2__AtomicNumericalDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomicNumericalDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomicNumericalDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicNumericalDataType);
		if (size)
			*size = sizeof(ns2__AtomicNumericalDataType);
		((ns2__AtomicNumericalDataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicNumericalDataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomicNumericalDataType);
		for (int i = 0; i < n; i++)
			((ns2__AtomicNumericalDataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomicNumericalDataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomicNumericalDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomicNumericalDataType %p -> %p\n", q, p));
	*(ns2__AtomicNumericalDataType*)p = *(ns2__AtomicNumericalDataType*)q;
}

void ns2__AtomicStateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomicStateType::Description = NULL;
	this->ns2__AtomicStateType::AtomicNumericalData = NULL;
	this->ns2__AtomicStateType::AtomicQuantumNumbers = NULL;
	this->ns2__AtomicStateType::AtomicComposition = NULL;
	soap_default__ns2__stateID(soap, &this->ns2__AtomicStateType::ns2__stateID);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__AtomicStateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__AtomicStateType::Description);
	soap_serialize_PointerTons2__AtomicNumericalDataType(soap, &this->ns2__AtomicStateType::AtomicNumericalData);
	soap_serialize_PointerTons2__AtomicQuantumNumbersType(soap, &this->ns2__AtomicStateType::AtomicQuantumNumbers);
	soap_serialize_PointerTons2__AtomicCompositionType(soap, &this->ns2__AtomicStateType::AtomicComposition);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__AtomicStateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomicStateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomicStateType(struct soap *soap, const char *tag, int id, const ns2__AtomicStateType *a, const char *type)
{
	soap_set_attr(soap, "ns2:stateID", ((ns2__AtomicStateType*)a)->ns2__stateID.c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomicStateType), "ns2:AtomicStateType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__AtomicStateType::Description), ""))
		return soap->error;
	if (soap_out_PointerTons2__AtomicNumericalDataType(soap, "ns2:AtomicNumericalData", -1, &(a->ns2__AtomicStateType::AtomicNumericalData), ""))
		return soap->error;
	if (soap_out_PointerTons2__AtomicQuantumNumbersType(soap, "ns2:AtomicQuantumNumbers", -1, &(a->ns2__AtomicStateType::AtomicQuantumNumbers), ""))
		return soap->error;
	if (soap_out_PointerTons2__AtomicCompositionType(soap, "ns2:AtomicComposition", -1, &(a->ns2__AtomicStateType::AtomicComposition), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomicStateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomicStateType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomicStateType * SOAP_FMAC4 soap_in_ns2__AtomicStateType(struct soap *soap, const char *tag, ns2__AtomicStateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomicStateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomicStateType, sizeof(ns2__AtomicStateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomicStateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomicStateType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:stateID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__AtomicStateType*)a)->ns2__stateID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_AtomicNumericalData1 = 1;
	size_t soap_flag_AtomicQuantumNumbers1 = 1;
	size_t soap_flag_AtomicComposition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__AtomicStateType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_AtomicNumericalData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomicNumericalDataType(soap, "ns2:AtomicNumericalData", &(a->ns2__AtomicStateType::AtomicNumericalData), "ns2:AtomicNumericalDataType"))
				{	soap_flag_AtomicNumericalData1--;
					continue;
				}
			if (soap_flag_AtomicQuantumNumbers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomicQuantumNumbersType(soap, "ns2:AtomicQuantumNumbers", &(a->ns2__AtomicStateType::AtomicQuantumNumbers), "ns2:AtomicQuantumNumbersType"))
				{	soap_flag_AtomicQuantumNumbers1--;
					continue;
				}
			if (soap_flag_AtomicComposition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AtomicCompositionType(soap, "ns2:AtomicComposition", &(a->ns2__AtomicStateType::AtomicComposition), "ns2:AtomicCompositionType"))
				{	soap_flag_AtomicComposition1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomicStateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomicStateType, 0, sizeof(ns2__AtomicStateType), 0, soap_copy_ns2__AtomicStateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AtomicStateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomicStateType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomicStateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomicStateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomicStateType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomicStateType * SOAP_FMAC4 soap_get_ns2__AtomicStateType(struct soap *soap, ns2__AtomicStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomicStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomicStateType * SOAP_FMAC2 soap_instantiate_ns2__AtomicStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomicStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomicStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicStateType);
		if (size)
			*size = sizeof(ns2__AtomicStateType);
		((ns2__AtomicStateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicStateType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomicStateType);
		for (int i = 0; i < n; i++)
			((ns2__AtomicStateType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomicStateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomicStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomicStateType %p -> %p\n", q, p));
	*(ns2__AtomicStateType*)p = *(ns2__AtomicStateType*)q;
}

void ns2__IonStateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->ns2__IonStateType::IonCharge);
	this->ns2__IonStateType::IsoelectronicSequence = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__AtomicStateType(soap, &this->ns2__IonStateType::AtomicState);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__IonStateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__IonStateType::IonCharge, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns2__IonStateType::IonCharge);
	soap_serialize_PointerTons2__ElementSymbolType(soap, &this->ns2__IonStateType::IsoelectronicSequence);
	soap_serialize_std__vectorTemplateOfPointerTons2__AtomicStateType(soap, &this->ns2__IonStateType::AtomicState);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__IonStateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__IonStateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IonStateType(struct soap *soap, const char *tag, int id, const ns2__IonStateType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IonStateType), "ns2:IonStateType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__integer(soap, "ns2:IonCharge", -1, &(a->ns2__IonStateType::IonCharge), ""))
		return soap->error;
	if (soap_out_PointerTons2__ElementSymbolType(soap, "ns2:IsoelectronicSequence", -1, &(a->ns2__IonStateType::IsoelectronicSequence), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__AtomicStateType(soap, "ns2:AtomicState", -1, &(a->ns2__IonStateType::AtomicState), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__IonStateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__IonStateType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__IonStateType * SOAP_FMAC4 soap_in_ns2__IonStateType(struct soap *soap, const char *tag, ns2__IonStateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__IonStateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IonStateType, sizeof(ns2__IonStateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__IonStateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__IonStateType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_IonCharge1 = 1;
	size_t soap_flag_IsoelectronicSequence1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_IonCharge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:IonCharge", &(a->ns2__IonStateType::IonCharge), "xsd:integer"))
				{	soap_flag_IonCharge1--;
					continue;
				}
			if (soap_flag_IsoelectronicSequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__ElementSymbolType(soap, "ns2:IsoelectronicSequence", &(a->ns2__IonStateType::IsoelectronicSequence), "ns2:ElementSymbolType"))
				{	soap_flag_IsoelectronicSequence1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__AtomicStateType(soap, "ns2:AtomicState", &(a->ns2__IonStateType::AtomicState), "ns2:AtomicStateType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__IonStateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IonStateType, 0, sizeof(ns2__IonStateType), 0, soap_copy_ns2__IonStateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IonCharge1 > 0 || a->ns2__IonStateType::AtomicState.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__IonStateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__IonStateType);
	if (this->soap_out(soap, tag?tag:"ns2:IonStateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__IonStateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__IonStateType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__IonStateType * SOAP_FMAC4 soap_get_ns2__IonStateType(struct soap *soap, ns2__IonStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IonStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__IonStateType * SOAP_FMAC2 soap_instantiate_ns2__IonStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__IonStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__IonStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__IonStateType);
		if (size)
			*size = sizeof(ns2__IonStateType);
		((ns2__IonStateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__IonStateType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__IonStateType);
		for (int i = 0; i < n; i++)
			((ns2__IonStateType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__IonStateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__IonStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__IonStateType %p -> %p\n", q, p));
	*(ns2__IonStateType*)p = *(ns2__IonStateType*)q;
}

void ns2__IsotopeParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->ns2__IsotopeParametersType::MassNumber);
	this->ns2__IsotopeParametersType::Mass = NULL;
	this->ns2__IsotopeParametersType::NuclearSpin = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__IsotopeParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__IsotopeParametersType::MassNumber, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns2__IsotopeParametersType::MassNumber);
	soap_serialize_PointerTons2__DataType(soap, &this->ns2__IsotopeParametersType::Mass);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__IsotopeParametersType::NuclearSpin);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__IsotopeParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__IsotopeParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IsotopeParametersType(struct soap *soap, const char *tag, int id, const ns2__IsotopeParametersType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IsotopeParametersType), "ns2:IsotopeParametersType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__integer(soap, "ns2:MassNumber", -1, &(a->ns2__IsotopeParametersType::MassNumber), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataType(soap, "ns2:Mass", -1, &(a->ns2__IsotopeParametersType::Mass), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:NuclearSpin", -1, &(a->ns2__IsotopeParametersType::NuclearSpin), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__IsotopeParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__IsotopeParametersType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__IsotopeParametersType * SOAP_FMAC4 soap_in_ns2__IsotopeParametersType(struct soap *soap, const char *tag, ns2__IsotopeParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__IsotopeParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IsotopeParametersType, sizeof(ns2__IsotopeParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__IsotopeParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__IsotopeParametersType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_MassNumber1 = 1;
	size_t soap_flag_Mass1 = 1;
	size_t soap_flag_NuclearSpin1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_MassNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:MassNumber", &(a->ns2__IsotopeParametersType::MassNumber), "xsd:integer"))
				{	soap_flag_MassNumber1--;
					continue;
				}
			if (soap_flag_Mass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataType(soap, "ns2:Mass", &(a->ns2__IsotopeParametersType::Mass), "ns2:DataType"))
				{	soap_flag_Mass1--;
					continue;
				}
			if (soap_flag_NuclearSpin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:NuclearSpin", &(a->ns2__IsotopeParametersType::NuclearSpin), "ns2:AngularMomentumType"))
				{	soap_flag_NuclearSpin1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__IsotopeParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IsotopeParametersType, 0, sizeof(ns2__IsotopeParametersType), 0, soap_copy_ns2__IsotopeParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MassNumber1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__IsotopeParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__IsotopeParametersType);
	if (this->soap_out(soap, tag?tag:"ns2:IsotopeParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__IsotopeParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__IsotopeParametersType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__IsotopeParametersType * SOAP_FMAC4 soap_get_ns2__IsotopeParametersType(struct soap *soap, ns2__IsotopeParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IsotopeParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__IsotopeParametersType * SOAP_FMAC2 soap_instantiate_ns2__IsotopeParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__IsotopeParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__IsotopeParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__IsotopeParametersType);
		if (size)
			*size = sizeof(ns2__IsotopeParametersType);
		((ns2__IsotopeParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__IsotopeParametersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__IsotopeParametersType);
		for (int i = 0; i < n; i++)
			((ns2__IsotopeParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__IsotopeParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__IsotopeParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__IsotopeParametersType %p -> %p\n", q, p));
	*(ns2__IsotopeParametersType*)p = *(ns2__IsotopeParametersType*)q;
}

void ns2__IsotopeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__IsotopeType::IsotopeParameters = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__IonStateType(soap, &this->ns2__IsotopeType::IonState);
	this->ns2__IsotopeType::Comments = NULL;
	/* transient soap skipped */
}

void ns2__IsotopeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IsotopeParametersType(soap, &this->ns2__IsotopeType::IsotopeParameters);
	soap_serialize_std__vectorTemplateOfPointerTons2__IonStateType(soap, &this->ns2__IsotopeType::IonState);
	soap_serialize_PointerTostd__string(soap, &this->ns2__IsotopeType::Comments);
	/* transient soap skipped */
}

int ns2__IsotopeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__IsotopeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IsotopeType(struct soap *soap, const char *tag, int id, const ns2__IsotopeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IsotopeType), type))
		return soap->error;
	if (soap_out_PointerTons2__IsotopeParametersType(soap, "ns2:IsotopeParameters", -1, &(a->ns2__IsotopeType::IsotopeParameters), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__IonStateType(soap, "ns2:IonState", -1, &(a->ns2__IsotopeType::IonState), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__IsotopeType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__IsotopeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__IsotopeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__IsotopeType * SOAP_FMAC4 soap_in_ns2__IsotopeType(struct soap *soap, const char *tag, ns2__IsotopeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__IsotopeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IsotopeType, sizeof(ns2__IsotopeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__IsotopeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__IsotopeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IsotopeParameters1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IsotopeParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IsotopeParametersType(soap, "ns2:IsotopeParameters", &(a->ns2__IsotopeType::IsotopeParameters), "ns2:IsotopeParametersType"))
				{	soap_flag_IsotopeParameters1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__IonStateType(soap, "ns2:IonState", &(a->ns2__IsotopeType::IonState), "ns2:IonStateType"))
					continue;
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__IsotopeType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__IsotopeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IsotopeType, 0, sizeof(ns2__IsotopeType), 0, soap_copy_ns2__IsotopeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__IsotopeType::IonState.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__IsotopeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__IsotopeType);
	if (this->soap_out(soap, tag?tag:"ns2:IsotopeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__IsotopeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__IsotopeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__IsotopeType * SOAP_FMAC4 soap_get_ns2__IsotopeType(struct soap *soap, ns2__IsotopeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IsotopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__IsotopeType * SOAP_FMAC2 soap_instantiate_ns2__IsotopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__IsotopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__IsotopeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__IsotopeType);
		if (size)
			*size = sizeof(ns2__IsotopeType);
		((ns2__IsotopeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__IsotopeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__IsotopeType);
		for (int i = 0; i < n; i++)
			((ns2__IsotopeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__IsotopeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__IsotopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__IsotopeType %p -> %p\n", q, p));
	*(ns2__IsotopeType*)p = *(ns2__IsotopeType*)q;
}

void ns2__AtomType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AtomType::ChemicalElement = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__IsotopeType(soap, &this->ns2__AtomType::Isotope);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__AtomType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ChemicalElementType(soap, &this->ns2__AtomType::ChemicalElement);
	soap_serialize_std__vectorTemplateOfPointerTons2__IsotopeType(soap, &this->ns2__AtomType::Isotope);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__AtomType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomType(struct soap *soap, const char *tag, int id, const ns2__AtomType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomType), "ns2:AtomType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__AtomType::ChemicalElement)
	{	if (soap_out_PointerTons2__ChemicalElementType(soap, "ns2:ChemicalElement", -1, &a->ns2__AtomType::ChemicalElement, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ChemicalElement"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__IsotopeType(soap, "ns2:Isotope", -1, &(a->ns2__AtomType::Isotope), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomType * SOAP_FMAC4 soap_in_ns2__AtomType(struct soap *soap, const char *tag, ns2__AtomType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomType, sizeof(ns2__AtomType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_ChemicalElement1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_ChemicalElement1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ChemicalElementType(soap, "ns2:ChemicalElement", &(a->ns2__AtomType::ChemicalElement), "ns2:ChemicalElementType"))
				{	soap_flag_ChemicalElement1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__IsotopeType(soap, "ns2:Isotope", &(a->ns2__AtomType::Isotope), "ns2:IsotopeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomType, 0, sizeof(ns2__AtomType), 0, soap_copy_ns2__AtomType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChemicalElement1 > 0 || a->ns2__AtomType::Isotope.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AtomType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomType * SOAP_FMAC4 soap_get_ns2__AtomType(struct soap *soap, ns2__AtomType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomType * SOAP_FMAC2 soap_instantiate_ns2__AtomType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomType);
		if (size)
			*size = sizeof(ns2__AtomType);
		((ns2__AtomType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomType);
		for (int i = 0; i < n; i++)
			((ns2__AtomType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomType %p -> %p\n", q, p));
	*(ns2__AtomType*)p = *(ns2__AtomType*)q;
}

void ns2__AtomsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__AtomType(soap, &this->ns2__AtomsType::Atom);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__AtomsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__AtomType(soap, &this->ns2__AtomsType::Atom);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__AtomsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AtomsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AtomsType(struct soap *soap, const char *tag, int id, const ns2__AtomsType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AtomsType), "ns2:AtomsType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__AtomType(soap, "ns2:Atom", -1, &(a->ns2__AtomsType::Atom), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AtomsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AtomsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AtomsType * SOAP_FMAC4 soap_in_ns2__AtomsType(struct soap *soap, const char *tag, ns2__AtomsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AtomsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AtomsType, sizeof(ns2__AtomsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AtomsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AtomsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__AtomType(soap, "ns2:Atom", &(a->ns2__AtomsType::Atom), "ns2:AtomType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AtomsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AtomsType, 0, sizeof(ns2__AtomsType), 0, soap_copy_ns2__AtomsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AtomsType::Atom.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AtomsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AtomsType);
	if (this->soap_out(soap, tag?tag:"ns2:AtomsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AtomsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AtomsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AtomsType * SOAP_FMAC4 soap_get_ns2__AtomsType(struct soap *soap, ns2__AtomsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AtomsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AtomsType * SOAP_FMAC2 soap_instantiate_ns2__AtomsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AtomsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AtomsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomsType);
		if (size)
			*size = sizeof(ns2__AtomsType);
		((ns2__AtomsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AtomsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AtomsType);
		for (int i = 0; i < n; i++)
			((ns2__AtomsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AtomsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AtomsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AtomsType %p -> %p\n", q, p));
	*(ns2__AtomsType*)p = *(ns2__AtomsType*)q;
}

void ns2__FunctionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FunctionType::Name = NULL;
	this->ns2__FunctionType::Expression = NULL;
	this->ns2__FunctionType::Y = NULL;
	this->ns2__FunctionType::Arguments = NULL;
	this->ns2__FunctionType::Parameters = NULL;
	this->ns2__FunctionType::ReferenceFrame = NULL;
	this->ns2__FunctionType::Description = NULL;
	this->ns2__FunctionType::SourceCodeURL = NULL;
	soap_default__ns2__functionID(soap, &this->ns2__FunctionType::ns2__functionID);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__FunctionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__FunctionType::Name);
	soap_serialize_PointerTons2__ExpressionType(soap, &this->ns2__FunctionType::Expression);
	soap_serialize_PointerTons2__ArgumentType(soap, &this->ns2__FunctionType::Y);
	soap_serialize_PointerTons2__ArgumentsType(soap, &this->ns2__FunctionType::Arguments);
	soap_serialize_PointerTons2__ParametersType(soap, &this->ns2__FunctionType::Parameters);
	soap_serialize_PointerTons2__ReferenceFrameType(soap, &this->ns2__FunctionType::ReferenceFrame);
	soap_serialize_PointerTostd__string(soap, &this->ns2__FunctionType::Description);
	soap_serialize_PointerTostd__string(soap, &this->ns2__FunctionType::SourceCodeURL);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__FunctionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FunctionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FunctionType(struct soap *soap, const char *tag, int id, const ns2__FunctionType *a, const char *type)
{
	soap_set_attr(soap, "ns2:functionID", ((ns2__FunctionType*)a)->ns2__functionID.c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FunctionType), "ns2:FunctionType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:Name", -1, &(a->ns2__FunctionType::Name), ""))
		return soap->error;
	if (a->ns2__FunctionType::Expression)
	{	if (soap_out_PointerTons2__ExpressionType(soap, "ns2:Expression", -1, &a->ns2__FunctionType::Expression, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Expression"))
		return soap->error;
	if (a->ns2__FunctionType::Y)
	{	if (soap_out_PointerTons2__ArgumentType(soap, "ns2:Y", -1, &a->ns2__FunctionType::Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Y"))
		return soap->error;
	if (a->ns2__FunctionType::Arguments)
	{	if (soap_out_PointerTons2__ArgumentsType(soap, "ns2:Arguments", -1, &a->ns2__FunctionType::Arguments, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Arguments"))
		return soap->error;
	if (soap_out_PointerTons2__ParametersType(soap, "ns2:Parameters", -1, &(a->ns2__FunctionType::Parameters), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReferenceFrameType(soap, "ns2:ReferenceFrame", -1, &(a->ns2__FunctionType::ReferenceFrame), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__FunctionType::Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:SourceCodeURL", -1, &(a->ns2__FunctionType::SourceCodeURL), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FunctionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FunctionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FunctionType * SOAP_FMAC4 soap_in_ns2__FunctionType(struct soap *soap, const char *tag, ns2__FunctionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FunctionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FunctionType, sizeof(ns2__FunctionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FunctionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FunctionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:functionID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__FunctionType*)a)->ns2__functionID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Expression1 = 1;
	size_t soap_flag_Y1 = 1;
	size_t soap_flag_Arguments1 = 1;
	size_t soap_flag_Parameters1 = 1;
	size_t soap_flag_ReferenceFrame1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_SourceCodeURL1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Name", &(a->ns2__FunctionType::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Expression1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExpressionType(soap, "ns2:Expression", &(a->ns2__FunctionType::Expression), "ns2:ExpressionType"))
				{	soap_flag_Expression1--;
					continue;
				}
			if (soap_flag_Y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArgumentType(soap, "ns2:Y", &(a->ns2__FunctionType::Y), "ns2:ArgumentType"))
				{	soap_flag_Y1--;
					continue;
				}
			if (soap_flag_Arguments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArgumentsType(soap, "ns2:Arguments", &(a->ns2__FunctionType::Arguments), "ns2:ArgumentsType"))
				{	soap_flag_Arguments1--;
					continue;
				}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametersType(soap, "ns2:Parameters", &(a->ns2__FunctionType::Parameters), "ns2:ParametersType"))
				{	soap_flag_Parameters1--;
					continue;
				}
			if (soap_flag_ReferenceFrame1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferenceFrameType(soap, "ns2:ReferenceFrame", &(a->ns2__FunctionType::ReferenceFrame), "ns2:ReferenceFrameType"))
				{	soap_flag_ReferenceFrame1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__FunctionType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_SourceCodeURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:SourceCodeURL", &(a->ns2__FunctionType::SourceCodeURL), "xsd:string"))
				{	soap_flag_SourceCodeURL1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FunctionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FunctionType, 0, sizeof(ns2__FunctionType), 0, soap_copy_ns2__FunctionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Expression1 > 0 || soap_flag_Y1 > 0 || soap_flag_Arguments1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FunctionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FunctionType);
	if (this->soap_out(soap, tag?tag:"ns2:FunctionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FunctionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FunctionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FunctionType * SOAP_FMAC4 soap_get_ns2__FunctionType(struct soap *soap, ns2__FunctionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FunctionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FunctionType * SOAP_FMAC2 soap_instantiate_ns2__FunctionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FunctionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FunctionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FunctionType);
		if (size)
			*size = sizeof(ns2__FunctionType);
		((ns2__FunctionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__FunctionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__FunctionType);
		for (int i = 0; i < n; i++)
			((ns2__FunctionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__FunctionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FunctionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FunctionType %p -> %p\n", q, p));
	*(ns2__FunctionType*)p = *(ns2__FunctionType*)q;
}

void ns2__FunctionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__FunctionType(soap, &this->ns2__FunctionsType::Function);
	/* transient soap skipped */
}

void ns2__FunctionsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__FunctionType(soap, &this->ns2__FunctionsType::Function);
	/* transient soap skipped */
}

int ns2__FunctionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FunctionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FunctionsType(struct soap *soap, const char *tag, int id, const ns2__FunctionsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FunctionsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__FunctionType(soap, "ns2:Function", -1, &(a->ns2__FunctionsType::Function), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FunctionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FunctionsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FunctionsType * SOAP_FMAC4 soap_in_ns2__FunctionsType(struct soap *soap, const char *tag, ns2__FunctionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FunctionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FunctionsType, sizeof(ns2__FunctionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FunctionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FunctionsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__FunctionType(soap, "ns2:Function", &(a->ns2__FunctionsType::Function), "ns2:FunctionType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FunctionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FunctionsType, 0, sizeof(ns2__FunctionsType), 0, soap_copy_ns2__FunctionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__FunctionsType::Function.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FunctionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FunctionsType);
	if (this->soap_out(soap, tag?tag:"ns2:FunctionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FunctionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FunctionsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FunctionsType * SOAP_FMAC4 soap_get_ns2__FunctionsType(struct soap *soap, ns2__FunctionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FunctionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FunctionsType * SOAP_FMAC2 soap_instantiate_ns2__FunctionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FunctionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FunctionsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FunctionsType);
		if (size)
			*size = sizeof(ns2__FunctionsType);
		((ns2__FunctionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__FunctionsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__FunctionsType);
		for (int i = 0; i < n; i++)
			((ns2__FunctionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__FunctionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FunctionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FunctionsType %p -> %p\n", q, p));
	*(ns2__FunctionsType*)p = *(ns2__FunctionsType*)q;
}

void ns2__MethodType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__MethodCategoryType(soap, &this->ns2__MethodType::Category);
	soap_default_std__string(soap, &this->ns2__MethodType::Description);
	this->ns2__MethodType::Comments = NULL;
	soap_default__ns2__methodID(soap, &this->ns2__MethodType::ns2__methodID);
	this->ns2__MethodType::ns2__sourceRef = NULL;
	this->ns2__MethodType::ns2__functionRef = NULL;
	/* transient soap skipped */
}

void ns2__MethodType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MethodType::Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MethodType::Description);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MethodType::Comments);
	/* transient soap skipped */
}

int ns2__MethodType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MethodType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MethodType(struct soap *soap, const char *tag, int id, const ns2__MethodType *a, const char *type)
{
	soap_set_attr(soap, "ns2:methodID", ((ns2__MethodType*)a)->ns2__methodID.c_str(), 1);
	if (((ns2__MethodType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__MethodType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__MethodType*)a)->ns2__functionRef)
		soap_set_attr(soap, "ns2:functionRef", ((ns2__MethodType*)a)->ns2__functionRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MethodType), type))
		return soap->error;
	if (soap_out_ns2__MethodCategoryType(soap, "ns2:Category", -1, &(a->ns2__MethodType::Category), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Description", -1, &(a->ns2__MethodType::Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__MethodType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MethodType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MethodType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MethodType * SOAP_FMAC4 soap_in_ns2__MethodType(struct soap *soap, const char *tag, ns2__MethodType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MethodType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MethodType, sizeof(ns2__MethodType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MethodType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MethodType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__MethodType*)a)->ns2__methodID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__MethodType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__MethodType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:functionRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__MethodType*)a)->ns2__functionRef = soap_new_std__string(soap, -1);
				((ns2__MethodType*)a)->ns2__functionRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Category1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__MethodCategoryType(soap, "ns2:Category", &(a->ns2__MethodType::Category), "ns2:MethodCategoryType"))
				{	soap_flag_Category1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Description", &(a->ns2__MethodType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__MethodType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MethodType, 0, sizeof(ns2__MethodType), 0, soap_copy_ns2__MethodType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Category1 > 0 || soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MethodType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MethodType);
	if (this->soap_out(soap, tag?tag:"ns2:MethodType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MethodType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MethodType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MethodType * SOAP_FMAC4 soap_get_ns2__MethodType(struct soap *soap, ns2__MethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MethodType * SOAP_FMAC2 soap_instantiate_ns2__MethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MethodType);
		if (size)
			*size = sizeof(ns2__MethodType);
		((ns2__MethodType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MethodType);
		for (int i = 0; i < n; i++)
			((ns2__MethodType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MethodType %p -> %p\n", q, p));
	*(ns2__MethodType*)p = *(ns2__MethodType*)q;
}

void ns2__MethodsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__MethodType(soap, &this->ns2__MethodsType::Method);
	/* transient soap skipped */
}

void ns2__MethodsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__MethodType(soap, &this->ns2__MethodsType::Method);
	/* transient soap skipped */
}

int ns2__MethodsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MethodsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MethodsType(struct soap *soap, const char *tag, int id, const ns2__MethodsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MethodsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__MethodType(soap, "ns2:Method", -1, &(a->ns2__MethodsType::Method), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MethodsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MethodsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MethodsType * SOAP_FMAC4 soap_in_ns2__MethodsType(struct soap *soap, const char *tag, ns2__MethodsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MethodsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MethodsType, sizeof(ns2__MethodsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MethodsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MethodsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MethodType(soap, "ns2:Method", &(a->ns2__MethodsType::Method), "ns2:MethodType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MethodsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MethodsType, 0, sizeof(ns2__MethodsType), 0, soap_copy_ns2__MethodsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__MethodsType::Method.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MethodsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MethodsType);
	if (this->soap_out(soap, tag?tag:"ns2:MethodsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MethodsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MethodsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MethodsType * SOAP_FMAC4 soap_get_ns2__MethodsType(struct soap *soap, ns2__MethodsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MethodsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MethodsType * SOAP_FMAC2 soap_instantiate_ns2__MethodsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MethodsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MethodsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MethodsType);
		if (size)
			*size = sizeof(ns2__MethodsType);
		((ns2__MethodsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MethodsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MethodsType);
		for (int i = 0; i < n; i++)
			((ns2__MethodsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MethodsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MethodsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MethodsType %p -> %p\n", q, p));
	*(ns2__MethodsType*)p = *(ns2__MethodsType*)q;
}

void ns2__EditorsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__EditorsType::Name);
	/* transient soap skipped */
}

void ns2__EditorsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__EditorsType::Name);
	/* transient soap skipped */
}

int ns2__EditorsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EditorsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EditorsType(struct soap *soap, const char *tag, int id, const ns2__EditorsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EditorsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:Name", -1, &(a->ns2__EditorsType::Name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__EditorsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EditorsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EditorsType * SOAP_FMAC4 soap_in_ns2__EditorsType(struct soap *soap, const char *tag, ns2__EditorsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EditorsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EditorsType, sizeof(ns2__EditorsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EditorsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EditorsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:Name", &(a->ns2__EditorsType::Name), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EditorsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EditorsType, 0, sizeof(ns2__EditorsType), 0, soap_copy_ns2__EditorsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__EditorsType::Name.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__EditorsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EditorsType);
	if (this->soap_out(soap, tag?tag:"ns2:EditorsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EditorsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EditorsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EditorsType * SOAP_FMAC4 soap_get_ns2__EditorsType(struct soap *soap, ns2__EditorsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EditorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EditorsType * SOAP_FMAC2 soap_instantiate_ns2__EditorsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EditorsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EditorsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EditorsType);
		if (size)
			*size = sizeof(ns2__EditorsType);
		((ns2__EditorsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__EditorsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__EditorsType);
		for (int i = 0; i < n; i++)
			((ns2__EditorsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__EditorsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EditorsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EditorsType %p -> %p\n", q, p));
	*(ns2__EditorsType*)p = *(ns2__EditorsType*)q;
}

void ns2__AuthorsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__AuthorType(soap, &this->ns2__AuthorsType::Author);
	/* transient soap skipped */
}

void ns2__AuthorsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__AuthorType(soap, &this->ns2__AuthorsType::Author);
	/* transient soap skipped */
}

int ns2__AuthorsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AuthorsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AuthorsType(struct soap *soap, const char *tag, int id, const ns2__AuthorsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AuthorsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__AuthorType(soap, "ns2:Author", -1, &(a->ns2__AuthorsType::Author), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AuthorsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AuthorsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AuthorsType * SOAP_FMAC4 soap_in_ns2__AuthorsType(struct soap *soap, const char *tag, ns2__AuthorsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AuthorsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AuthorsType, sizeof(ns2__AuthorsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AuthorsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AuthorsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__AuthorType(soap, "ns2:Author", &(a->ns2__AuthorsType::Author), "ns2:AuthorType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AuthorsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AuthorsType, 0, sizeof(ns2__AuthorsType), 0, soap_copy_ns2__AuthorsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AuthorsType::Author.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AuthorsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AuthorsType);
	if (this->soap_out(soap, tag?tag:"ns2:AuthorsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AuthorsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AuthorsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AuthorsType * SOAP_FMAC4 soap_get_ns2__AuthorsType(struct soap *soap, ns2__AuthorsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AuthorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AuthorsType * SOAP_FMAC2 soap_instantiate_ns2__AuthorsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AuthorsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AuthorsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AuthorsType);
		if (size)
			*size = sizeof(ns2__AuthorsType);
		((ns2__AuthorsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AuthorsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AuthorsType);
		for (int i = 0; i < n; i++)
			((ns2__AuthorsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AuthorsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AuthorsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AuthorsType %p -> %p\n", q, p));
	*(ns2__AuthorsType*)p = *(ns2__AuthorsType*)q;
}

void ns2__SourceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__CategoryType(soap, &this->ns2__SourceType::Category);
	soap_default_std__string(soap, &this->ns2__SourceType::SourceName);
	soap_default_xsd__gYear(soap, &this->ns2__SourceType::Year);
	this->ns2__SourceType::Authors = NULL;
	this->ns2__SourceType::Title = NULL;
	this->ns2__SourceType::Volume = NULL;
	this->ns2__SourceType::DigitalObjectIdentifier = NULL;
	this->ns2__SourceType::PageBegin = NULL;
	this->ns2__SourceType::PageEnd = NULL;
	this->ns2__SourceType::UniformResourceIdentifier = NULL;
	this->ns2__SourceType::Publisher = NULL;
	this->ns2__SourceType::City = NULL;
	this->ns2__SourceType::Editors = NULL;
	this->ns2__SourceType::ProductionDate = NULL;
	this->ns2__SourceType::Version = NULL;
	this->ns2__SourceType::Comments = NULL;
	soap_default__ns2__sourceID(soap, &this->ns2__SourceType::ns2__sourceID);
	/* transient soap skipped */
}

void ns2__SourceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__SourceType::SourceName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__SourceType::SourceName);
	soap_serialize_xsd__gYear(soap, &this->ns2__SourceType::Year);
	soap_serialize_PointerTons2__AuthorsType(soap, &this->ns2__SourceType::Authors);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::Title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::Volume);
	soap_serialize_PointerToxsd__token(soap, &this->ns2__SourceType::DigitalObjectIdentifier);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::PageBegin);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::PageEnd);
	soap_serialize_PointerToxsd__anyURI(soap, &this->ns2__SourceType::UniformResourceIdentifier);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::Publisher);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::City);
	soap_serialize_PointerTons2__EditorsType(soap, &this->ns2__SourceType::Editors);
	soap_serialize_PointerToxsd__date(soap, &this->ns2__SourceType::ProductionDate);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::Version);
	soap_serialize_PointerTostd__string(soap, &this->ns2__SourceType::Comments);
	/* transient soap skipped */
}

int ns2__SourceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SourceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SourceType(struct soap *soap, const char *tag, int id, const ns2__SourceType *a, const char *type)
{
	soap_set_attr(soap, "ns2:sourceID", ((ns2__SourceType*)a)->ns2__sourceID.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SourceType), type))
		return soap->error;
	if (soap_out_ns2__CategoryType(soap, "ns2:Category", -1, &(a->ns2__SourceType::Category), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:SourceName", -1, &(a->ns2__SourceType::SourceName), ""))
		return soap->error;
	if (soap_out_xsd__gYear(soap, "ns2:Year", -1, &(a->ns2__SourceType::Year), ""))
		return soap->error;
	if (a->ns2__SourceType::Authors)
	{	if (soap_out_PointerTons2__AuthorsType(soap, "ns2:Authors", -1, &a->ns2__SourceType::Authors, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Authors"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Title", -1, &(a->ns2__SourceType::Title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Volume", -1, &(a->ns2__SourceType::Volume), ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "ns2:DigitalObjectIdentifier", -1, &(a->ns2__SourceType::DigitalObjectIdentifier), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:PageBegin", -1, &(a->ns2__SourceType::PageBegin), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:PageEnd", -1, &(a->ns2__SourceType::PageEnd), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "ns2:UniformResourceIdentifier", -1, &(a->ns2__SourceType::UniformResourceIdentifier), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Publisher", -1, &(a->ns2__SourceType::Publisher), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:City", -1, &(a->ns2__SourceType::City), ""))
		return soap->error;
	if (soap_out_PointerTons2__EditorsType(soap, "ns2:Editors", -1, &(a->ns2__SourceType::Editors), ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns2:ProductionDate", -1, &(a->ns2__SourceType::ProductionDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Version", -1, &(a->ns2__SourceType::Version), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__SourceType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SourceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SourceType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SourceType * SOAP_FMAC4 soap_in_ns2__SourceType(struct soap *soap, const char *tag, ns2__SourceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SourceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SourceType, sizeof(ns2__SourceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SourceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SourceType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceID", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__SourceType*)a)->ns2__sourceID.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Category1 = 1;
	size_t soap_flag_SourceName1 = 1;
	size_t soap_flag_Year1 = 1;
	size_t soap_flag_Authors1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_Volume1 = 1;
	size_t soap_flag_DigitalObjectIdentifier1 = 1;
	size_t soap_flag_PageBegin1 = 1;
	size_t soap_flag_PageEnd1 = 1;
	size_t soap_flag_UniformResourceIdentifier1 = 1;
	size_t soap_flag_Publisher1 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_Editors1 = 1;
	size_t soap_flag_ProductionDate1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__CategoryType(soap, "ns2:Category", &(a->ns2__SourceType::Category), "ns2:CategoryType"))
				{	soap_flag_Category1--;
					continue;
				}
			if (soap_flag_SourceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:SourceName", &(a->ns2__SourceType::SourceName), "xsd:string"))
				{	soap_flag_SourceName1--;
					continue;
				}
			if (soap_flag_Year1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__gYear(soap, "ns2:Year", &(a->ns2__SourceType::Year), "xsd:gYear"))
				{	soap_flag_Year1--;
					continue;
				}
			if (soap_flag_Authors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AuthorsType(soap, "ns2:Authors", &(a->ns2__SourceType::Authors), "ns2:AuthorsType"))
				{	soap_flag_Authors1--;
					continue;
				}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Title", &(a->ns2__SourceType::Title), "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			if (soap_flag_Volume1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Volume", &(a->ns2__SourceType::Volume), "xsd:string"))
				{	soap_flag_Volume1--;
					continue;
				}
			if (soap_flag_DigitalObjectIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "ns2:DigitalObjectIdentifier", &(a->ns2__SourceType::DigitalObjectIdentifier), "xsd:token"))
				{	soap_flag_DigitalObjectIdentifier1--;
					continue;
				}
			if (soap_flag_PageBegin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:PageBegin", &(a->ns2__SourceType::PageBegin), "xsd:string"))
				{	soap_flag_PageBegin1--;
					continue;
				}
			if (soap_flag_PageEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:PageEnd", &(a->ns2__SourceType::PageEnd), "xsd:string"))
				{	soap_flag_PageEnd1--;
					continue;
				}
			if (soap_flag_UniformResourceIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "ns2:UniformResourceIdentifier", &(a->ns2__SourceType::UniformResourceIdentifier), "xsd:anyURI"))
				{	soap_flag_UniformResourceIdentifier1--;
					continue;
				}
			if (soap_flag_Publisher1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Publisher", &(a->ns2__SourceType::Publisher), "xsd:string"))
				{	soap_flag_Publisher1--;
					continue;
				}
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:City", &(a->ns2__SourceType::City), "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_Editors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EditorsType(soap, "ns2:Editors", &(a->ns2__SourceType::Editors), "ns2:EditorsType"))
				{	soap_flag_Editors1--;
					continue;
				}
			if (soap_flag_ProductionDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ns2:ProductionDate", &(a->ns2__SourceType::ProductionDate), "xsd:date"))
				{	soap_flag_ProductionDate1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Version", &(a->ns2__SourceType::Version), "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__SourceType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SourceType, 0, sizeof(ns2__SourceType), 0, soap_copy_ns2__SourceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Category1 > 0 || soap_flag_SourceName1 > 0 || soap_flag_Year1 > 0 || soap_flag_Authors1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SourceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SourceType);
	if (this->soap_out(soap, tag?tag:"ns2:SourceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SourceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SourceType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SourceType * SOAP_FMAC4 soap_get_ns2__SourceType(struct soap *soap, ns2__SourceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SourceType * SOAP_FMAC2 soap_instantiate_ns2__SourceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SourceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SourceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SourceType);
		if (size)
			*size = sizeof(ns2__SourceType);
		((ns2__SourceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SourceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SourceType);
		for (int i = 0; i < n; i++)
			((ns2__SourceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SourceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SourceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SourceType %p -> %p\n", q, p));
	*(ns2__SourceType*)p = *(ns2__SourceType*)q;
}

void ns2__SourcesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__SourceType(soap, &this->ns2__SourcesType::Source);
	/* transient soap skipped */
}

void ns2__SourcesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__SourceType(soap, &this->ns2__SourcesType::Source);
	/* transient soap skipped */
}

int ns2__SourcesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SourcesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SourcesType(struct soap *soap, const char *tag, int id, const ns2__SourcesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SourcesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__SourceType(soap, "ns2:Source", -1, &(a->ns2__SourcesType::Source), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SourcesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SourcesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SourcesType * SOAP_FMAC4 soap_in_ns2__SourcesType(struct soap *soap, const char *tag, ns2__SourcesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SourcesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SourcesType, sizeof(ns2__SourcesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SourcesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SourcesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__SourceType(soap, "ns2:Source", &(a->ns2__SourcesType::Source), "ns2:SourceType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SourcesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SourcesType, 0, sizeof(ns2__SourcesType), 0, soap_copy_ns2__SourcesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SourcesType::Source.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SourcesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SourcesType);
	if (this->soap_out(soap, tag?tag:"ns2:SourcesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SourcesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SourcesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SourcesType * SOAP_FMAC4 soap_get_ns2__SourcesType(struct soap *soap, ns2__SourcesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SourcesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SourcesType * SOAP_FMAC2 soap_instantiate_ns2__SourcesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SourcesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SourcesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SourcesType);
		if (size)
			*size = sizeof(ns2__SourcesType);
		((ns2__SourcesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SourcesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SourcesType);
		for (int i = 0; i < n; i++)
			((ns2__SourcesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SourcesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SourcesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SourcesType %p -> %p\n", q, p));
	*(ns2__SourcesType*)p = *(ns2__SourcesType*)q;
}

void ns2__AuthorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__AuthorType::Name);
	this->ns2__AuthorType::Address = NULL;
	/* transient soap skipped */
}

void ns2__AuthorType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__AuthorType::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AuthorType::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AuthorType::Address);
	/* transient soap skipped */
}

int ns2__AuthorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AuthorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AuthorType(struct soap *soap, const char *tag, int id, const ns2__AuthorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AuthorType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Name", -1, &(a->ns2__AuthorType::Name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Address", -1, &(a->ns2__AuthorType::Address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AuthorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AuthorType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AuthorType * SOAP_FMAC4 soap_in_ns2__AuthorType(struct soap *soap, const char *tag, ns2__AuthorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AuthorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AuthorType, sizeof(ns2__AuthorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AuthorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AuthorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Address1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Name", &(a->ns2__AuthorType::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Address", &(a->ns2__AuthorType::Address), "xsd:string"))
				{	soap_flag_Address1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AuthorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AuthorType, 0, sizeof(ns2__AuthorType), 0, soap_copy_ns2__AuthorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AuthorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AuthorType);
	if (this->soap_out(soap, tag?tag:"ns2:AuthorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AuthorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AuthorType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AuthorType * SOAP_FMAC4 soap_get_ns2__AuthorType(struct soap *soap, ns2__AuthorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AuthorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AuthorType * SOAP_FMAC2 soap_instantiate_ns2__AuthorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AuthorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AuthorType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AuthorType);
		if (size)
			*size = sizeof(ns2__AuthorType);
		((ns2__AuthorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AuthorType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AuthorType);
		for (int i = 0; i < n; i++)
			((ns2__AuthorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AuthorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AuthorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AuthorType %p -> %p\n", q, p));
	*(ns2__AuthorType*)p = *(ns2__AuthorType*)q;
}

void ns2__ProductsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__ns2__ProductsType_sequence(soap, &this->ns2__ProductsType::__ProductsType_sequence);
	/* transient soap skipped */
}

void ns2__ProductsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__ns2__ProductsType_sequence(soap, &this->ns2__ProductsType::__ProductsType_sequence);
	/* transient soap skipped */
}

int ns2__ProductsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ProductsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ProductsType(struct soap *soap, const char *tag, int id, const ns2__ProductsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ProductsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__ns2__ProductsType_sequence(soap, "-ProductsType-sequence", -1, &(a->ns2__ProductsType::__ProductsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ProductsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ProductsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ProductsType * SOAP_FMAC4 soap_in_ns2__ProductsType(struct soap *soap, const char *tag, ns2__ProductsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ProductsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ProductsType, sizeof(ns2__ProductsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ProductsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ProductsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__ProductsType_sequence(soap, "-ProductsType-sequence", &(a->ns2__ProductsType::__ProductsType_sequence), "-ns2:ProductsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ProductsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ProductsType, 0, sizeof(ns2__ProductsType), 0, soap_copy_ns2__ProductsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ProductsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ProductsType);
	if (this->soap_out(soap, tag?tag:"ns2:ProductsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ProductsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ProductsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ProductsType * SOAP_FMAC4 soap_get_ns2__ProductsType(struct soap *soap, ns2__ProductsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ProductsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ProductsType * SOAP_FMAC2 soap_instantiate_ns2__ProductsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ProductsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ProductsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ProductsType);
		if (size)
			*size = sizeof(ns2__ProductsType);
		((ns2__ProductsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ProductsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ProductsType);
		for (int i = 0; i < n; i++)
			((ns2__ProductsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ProductsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ProductsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ProductsType %p -> %p\n", q, p));
	*(ns2__ProductsType*)p = *(ns2__ProductsType*)q;
}

void ns2__ReactantsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__ns2__ReactantsType_sequence(soap, &this->ns2__ReactantsType::__ReactantsType_sequence);
	/* transient soap skipped */
}

void ns2__ReactantsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__ns2__ReactantsType_sequence(soap, &this->ns2__ReactantsType::__ReactantsType_sequence);
	/* transient soap skipped */
}

int ns2__ReactantsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReactantsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReactantsType(struct soap *soap, const char *tag, int id, const ns2__ReactantsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReactantsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__ns2__ReactantsType_sequence(soap, "-ReactantsType-sequence", -1, &(a->ns2__ReactantsType::__ReactantsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ReactantsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReactantsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReactantsType * SOAP_FMAC4 soap_in_ns2__ReactantsType(struct soap *soap, const char *tag, ns2__ReactantsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReactantsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReactantsType, sizeof(ns2__ReactantsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReactantsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ReactantsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__ns2__ReactantsType_sequence(soap, "-ReactantsType-sequence", &(a->ns2__ReactantsType::__ReactantsType_sequence), "-ns2:ReactantsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReactantsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReactantsType, 0, sizeof(ns2__ReactantsType), 0, soap_copy_ns2__ReactantsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ReactantsType::__ReactantsType_sequence.size() < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ReactantsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReactantsType);
	if (this->soap_out(soap, tag?tag:"ns2:ReactantsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReactantsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReactantsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReactantsType * SOAP_FMAC4 soap_get_ns2__ReactantsType(struct soap *soap, ns2__ReactantsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReactantsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ReactantsType * SOAP_FMAC2 soap_instantiate_ns2__ReactantsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReactantsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReactantsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReactantsType);
		if (size)
			*size = sizeof(ns2__ReactantsType);
		((ns2__ReactantsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReactantsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ReactantsType);
		for (int i = 0; i < n; i++)
			((ns2__ReactantsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ReactantsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReactantsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReactantsType %p -> %p\n", q, p));
	*(ns2__ReactantsType*)p = *(ns2__ReactantsType*)q;
}

void ns2__TermType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TermType::LS = NULL;
	this->ns2__TermType::jj = NULL;
	this->ns2__TermType::J1J2 = NULL;
	this->ns2__TermType::jK = NULL;
	this->ns2__TermType::LK = NULL;
	this->ns2__TermType::TermLabel = NULL;
	/* transient soap skipped */
}

void ns2__TermType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__LSCouplingType(soap, &this->ns2__TermType::LS);
	soap_serialize_PointerTons2__jjCouplingType(soap, &this->ns2__TermType::jj);
	soap_serialize_PointerTons2__jjCouplingType(soap, &this->ns2__TermType::J1J2);
	soap_serialize_PointerTons2__jKCouplingType(soap, &this->ns2__TermType::jK);
	soap_serialize_PointerTons2__LKCouplingType(soap, &this->ns2__TermType::LK);
	soap_serialize_PointerTostd__string(soap, &this->ns2__TermType::TermLabel);
	/* transient soap skipped */
}

int ns2__TermType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TermType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TermType(struct soap *soap, const char *tag, int id, const ns2__TermType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TermType), type))
		return soap->error;
	if (soap_out_PointerTons2__LSCouplingType(soap, "ns2:LS", -1, &(a->ns2__TermType::LS), ""))
		return soap->error;
	if (soap_out_PointerTons2__jjCouplingType(soap, "ns2:jj", -1, &(a->ns2__TermType::jj), ""))
		return soap->error;
	if (soap_out_PointerTons2__jjCouplingType(soap, "ns2:J1J2", -1, &(a->ns2__TermType::J1J2), ""))
		return soap->error;
	if (soap_out_PointerTons2__jKCouplingType(soap, "ns2:jK", -1, &(a->ns2__TermType::jK), ""))
		return soap->error;
	if (soap_out_PointerTons2__LKCouplingType(soap, "ns2:LK", -1, &(a->ns2__TermType::LK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:TermLabel", -1, &(a->ns2__TermType::TermLabel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__TermType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TermType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TermType * SOAP_FMAC4 soap_in_ns2__TermType(struct soap *soap, const char *tag, ns2__TermType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TermType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TermType, sizeof(ns2__TermType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__TermType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__TermType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LS1 = 1;
	size_t soap_flag_jj1 = 1;
	size_t soap_flag_J1J21 = 1;
	size_t soap_flag_jK1 = 1;
	size_t soap_flag_LK1 = 1;
	size_t soap_flag_TermLabel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LSCouplingType(soap, "ns2:LS", &(a->ns2__TermType::LS), "ns2:LSCouplingType"))
				{	soap_flag_LS1--;
					continue;
				}
			if (soap_flag_jj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__jjCouplingType(soap, "ns2:jj", &(a->ns2__TermType::jj), "ns2:jjCouplingType"))
				{	soap_flag_jj1--;
					continue;
				}
			if (soap_flag_J1J21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__jjCouplingType(soap, "ns2:J1J2", &(a->ns2__TermType::J1J2), "ns2:jjCouplingType"))
				{	soap_flag_J1J21--;
					continue;
				}
			if (soap_flag_jK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__jKCouplingType(soap, "ns2:jK", &(a->ns2__TermType::jK), "ns2:jKCouplingType"))
				{	soap_flag_jK1--;
					continue;
				}
			if (soap_flag_LK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LKCouplingType(soap, "ns2:LK", &(a->ns2__TermType::LK), "ns2:LKCouplingType"))
				{	soap_flag_LK1--;
					continue;
				}
			if (soap_flag_TermLabel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:TermLabel", &(a->ns2__TermType::TermLabel), "xsd:string"))
				{	soap_flag_TermLabel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TermType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TermType, 0, sizeof(ns2__TermType), 0, soap_copy_ns2__TermType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__TermType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__TermType);
	if (this->soap_out(soap, tag?tag:"ns2:TermType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TermType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TermType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TermType * SOAP_FMAC4 soap_get_ns2__TermType(struct soap *soap, ns2__TermType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TermType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__TermType * SOAP_FMAC2 soap_instantiate_ns2__TermType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TermType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__TermType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__TermType);
		if (size)
			*size = sizeof(ns2__TermType);
		((ns2__TermType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__TermType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__TermType);
		for (int i = 0; i < n; i++)
			((ns2__TermType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__TermType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__TermType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__TermType %p -> %p\n", q, p));
	*(ns2__TermType*)p = *(ns2__TermType*)q;
}

void ns2__OrbitalAngularMomentumType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->ns2__OrbitalAngularMomentumType::Value);
	this->ns2__OrbitalAngularMomentumType::Symbol = NULL;
	/* transient soap skipped */
}

void ns2__OrbitalAngularMomentumType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->ns2__OrbitalAngularMomentumType::Value);
	soap_serialize_PointerTons2__OrbitalAngularMomentumSymbolType(soap, &this->ns2__OrbitalAngularMomentumType::Symbol);
	/* transient soap skipped */
}

int ns2__OrbitalAngularMomentumType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OrbitalAngularMomentumType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OrbitalAngularMomentumType(struct soap *soap, const char *tag, int id, const ns2__OrbitalAngularMomentumType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OrbitalAngularMomentumType), type))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "ns2:Value", -1, &(a->ns2__OrbitalAngularMomentumType::Value), ""))
		return soap->error;
	if (soap_out_PointerTons2__OrbitalAngularMomentumSymbolType(soap, "ns2:Symbol", -1, &(a->ns2__OrbitalAngularMomentumType::Symbol), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OrbitalAngularMomentumType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OrbitalAngularMomentumType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OrbitalAngularMomentumType * SOAP_FMAC4 soap_in_ns2__OrbitalAngularMomentumType(struct soap *soap, const char *tag, ns2__OrbitalAngularMomentumType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OrbitalAngularMomentumType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OrbitalAngularMomentumType, sizeof(ns2__OrbitalAngularMomentumType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OrbitalAngularMomentumType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OrbitalAngularMomentumType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "ns2:Value", &(a->ns2__OrbitalAngularMomentumType::Value), "xsd:nonNegativeInteger"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__OrbitalAngularMomentumSymbolType(soap, "ns2:Symbol", &(a->ns2__OrbitalAngularMomentumType::Symbol), "ns2:OrbitalAngularMomentumSymbolType"))
				{	soap_flag_Symbol1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OrbitalAngularMomentumType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OrbitalAngularMomentumType, 0, sizeof(ns2__OrbitalAngularMomentumType), 0, soap_copy_ns2__OrbitalAngularMomentumType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__OrbitalAngularMomentumType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OrbitalAngularMomentumType);
	if (this->soap_out(soap, tag?tag:"ns2:OrbitalAngularMomentumType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OrbitalAngularMomentumType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OrbitalAngularMomentumType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OrbitalAngularMomentumType * SOAP_FMAC4 soap_get_ns2__OrbitalAngularMomentumType(struct soap *soap, ns2__OrbitalAngularMomentumType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OrbitalAngularMomentumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OrbitalAngularMomentumType * SOAP_FMAC2 soap_instantiate_ns2__OrbitalAngularMomentumType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OrbitalAngularMomentumType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OrbitalAngularMomentumType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OrbitalAngularMomentumType);
		if (size)
			*size = sizeof(ns2__OrbitalAngularMomentumType);
		((ns2__OrbitalAngularMomentumType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__OrbitalAngularMomentumType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__OrbitalAngularMomentumType);
		for (int i = 0; i < n; i++)
			((ns2__OrbitalAngularMomentumType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__OrbitalAngularMomentumType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OrbitalAngularMomentumType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OrbitalAngularMomentumType %p -> %p\n", q, p));
	*(ns2__OrbitalAngularMomentumType*)p = *(ns2__OrbitalAngularMomentumType*)q;
}

void ns2__MixingCoefficientType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns2__MixingCoefficientType::__item);
	soap_default_ns2__MixingClassType(soap, &this->ns2__MixingCoefficientType::mixingClass);
	/* transient soap skipped */
}

void ns2__MixingCoefficientType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MixingCoefficientType::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int ns2__MixingCoefficientType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MixingCoefficientType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MixingCoefficientType(struct soap *soap, const char *tag, int id, const ns2__MixingCoefficientType *a, const char *type)
{
	soap_set_attr(soap, "mixingClass", soap_ns2__MixingClassType2s(soap, ((ns2__MixingCoefficientType*)a)->mixingClass), 1);
	return soap_out_double(soap, tag, id, &a->ns2__MixingCoefficientType::__item, "");
}

void *ns2__MixingCoefficientType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MixingCoefficientType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MixingCoefficientType * SOAP_FMAC4 soap_in_ns2__MixingCoefficientType(struct soap *soap, const char *tag, ns2__MixingCoefficientType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__MixingCoefficientType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MixingCoefficientType, sizeof(ns2__MixingCoefficientType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MixingCoefficientType)
			return (ns2__MixingCoefficientType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2ns2__MixingClassType(soap, soap_attr_value(soap, "mixingClass", 1), &((ns2__MixingCoefficientType*)a)->mixingClass))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->ns2__MixingCoefficientType::__item), "ns2:MixingCoefficientType"))
		return NULL;
	return a;
}

int ns2__MixingCoefficientType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MixingCoefficientType);
	if (this->soap_out(soap, tag?tag:"ns2:MixingCoefficientType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MixingCoefficientType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MixingCoefficientType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MixingCoefficientType * SOAP_FMAC4 soap_get_ns2__MixingCoefficientType(struct soap *soap, ns2__MixingCoefficientType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MixingCoefficientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MixingCoefficientType * SOAP_FMAC2 soap_instantiate_ns2__MixingCoefficientType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MixingCoefficientType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MixingCoefficientType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MixingCoefficientType);
		if (size)
			*size = sizeof(ns2__MixingCoefficientType);
		((ns2__MixingCoefficientType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MixingCoefficientType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MixingCoefficientType);
		for (int i = 0; i < n; i++)
			((ns2__MixingCoefficientType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MixingCoefficientType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MixingCoefficientType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MixingCoefficientType %p -> %p\n", q, p));
	*(ns2__MixingCoefficientType*)p = *(ns2__MixingCoefficientType*)q;
}

void ns2__LSCouplingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LSCouplingType::L = NULL;
	soap_default_ns2__AngularMomentumType(soap, &this->ns2__LSCouplingType::S);
	this->ns2__LSCouplingType::Multiplicity = NULL;
	this->ns2__LSCouplingType::Seniority = NULL;
	/* transient soap skipped */
}

void ns2__LSCouplingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OrbitalAngularMomentumType(soap, &this->ns2__LSCouplingType::L);
	soap_embedded(soap, &this->ns2__LSCouplingType::S, SOAP_TYPE_ns2__AngularMomentumType);
	soap_serialize_ns2__AngularMomentumType(soap, &this->ns2__LSCouplingType::S);
	soap_serialize_PointerToxsd__positiveInteger(soap, &this->ns2__LSCouplingType::Multiplicity);
	soap_serialize_PointerTo_ns2__LSCouplingType_Seniority(soap, &this->ns2__LSCouplingType::Seniority);
	/* transient soap skipped */
}

int ns2__LSCouplingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LSCouplingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LSCouplingType(struct soap *soap, const char *tag, int id, const ns2__LSCouplingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LSCouplingType), type))
		return soap->error;
	if (a->ns2__LSCouplingType::L)
	{	if (soap_out_PointerTons2__OrbitalAngularMomentumType(soap, "ns2:L", -1, &a->ns2__LSCouplingType::L, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:L"))
		return soap->error;
	if (soap_out_ns2__AngularMomentumType(soap, "ns2:S", -1, &(a->ns2__LSCouplingType::S), ""))
		return soap->error;
	if (soap_out_PointerToxsd__positiveInteger(soap, "ns2:Multiplicity", -1, &(a->ns2__LSCouplingType::Multiplicity), ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__LSCouplingType_Seniority(soap, "ns2:Seniority", -1, &(a->ns2__LSCouplingType::Seniority), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LSCouplingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LSCouplingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LSCouplingType * SOAP_FMAC4 soap_in_ns2__LSCouplingType(struct soap *soap, const char *tag, ns2__LSCouplingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LSCouplingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LSCouplingType, sizeof(ns2__LSCouplingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LSCouplingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LSCouplingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_L1 = 1;
	size_t soap_flag_S1 = 1;
	size_t soap_flag_Multiplicity1 = 1;
	size_t soap_flag_Seniority1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_L1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OrbitalAngularMomentumType(soap, "ns2:L", &(a->ns2__LSCouplingType::L), "ns2:OrbitalAngularMomentumType"))
				{	soap_flag_L1--;
					continue;
				}
			if (soap_flag_S1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__AngularMomentumType(soap, "ns2:S", &(a->ns2__LSCouplingType::S), "ns2:AngularMomentumType"))
				{	soap_flag_S1--;
					continue;
				}
			if (soap_flag_Multiplicity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__positiveInteger(soap, "ns2:Multiplicity", &(a->ns2__LSCouplingType::Multiplicity), "xsd:positiveInteger"))
				{	soap_flag_Multiplicity1--;
					continue;
				}
			if (soap_flag_Seniority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__LSCouplingType_Seniority(soap, "ns2:Seniority", &(a->ns2__LSCouplingType::Seniority), ""))
				{	soap_flag_Seniority1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LSCouplingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LSCouplingType, 0, sizeof(ns2__LSCouplingType), 0, soap_copy_ns2__LSCouplingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_L1 > 0 || soap_flag_S1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LSCouplingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LSCouplingType);
	if (this->soap_out(soap, tag?tag:"ns2:LSCouplingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LSCouplingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LSCouplingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LSCouplingType * SOAP_FMAC4 soap_get_ns2__LSCouplingType(struct soap *soap, ns2__LSCouplingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LSCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LSCouplingType * SOAP_FMAC2 soap_instantiate_ns2__LSCouplingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LSCouplingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LSCouplingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LSCouplingType);
		if (size)
			*size = sizeof(ns2__LSCouplingType);
		((ns2__LSCouplingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LSCouplingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LSCouplingType);
		for (int i = 0; i < n; i++)
			((ns2__LSCouplingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LSCouplingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LSCouplingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LSCouplingType %p -> %p\n", q, p));
	*(ns2__LSCouplingType*)p = *(ns2__LSCouplingType*)q;
}

void ns2__LKCouplingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LKCouplingType::L = NULL;
	soap_default_ns2__AngularMomentumType(soap, &this->ns2__LKCouplingType::K);
	this->ns2__LKCouplingType::S2 = NULL;
	/* transient soap skipped */
}

void ns2__LKCouplingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OrbitalAngularMomentumType(soap, &this->ns2__LKCouplingType::L);
	soap_embedded(soap, &this->ns2__LKCouplingType::K, SOAP_TYPE_ns2__AngularMomentumType);
	soap_serialize_ns2__AngularMomentumType(soap, &this->ns2__LKCouplingType::K);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__LKCouplingType::S2);
	/* transient soap skipped */
}

int ns2__LKCouplingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LKCouplingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LKCouplingType(struct soap *soap, const char *tag, int id, const ns2__LKCouplingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LKCouplingType), type))
		return soap->error;
	if (a->ns2__LKCouplingType::L)
	{	if (soap_out_PointerTons2__OrbitalAngularMomentumType(soap, "ns2:L", -1, &a->ns2__LKCouplingType::L, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:L"))
		return soap->error;
	if (soap_out_ns2__AngularMomentumType(soap, "ns2:K", -1, &(a->ns2__LKCouplingType::K), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:S2", -1, &(a->ns2__LKCouplingType::S2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LKCouplingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LKCouplingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LKCouplingType * SOAP_FMAC4 soap_in_ns2__LKCouplingType(struct soap *soap, const char *tag, ns2__LKCouplingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LKCouplingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LKCouplingType, sizeof(ns2__LKCouplingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LKCouplingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LKCouplingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_L1 = 1;
	size_t soap_flag_K1 = 1;
	size_t soap_flag_S21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_L1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OrbitalAngularMomentumType(soap, "ns2:L", &(a->ns2__LKCouplingType::L), "ns2:OrbitalAngularMomentumType"))
				{	soap_flag_L1--;
					continue;
				}
			if (soap_flag_K1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__AngularMomentumType(soap, "ns2:K", &(a->ns2__LKCouplingType::K), "ns2:AngularMomentumType"))
				{	soap_flag_K1--;
					continue;
				}
			if (soap_flag_S21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:S2", &(a->ns2__LKCouplingType::S2), "ns2:AngularMomentumType"))
				{	soap_flag_S21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LKCouplingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LKCouplingType, 0, sizeof(ns2__LKCouplingType), 0, soap_copy_ns2__LKCouplingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_L1 > 0 || soap_flag_K1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LKCouplingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LKCouplingType);
	if (this->soap_out(soap, tag?tag:"ns2:LKCouplingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LKCouplingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LKCouplingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LKCouplingType * SOAP_FMAC4 soap_get_ns2__LKCouplingType(struct soap *soap, ns2__LKCouplingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LKCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LKCouplingType * SOAP_FMAC2 soap_instantiate_ns2__LKCouplingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LKCouplingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LKCouplingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LKCouplingType);
		if (size)
			*size = sizeof(ns2__LKCouplingType);
		((ns2__LKCouplingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LKCouplingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LKCouplingType);
		for (int i = 0; i < n; i++)
			((ns2__LKCouplingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LKCouplingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LKCouplingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LKCouplingType %p -> %p\n", q, p));
	*(ns2__LKCouplingType*)p = *(ns2__LKCouplingType*)q;
}

void ns2__jKCouplingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__jKCouplingType::j = NULL;
	this->ns2__jKCouplingType::S2 = NULL;
	soap_default_ns2__AngularMomentumType(soap, &this->ns2__jKCouplingType::K);
	/* transient soap skipped */
}

void ns2__jKCouplingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__jKCouplingType::j);
	soap_serialize_PointerTons2__AngularMomentumType(soap, &this->ns2__jKCouplingType::S2);
	soap_embedded(soap, &this->ns2__jKCouplingType::K, SOAP_TYPE_ns2__AngularMomentumType);
	soap_serialize_ns2__AngularMomentumType(soap, &this->ns2__jKCouplingType::K);
	/* transient soap skipped */
}

int ns2__jKCouplingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__jKCouplingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__jKCouplingType(struct soap *soap, const char *tag, int id, const ns2__jKCouplingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__jKCouplingType), type))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:j", -1, &(a->ns2__jKCouplingType::j), ""))
		return soap->error;
	if (soap_out_PointerTons2__AngularMomentumType(soap, "ns2:S2", -1, &(a->ns2__jKCouplingType::S2), ""))
		return soap->error;
	if (soap_out_ns2__AngularMomentumType(soap, "ns2:K", -1, &(a->ns2__jKCouplingType::K), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__jKCouplingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__jKCouplingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__jKCouplingType * SOAP_FMAC4 soap_in_ns2__jKCouplingType(struct soap *soap, const char *tag, ns2__jKCouplingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__jKCouplingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__jKCouplingType, sizeof(ns2__jKCouplingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__jKCouplingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__jKCouplingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_j1 = 1;
	size_t soap_flag_S21 = 1;
	size_t soap_flag_K1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_j1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:j", &(a->ns2__jKCouplingType::j), "ns2:AngularMomentumType"))
				{	soap_flag_j1--;
					continue;
				}
			if (soap_flag_S21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__AngularMomentumType(soap, "ns2:S2", &(a->ns2__jKCouplingType::S2), "ns2:AngularMomentumType"))
				{	soap_flag_S21--;
					continue;
				}
			if (soap_flag_K1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__AngularMomentumType(soap, "ns2:K", &(a->ns2__jKCouplingType::K), "ns2:AngularMomentumType"))
				{	soap_flag_K1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__jKCouplingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__jKCouplingType, 0, sizeof(ns2__jKCouplingType), 0, soap_copy_ns2__jKCouplingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_K1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__jKCouplingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__jKCouplingType);
	if (this->soap_out(soap, tag?tag:"ns2:jKCouplingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__jKCouplingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__jKCouplingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__jKCouplingType * SOAP_FMAC4 soap_get_ns2__jKCouplingType(struct soap *soap, ns2__jKCouplingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__jKCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__jKCouplingType * SOAP_FMAC2 soap_instantiate_ns2__jKCouplingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__jKCouplingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__jKCouplingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__jKCouplingType);
		if (size)
			*size = sizeof(ns2__jKCouplingType);
		((ns2__jKCouplingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__jKCouplingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__jKCouplingType);
		for (int i = 0; i < n; i++)
			((ns2__jKCouplingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__jKCouplingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__jKCouplingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__jKCouplingType %p -> %p\n", q, p));
	*(ns2__jKCouplingType*)p = *(ns2__jKCouplingType*)q;
}

void ns2__jjCouplingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns2__AngularMomentumType(soap, &this->ns2__jjCouplingType::j);
	/* transient soap skipped */
}

void ns2__jjCouplingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns2__AngularMomentumType(soap, &this->ns2__jjCouplingType::j);
	/* transient soap skipped */
}

int ns2__jjCouplingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__jjCouplingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__jjCouplingType(struct soap *soap, const char *tag, int id, const ns2__jjCouplingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__jjCouplingType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__AngularMomentumType(soap, "ns2:j", -1, &(a->ns2__jjCouplingType::j), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__jjCouplingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__jjCouplingType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__jjCouplingType * SOAP_FMAC4 soap_in_ns2__jjCouplingType(struct soap *soap, const char *tag, ns2__jjCouplingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__jjCouplingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__jjCouplingType, sizeof(ns2__jjCouplingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__jjCouplingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__jjCouplingType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__AngularMomentumType(soap, "ns2:j", &(a->ns2__jjCouplingType::j), "ns2:AngularMomentumType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__jjCouplingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__jjCouplingType, 0, sizeof(ns2__jjCouplingType), 0, soap_copy_ns2__jjCouplingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__jjCouplingType::j.size() < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__jjCouplingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__jjCouplingType);
	if (this->soap_out(soap, tag?tag:"ns2:jjCouplingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__jjCouplingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__jjCouplingType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__jjCouplingType * SOAP_FMAC4 soap_get_ns2__jjCouplingType(struct soap *soap, ns2__jjCouplingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__jjCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__jjCouplingType * SOAP_FMAC2 soap_instantiate_ns2__jjCouplingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__jjCouplingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__jjCouplingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__jjCouplingType);
		if (size)
			*size = sizeof(ns2__jjCouplingType);
		((ns2__jjCouplingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__jjCouplingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__jjCouplingType);
		for (int i = 0; i < n; i++)
			((ns2__jjCouplingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__jjCouplingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__jjCouplingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__jjCouplingType %p -> %p\n", q, p));
	*(ns2__jjCouplingType*)p = *(ns2__jjCouplingType*)q;
}

void ns2__ValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns2__ValueType::__item);
	soap_default__ns2__units(soap, &this->ns2__ValueType::ns2__units);
	/* transient soap skipped */
}

void ns2__ValueType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ValueType::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int ns2__ValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueType(struct soap *soap, const char *tag, int id, const ns2__ValueType *a, const char *type)
{
	soap_set_attr(soap, "ns2:units", soap__ns2__units2s(soap, ((ns2__ValueType*)a)->ns2__units), 1);
	return soap_out_double(soap, tag, id, &a->ns2__ValueType::__item, "");
}

void *ns2__ValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueType * SOAP_FMAC4 soap_in_ns2__ValueType(struct soap *soap, const char *tag, ns2__ValueType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__ValueType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueType, sizeof(ns2__ValueType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueType)
			return (ns2__ValueType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2_ns2__units(soap, soap_attr_value(soap, "ns2:units", 1), &((ns2__ValueType*)a)->ns2__units))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->ns2__ValueType::__item), "ns2:ValueType"))
		return NULL;
	return a;
}

int ns2__ValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueType);
	if (this->soap_out(soap, tag?tag:"ns2:ValueType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueType * SOAP_FMAC4 soap_get_ns2__ValueType(struct soap *soap, ns2__ValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueType * SOAP_FMAC2 soap_instantiate_ns2__ValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueType);
		if (size)
			*size = sizeof(ns2__ValueType);
		((ns2__ValueType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ValueType);
		for (int i = 0; i < n; i++)
			((ns2__ValueType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueType %p -> %p\n", q, p));
	*(ns2__ValueType*)p = *(ns2__ValueType*)q;
}

void ns2__ParameterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->ns2__ParameterType::Name);
	this->ns2__ParameterType::Description = NULL;
	/* transient soap skipped */
}

void ns2__ParameterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ParameterType::Name, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->ns2__ParameterType::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ParameterType::Description);
	/* transient soap skipped */
}

int ns2__ParameterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParameterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParameterType(struct soap *soap, const char *tag, int id, const ns2__ParameterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParameterType), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "ns2:Name", -1, &(a->ns2__ParameterType::Name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__ParameterType::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParameterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParameterType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParameterType * SOAP_FMAC4 soap_in_ns2__ParameterType(struct soap *soap, const char *tag, ns2__ParameterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParameterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParameterType, sizeof(ns2__ParameterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParameterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParameterType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:Name", &(a->ns2__ParameterType::Name), "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__ParameterType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParameterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParameterType, 0, sizeof(ns2__ParameterType), 0, soap_copy_ns2__ParameterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParameterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParameterType);
	if (this->soap_out(soap, tag?tag:"ns2:ParameterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParameterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParameterType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParameterType * SOAP_FMAC4 soap_get_ns2__ParameterType(struct soap *soap, ns2__ParameterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParameterType * SOAP_FMAC2 soap_instantiate_ns2__ParameterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParameterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParameterType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParameterType);
		if (size)
			*size = sizeof(ns2__ParameterType);
		((ns2__ParameterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParameterType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ParameterType);
		for (int i = 0; i < n; i++)
			((ns2__ParameterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ParameterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParameterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParameterType %p -> %p\n", q, p));
	*(ns2__ParameterType*)p = *(ns2__ParameterType*)q;
}

void ns2__ParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ParameterType(soap, &this->ns2__ParametersType::Parameter);
	/* transient soap skipped */
}

void ns2__ParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ParameterType(soap, &this->ns2__ParametersType::Parameter);
	/* transient soap skipped */
}

int ns2__ParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParametersType(struct soap *soap, const char *tag, int id, const ns2__ParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ParameterType(soap, "ns2:Parameter", -1, &(a->ns2__ParametersType::Parameter), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParametersType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParametersType * SOAP_FMAC4 soap_in_ns2__ParametersType(struct soap *soap, const char *tag, ns2__ParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParametersType, sizeof(ns2__ParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParametersType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ParameterType(soap, "ns2:Parameter", &(a->ns2__ParametersType::Parameter), "ns2:ParameterType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParametersType, 0, sizeof(ns2__ParametersType), 0, soap_copy_ns2__ParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ParametersType::Parameter.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParametersType);
	if (this->soap_out(soap, tag?tag:"ns2:ParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParametersType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParametersType * SOAP_FMAC4 soap_get_ns2__ParametersType(struct soap *soap, ns2__ParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParametersType * SOAP_FMAC2 soap_instantiate_ns2__ParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametersType);
		if (size)
			*size = sizeof(ns2__ParametersType);
		((ns2__ParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ParametersType);
		for (int i = 0; i < n; i++)
			((ns2__ParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParametersType %p -> %p\n", q, p));
	*(ns2__ParametersType*)p = *(ns2__ParametersType*)q;
}

void ns2__ArgumentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ArgumentType::Name = NULL;
	this->ns2__ArgumentType::Description = NULL;
	soap_default__ns2__units(soap, &this->ns2__ArgumentType::ns2__units);
	soap_default_std__string(soap, &this->ns2__ArgumentType::parameter);
	/* transient soap skipped */
}

void ns2__ArgumentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__ArgumentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArgumentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArgumentType(struct soap *soap, const char *tag, int id, const ns2__ArgumentType *a, const char *type)
{
	soap_set_attr(soap, "ns2:units", soap__ns2__units2s(soap, ((ns2__ArgumentType*)a)->ns2__units), 1);
	if (!((ns2__ArgumentType*)a)->parameter.empty())
	soap_set_attr(soap, "parameter", ((ns2__ArgumentType*)a)->parameter.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArgumentType), type))
		return soap->error;
	soap_outliteral(soap, "ns2:Name", &(a->ns2__ArgumentType::Name), NULL);
	soap_outliteral(soap, "ns2:Description", &(a->ns2__ArgumentType::Description), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ArgumentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArgumentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArgumentType * SOAP_FMAC4 soap_in_ns2__ArgumentType(struct soap *soap, const char *tag, ns2__ArgumentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArgumentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArgumentType, sizeof(ns2__ArgumentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArgumentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArgumentType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_ns2__units(soap, soap_attr_value(soap, "ns2:units", 1), &((ns2__ArgumentType*)a)->ns2__units))
		return NULL;
	{	const char *t = soap_attr_value(soap, "parameter", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__ArgumentType*)a)->parameter.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:Name", &(a->ns2__ArgumentType::Name)))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:Description", &(a->ns2__ArgumentType::Description)))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArgumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArgumentType, 0, sizeof(ns2__ArgumentType), 0, soap_copy_ns2__ArgumentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ArgumentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArgumentType);
	if (this->soap_out(soap, tag?tag:"ns2:ArgumentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ArgumentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArgumentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArgumentType * SOAP_FMAC4 soap_get_ns2__ArgumentType(struct soap *soap, ns2__ArgumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArgumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ArgumentType * SOAP_FMAC2 soap_instantiate_ns2__ArgumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArgumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArgumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ArgumentType);
		if (size)
			*size = sizeof(ns2__ArgumentType);
		((ns2__ArgumentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ArgumentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ArgumentType);
		for (int i = 0; i < n; i++)
			((ns2__ArgumentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ArgumentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArgumentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArgumentType %p -> %p\n", q, p));
	*(ns2__ArgumentType*)p = *(ns2__ArgumentType*)q;
}

void ns2__ArgumentsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ArgumentType(soap, &this->ns2__ArgumentsType::Argument);
	/* transient soap skipped */
}

void ns2__ArgumentsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ArgumentType(soap, &this->ns2__ArgumentsType::Argument);
	/* transient soap skipped */
}

int ns2__ArgumentsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArgumentsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArgumentsType(struct soap *soap, const char *tag, int id, const ns2__ArgumentsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArgumentsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ArgumentType(soap, "ns2:Argument", -1, &(a->ns2__ArgumentsType::Argument), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ArgumentsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArgumentsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArgumentsType * SOAP_FMAC4 soap_in_ns2__ArgumentsType(struct soap *soap, const char *tag, ns2__ArgumentsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArgumentsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArgumentsType, sizeof(ns2__ArgumentsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArgumentsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArgumentsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ArgumentType(soap, "ns2:Argument", &(a->ns2__ArgumentsType::Argument), "ns2:ArgumentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArgumentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArgumentsType, 0, sizeof(ns2__ArgumentsType), 0, soap_copy_ns2__ArgumentsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ArgumentsType::Argument.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ArgumentsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArgumentsType);
	if (this->soap_out(soap, tag?tag:"ns2:ArgumentsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ArgumentsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArgumentsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArgumentsType * SOAP_FMAC4 soap_get_ns2__ArgumentsType(struct soap *soap, ns2__ArgumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArgumentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ArgumentsType * SOAP_FMAC2 soap_instantiate_ns2__ArgumentsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArgumentsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArgumentsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ArgumentsType);
		if (size)
			*size = sizeof(ns2__ArgumentsType);
		((ns2__ArgumentsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ArgumentsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ArgumentsType);
		for (int i = 0; i < n; i++)
			((ns2__ArgumentsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ArgumentsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArgumentsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArgumentsType %p -> %p\n", q, p));
	*(ns2__ArgumentsType*)p = *(ns2__ArgumentsType*)q;
}

void ns2__ExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__ExpressionType::__item);
	soap_default_std__string(soap, &this->ns2__ExpressionType::computerLanguage);
	/* transient soap skipped */
}

void ns2__ExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ExpressionType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ExpressionType::__item);
	/* transient soap skipped */
}

int ns2__ExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExpressionType(struct soap *soap, const char *tag, int id, const ns2__ExpressionType *a, const char *type)
{
	soap_set_attr(soap, "computerLanguage", ((ns2__ExpressionType*)a)->computerLanguage.c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->ns2__ExpressionType::__item, "");
}

void *ns2__ExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ExpressionType * SOAP_FMAC4 soap_in_ns2__ExpressionType(struct soap *soap, const char *tag, ns2__ExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__ExpressionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExpressionType, sizeof(ns2__ExpressionType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ExpressionType)
			return (ns2__ExpressionType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "computerLanguage", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__ExpressionType*)a)->computerLanguage.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->ns2__ExpressionType::__item), "ns2:ExpressionType"))
		return NULL;
	return a;
}

int ns2__ExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ExpressionType);
	if (this->soap_out(soap, tag?tag:"ns2:ExpressionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ExpressionType * SOAP_FMAC4 soap_get_ns2__ExpressionType(struct soap *soap, ns2__ExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ExpressionType * SOAP_FMAC2 soap_instantiate_ns2__ExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ExpressionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ExpressionType);
		if (size)
			*size = sizeof(ns2__ExpressionType);
		((ns2__ExpressionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ExpressionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ExpressionType);
		for (int i = 0; i < n; i++)
			((ns2__ExpressionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ExpressionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ExpressionType %p -> %p\n", q, p));
	*(ns2__ExpressionType*)p = *(ns2__ExpressionType*)q;
}

void ns2__FitValidityLimitsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FitValidityLimitsType::LowerLimit = NULL;
	this->ns2__FitValidityLimitsType::UpperLimit = NULL;
	/* transient soap skipped */
}

void ns2__FitValidityLimitsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns2__FitValidityLimitsType::LowerLimit);
	soap_serialize_PointerTodouble(soap, &this->ns2__FitValidityLimitsType::UpperLimit);
	/* transient soap skipped */
}

int ns2__FitValidityLimitsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FitValidityLimitsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FitValidityLimitsType(struct soap *soap, const char *tag, int id, const ns2__FitValidityLimitsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FitValidityLimitsType), type))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns2:LowerLimit", -1, &(a->ns2__FitValidityLimitsType::LowerLimit), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns2:UpperLimit", -1, &(a->ns2__FitValidityLimitsType::UpperLimit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FitValidityLimitsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FitValidityLimitsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FitValidityLimitsType * SOAP_FMAC4 soap_in_ns2__FitValidityLimitsType(struct soap *soap, const char *tag, ns2__FitValidityLimitsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FitValidityLimitsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FitValidityLimitsType, sizeof(ns2__FitValidityLimitsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FitValidityLimitsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FitValidityLimitsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LowerLimit1 = 1;
	size_t soap_flag_UpperLimit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LowerLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns2:LowerLimit", &(a->ns2__FitValidityLimitsType::LowerLimit), "xsd:double"))
				{	soap_flag_LowerLimit1--;
					continue;
				}
			if (soap_flag_UpperLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns2:UpperLimit", &(a->ns2__FitValidityLimitsType::UpperLimit), "xsd:double"))
				{	soap_flag_UpperLimit1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FitValidityLimitsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FitValidityLimitsType, 0, sizeof(ns2__FitValidityLimitsType), 0, soap_copy_ns2__FitValidityLimitsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__FitValidityLimitsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FitValidityLimitsType);
	if (this->soap_out(soap, tag?tag:"ns2:FitValidityLimitsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FitValidityLimitsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FitValidityLimitsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FitValidityLimitsType * SOAP_FMAC4 soap_get_ns2__FitValidityLimitsType(struct soap *soap, ns2__FitValidityLimitsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FitValidityLimitsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FitValidityLimitsType * SOAP_FMAC2 soap_instantiate_ns2__FitValidityLimitsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FitValidityLimitsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FitValidityLimitsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FitValidityLimitsType);
		if (size)
			*size = sizeof(ns2__FitValidityLimitsType);
		((ns2__FitValidityLimitsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__FitValidityLimitsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__FitValidityLimitsType);
		for (int i = 0; i < n; i++)
			((ns2__FitValidityLimitsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__FitValidityLimitsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FitValidityLimitsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FitValidityLimitsType %p -> %p\n", q, p));
	*(ns2__FitValidityLimitsType*)p = *(ns2__FitValidityLimitsType*)q;
}

void ns2__FitParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns2__FitParametersType::Parameter);
	/* transient soap skipped */
}

void ns2__FitParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns2__FitParametersType::Parameter);
	/* transient soap skipped */
}

int ns2__FitParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FitParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FitParametersType(struct soap *soap, const char *tag, int id, const ns2__FitParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FitParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "ns2:Parameter", -1, &(a->ns2__FitParametersType::Parameter), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FitParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FitParametersType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FitParametersType * SOAP_FMAC4 soap_in_ns2__FitParametersType(struct soap *soap, const char *tag, ns2__FitParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FitParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FitParametersType, sizeof(ns2__FitParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FitParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FitParametersType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "ns2:Parameter", &(a->ns2__FitParametersType::Parameter), "xsd:double"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FitParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FitParametersType, 0, sizeof(ns2__FitParametersType), 0, soap_copy_ns2__FitParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__FitParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FitParametersType);
	if (this->soap_out(soap, tag?tag:"ns2:FitParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FitParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FitParametersType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FitParametersType * SOAP_FMAC4 soap_get_ns2__FitParametersType(struct soap *soap, ns2__FitParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FitParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FitParametersType * SOAP_FMAC2 soap_instantiate_ns2__FitParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FitParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FitParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FitParametersType);
		if (size)
			*size = sizeof(ns2__FitParametersType);
		((ns2__FitParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__FitParametersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__FitParametersType);
		for (int i = 0; i < n; i++)
			((ns2__FitParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__FitParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FitParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FitParametersType %p -> %p\n", q, p));
	*(ns2__FitParametersType*)p = *(ns2__FitParametersType*)q;
}

void ns2__FitDataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__IDREF(soap, &this->ns2__FitDataType::FunctionRef);
	soap_default_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(soap, &this->ns2__FitDataType::FitValidityLimits);
	this->ns2__FitDataType::FitParameters = NULL;
	this->ns2__FitDataType::FitAccuracy = NULL;
	this->ns2__FitDataType::PhysicalUncertainty = NULL;
	this->ns2__FitDataType::ProductionDate = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__FitDataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__FitDataType::FunctionRef, SOAP_TYPE_xsd__IDREF);
	soap_serialize_xsd__IDREF(soap, &this->ns2__FitDataType::FunctionRef);
	soap_serialize_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(soap, &this->ns2__FitDataType::FitValidityLimits);
	soap_serialize_PointerTons2__FitParametersType(soap, &this->ns2__FitDataType::FitParameters);
	soap_serialize_PointerTostd__string(soap, &this->ns2__FitDataType::FitAccuracy);
	soap_serialize_PointerTostd__string(soap, &this->ns2__FitDataType::PhysicalUncertainty);
	soap_serialize_PointerToxsd__date(soap, &this->ns2__FitDataType::ProductionDate);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__FitDataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FitDataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FitDataType(struct soap *soap, const char *tag, int id, const ns2__FitDataType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FitDataType), "ns2:FitDataType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__IDREF(soap, "ns2:FunctionRef", -1, &(a->ns2__FitDataType::FunctionRef), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(soap, "ns2:FitValidityLimits", -1, &(a->ns2__FitDataType::FitValidityLimits), ""))
		return soap->error;
	if (a->ns2__FitDataType::FitParameters)
	{	if (soap_out_PointerTons2__FitParametersType(soap, "ns2:FitParameters", -1, &a->ns2__FitDataType::FitParameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:FitParameters"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:FitAccuracy", -1, &(a->ns2__FitDataType::FitAccuracy), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:PhysicalUncertainty", -1, &(a->ns2__FitDataType::PhysicalUncertainty), ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns2:ProductionDate", -1, &(a->ns2__FitDataType::ProductionDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FitDataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FitDataType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FitDataType * SOAP_FMAC4 soap_in_ns2__FitDataType(struct soap *soap, const char *tag, ns2__FitDataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FitDataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FitDataType, sizeof(ns2__FitDataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FitDataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FitDataType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_FunctionRef1 = 1;
	size_t soap_flag_FitParameters1 = 1;
	size_t soap_flag_FitAccuracy1 = 1;
	size_t soap_flag_PhysicalUncertainty1 = 1;
	size_t soap_flag_ProductionDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_FunctionRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__IDREF(soap, "ns2:FunctionRef", &(a->ns2__FitDataType::FunctionRef), "xsd:IDREF"))
				{	soap_flag_FunctionRef1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(soap, "ns2:FitValidityLimits", &(a->ns2__FitDataType::FitValidityLimits), "ns2:FitValidityLimitsType"))
					continue;
			if (soap_flag_FitParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FitParametersType(soap, "ns2:FitParameters", &(a->ns2__FitDataType::FitParameters), "ns2:FitParametersType"))
				{	soap_flag_FitParameters1--;
					continue;
				}
			if (soap_flag_FitAccuracy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:FitAccuracy", &(a->ns2__FitDataType::FitAccuracy), "xsd:string"))
				{	soap_flag_FitAccuracy1--;
					continue;
				}
			if (soap_flag_PhysicalUncertainty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:PhysicalUncertainty", &(a->ns2__FitDataType::PhysicalUncertainty), "xsd:string"))
				{	soap_flag_PhysicalUncertainty1--;
					continue;
				}
			if (soap_flag_ProductionDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ns2:ProductionDate", &(a->ns2__FitDataType::ProductionDate), "xsd:date"))
				{	soap_flag_ProductionDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FitDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FitDataType, 0, sizeof(ns2__FitDataType), 0, soap_copy_ns2__FitDataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FunctionRef1 > 0 || a->ns2__FitDataType::FitValidityLimits.size() < 1 || soap_flag_FitParameters1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FitDataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FitDataType);
	if (this->soap_out(soap, tag?tag:"ns2:FitDataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FitDataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FitDataType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FitDataType * SOAP_FMAC4 soap_get_ns2__FitDataType(struct soap *soap, ns2__FitDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FitDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FitDataType * SOAP_FMAC2 soap_instantiate_ns2__FitDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FitDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FitDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FitDataType);
		if (size)
			*size = sizeof(ns2__FitDataType);
		((ns2__FitDataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__FitDataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__FitDataType);
		for (int i = 0; i < n; i++)
			((ns2__FitDataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__FitDataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FitDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FitDataType %p -> %p\n", q, p));
	*(ns2__FitDataType*)p = *(ns2__FitDataType*)q;
}

void ns2__TabulatedDataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TabulatedDataType::DataXY = NULL;
	this->ns2__TabulatedDataType::ReferenceFrame = NULL;
	this->ns2__TabulatedDataType::PhysicalUncertainty = NULL;
	this->ns2__TabulatedDataType::ProductionDate = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__TabulatedDataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DataXYType(soap, &this->ns2__TabulatedDataType::DataXY);
	soap_serialize_PointerTons2__ReferenceFrameType(soap, &this->ns2__TabulatedDataType::ReferenceFrame);
	soap_serialize_PointerTostd__string(soap, &this->ns2__TabulatedDataType::PhysicalUncertainty);
	soap_serialize_PointerToxsd__date(soap, &this->ns2__TabulatedDataType::ProductionDate);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__TabulatedDataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TabulatedDataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TabulatedDataType(struct soap *soap, const char *tag, int id, const ns2__TabulatedDataType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TabulatedDataType), "ns2:TabulatedDataType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__TabulatedDataType::DataXY)
	{	if (soap_out_PointerTons2__DataXYType(soap, "ns2:DataXY", -1, &a->ns2__TabulatedDataType::DataXY, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:DataXY"))
		return soap->error;
	if (soap_out_PointerTons2__ReferenceFrameType(soap, "ns2:ReferenceFrame", -1, &(a->ns2__TabulatedDataType::ReferenceFrame), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:PhysicalUncertainty", -1, &(a->ns2__TabulatedDataType::PhysicalUncertainty), ""))
		return soap->error;
	if (soap_out_PointerToxsd__date(soap, "ns2:ProductionDate", -1, &(a->ns2__TabulatedDataType::ProductionDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TabulatedDataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TabulatedDataType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TabulatedDataType * SOAP_FMAC4 soap_in_ns2__TabulatedDataType(struct soap *soap, const char *tag, ns2__TabulatedDataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TabulatedDataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TabulatedDataType, sizeof(ns2__TabulatedDataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__TabulatedDataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__TabulatedDataType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_DataXY1 = 1;
	size_t soap_flag_ReferenceFrame1 = 1;
	size_t soap_flag_PhysicalUncertainty1 = 1;
	size_t soap_flag_ProductionDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_DataXY1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataXYType(soap, "ns2:DataXY", &(a->ns2__TabulatedDataType::DataXY), "ns2:DataXYType"))
				{	soap_flag_DataXY1--;
					continue;
				}
			if (soap_flag_ReferenceFrame1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferenceFrameType(soap, "ns2:ReferenceFrame", &(a->ns2__TabulatedDataType::ReferenceFrame), "ns2:ReferenceFrameType"))
				{	soap_flag_ReferenceFrame1--;
					continue;
				}
			if (soap_flag_PhysicalUncertainty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:PhysicalUncertainty", &(a->ns2__TabulatedDataType::PhysicalUncertainty), "xsd:string"))
				{	soap_flag_PhysicalUncertainty1--;
					continue;
				}
			if (soap_flag_ProductionDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ns2:ProductionDate", &(a->ns2__TabulatedDataType::ProductionDate), "xsd:date"))
				{	soap_flag_ProductionDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TabulatedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TabulatedDataType, 0, sizeof(ns2__TabulatedDataType), 0, soap_copy_ns2__TabulatedDataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataXY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__TabulatedDataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__TabulatedDataType);
	if (this->soap_out(soap, tag?tag:"ns2:TabulatedDataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TabulatedDataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TabulatedDataType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TabulatedDataType * SOAP_FMAC4 soap_get_ns2__TabulatedDataType(struct soap *soap, ns2__TabulatedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TabulatedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__TabulatedDataType * SOAP_FMAC2 soap_instantiate_ns2__TabulatedDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TabulatedDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__TabulatedDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__TabulatedDataType);
		if (size)
			*size = sizeof(ns2__TabulatedDataType);
		((ns2__TabulatedDataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__TabulatedDataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__TabulatedDataType);
		for (int i = 0; i < n; i++)
			((ns2__TabulatedDataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__TabulatedDataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__TabulatedDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__TabulatedDataType %p -> %p\n", q, p));
	*(ns2__TabulatedDataType*)p = *(ns2__TabulatedDataType*)q;
}

void ns2__DataXYType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__DataTableType(soap, &this->ns2__DataXYType::X);
	this->ns2__DataXYType::Y = NULL;
	/* transient soap skipped */
}

void ns2__DataXYType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__DataTableType(soap, &this->ns2__DataXYType::X);
	soap_serialize_PointerTons2__DataTableType(soap, &this->ns2__DataXYType::Y);
	/* transient soap skipped */
}

int ns2__DataXYType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataXYType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataXYType(struct soap *soap, const char *tag, int id, const ns2__DataXYType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataXYType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__DataTableType(soap, "ns2:X", -1, &(a->ns2__DataXYType::X), ""))
		return soap->error;
	if (a->ns2__DataXYType::Y)
	{	if (soap_out_PointerTons2__DataTableType(soap, "ns2:Y", -1, &a->ns2__DataXYType::Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Y"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DataXYType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataXYType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataXYType * SOAP_FMAC4 soap_in_ns2__DataXYType(struct soap *soap, const char *tag, ns2__DataXYType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataXYType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataXYType, sizeof(ns2__DataXYType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataXYType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataXYType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Y1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__DataTableType(soap, "ns2:X", &(a->ns2__DataXYType::X), "ns2:DataTableType"))
					continue;
			if (soap_flag_Y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DataTableType(soap, "ns2:Y", &(a->ns2__DataXYType::Y), "ns2:DataTableType"))
				{	soap_flag_Y1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataXYType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataXYType, 0, sizeof(ns2__DataXYType), 0, soap_copy_ns2__DataXYType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__DataXYType::X.size() < 1 || soap_flag_Y1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DataXYType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataXYType);
	if (this->soap_out(soap, tag?tag:"ns2:DataXYType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataXYType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataXYType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataXYType * SOAP_FMAC4 soap_get_ns2__DataXYType(struct soap *soap, ns2__DataXYType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataXYType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataXYType * SOAP_FMAC2 soap_instantiate_ns2__DataXYType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataXYType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataXYType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataXYType);
		if (size)
			*size = sizeof(ns2__DataXYType);
		((ns2__DataXYType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataXYType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DataXYType);
		for (int i = 0; i < n; i++)
			((ns2__DataXYType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DataXYType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataXYType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataXYType %p -> %p\n", q, p));
	*(ns2__DataXYType*)p = *(ns2__DataXYType*)q;
}

void ns2__DataTableType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__DataListType(soap, &this->ns2__DataTableType::DataList);
	this->ns2__DataTableType::Error = NULL;
	this->ns2__DataTableType::NegativeError = NULL;
	this->ns2__DataTableType::PositiveError = NULL;
	this->ns2__DataTableType::DataDescription = NULL;
	soap_default__ns2__units(soap, &this->ns2__DataTableType::ns2__units);
	this->ns2__DataTableType::parameter = NULL;
	/* transient soap skipped */
}

void ns2__DataTableType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__DataTableType::DataList, SOAP_TYPE_ns2__DataListType);
	soap_serialize_ns2__DataListType(soap, &this->ns2__DataTableType::DataList);
	soap_serialize_PointerTons2__DataListType(soap, &this->ns2__DataTableType::Error);
	soap_serialize_PointerTons2__DataListType(soap, &this->ns2__DataTableType::NegativeError);
	soap_serialize_PointerTons2__DataListType(soap, &this->ns2__DataTableType::PositiveError);
	/* transient soap skipped */
}

int ns2__DataTableType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataTableType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataTableType(struct soap *soap, const char *tag, int id, const ns2__DataTableType *a, const char *type)
{
	soap_set_attr(soap, "ns2:units", soap__ns2__units2s(soap, ((ns2__DataTableType*)a)->ns2__units), 1);
	if (((ns2__DataTableType*)a)->parameter)
		soap_set_attr(soap, "parameter", ((ns2__DataTableType*)a)->parameter->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataTableType), type))
		return soap->error;
	if (soap_out_ns2__DataListType(soap, "ns2:DataList", -1, &(a->ns2__DataTableType::DataList), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataListType(soap, "ns2:Error", -1, &(a->ns2__DataTableType::Error), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataListType(soap, "ns2:NegativeError", -1, &(a->ns2__DataTableType::NegativeError), ""))
		return soap->error;
	if (soap_out_PointerTons2__DataListType(soap, "ns2:PositiveError", -1, &(a->ns2__DataTableType::PositiveError), ""))
		return soap->error;
	soap_outliteral(soap, "ns2:DataDescription", &(a->ns2__DataTableType::DataDescription), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DataTableType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataTableType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataTableType * SOAP_FMAC4 soap_in_ns2__DataTableType(struct soap *soap, const char *tag, ns2__DataTableType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataTableType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataTableType, sizeof(ns2__DataTableType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataTableType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataTableType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_ns2__units(soap, soap_attr_value(soap, "ns2:units", 1), &((ns2__DataTableType*)a)->ns2__units))
		return NULL;
	{	const char *t = soap_attr_value(soap, "parameter", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__DataTableType*)a)->parameter = soap_new_std__string(soap, -1);
				((ns2__DataTableType*)a)->parameter->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_DataList1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_NegativeError1 = 1;
	size_t soap_flag_PositiveError1 = 1;
	size_t soap_flag_DataDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__DataListType(soap, "ns2:DataList", &(a->ns2__DataTableType::DataList), "ns2:DataListType"))
				{	soap_flag_DataList1--;
					continue;
				}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__DataListType(soap, "ns2:Error", &(a->ns2__DataTableType::Error), "ns2:DataListType"))
				{	soap_flag_Error1--;
					continue;
				}
			if (soap_flag_NegativeError1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__DataListType(soap, "ns2:NegativeError", &(a->ns2__DataTableType::NegativeError), "ns2:DataListType"))
				{	soap_flag_NegativeError1--;
					continue;
				}
			if (soap_flag_PositiveError1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__DataListType(soap, "ns2:PositiveError", &(a->ns2__DataTableType::PositiveError), "ns2:DataListType"))
				{	soap_flag_PositiveError1--;
					continue;
				}
			if (soap_flag_DataDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:DataDescription", &(a->ns2__DataTableType::DataDescription)))
				{	soap_flag_DataDescription1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataTableType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataTableType, 0, sizeof(ns2__DataTableType), 0, soap_copy_ns2__DataTableType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DataTableType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataTableType);
	if (this->soap_out(soap, tag?tag:"ns2:DataTableType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataTableType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataTableType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataTableType * SOAP_FMAC4 soap_get_ns2__DataTableType(struct soap *soap, ns2__DataTableType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataTableType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataTableType * SOAP_FMAC2 soap_instantiate_ns2__DataTableType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataTableType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataTableType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataTableType);
		if (size)
			*size = sizeof(ns2__DataTableType);
		((ns2__DataTableType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataTableType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DataTableType);
		for (int i = 0; i < n; i++)
			((ns2__DataTableType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DataTableType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataTableType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataTableType %p -> %p\n", q, p));
	*(ns2__DataTableType*)p = *(ns2__DataTableType*)q;
}

void ns2__DataSetsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__DataSetType(soap, &this->ns2__DataSetsType::DataSet);
	/* transient soap skipped */
}

void ns2__DataSetsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__DataSetType(soap, &this->ns2__DataSetsType::DataSet);
	/* transient soap skipped */
}

int ns2__DataSetsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataSetsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataSetsType(struct soap *soap, const char *tag, int id, const ns2__DataSetsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataSetsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__DataSetType(soap, "ns2:DataSet", -1, &(a->ns2__DataSetsType::DataSet), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DataSetsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataSetsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataSetsType * SOAP_FMAC4 soap_in_ns2__DataSetsType(struct soap *soap, const char *tag, ns2__DataSetsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataSetsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataSetsType, sizeof(ns2__DataSetsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataSetsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataSetsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__DataSetType(soap, "ns2:DataSet", &(a->ns2__DataSetsType::DataSet), "ns2:DataSetType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataSetsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataSetsType, 0, sizeof(ns2__DataSetsType), 0, soap_copy_ns2__DataSetsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__DataSetsType::DataSet.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DataSetsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataSetsType);
	if (this->soap_out(soap, tag?tag:"ns2:DataSetsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataSetsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataSetsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataSetsType * SOAP_FMAC4 soap_get_ns2__DataSetsType(struct soap *soap, ns2__DataSetsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataSetsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataSetsType * SOAP_FMAC2 soap_instantiate_ns2__DataSetsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataSetsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataSetsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataSetsType);
		if (size)
			*size = sizeof(ns2__DataSetsType);
		((ns2__DataSetsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataSetsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DataSetsType);
		for (int i = 0; i < n; i++)
			((ns2__DataSetsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DataSetsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataSetsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataSetsType %p -> %p\n", q, p));
	*(ns2__DataSetsType*)p = *(ns2__DataSetsType*)q;
}

void ns2__DataSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__FitDataType(soap, &this->ns2__DataSetType::FitData);
	soap_default_std__vectorTemplateOfPointerTons2__TabulatedDataType(soap, &this->ns2__DataSetType::TabulatedData);
	soap_default_ns2__DataDescriptionType(soap, &this->ns2__DataSetType::dataDescription);
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__DataSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__FitDataType(soap, &this->ns2__DataSetType::FitData);
	soap_serialize_std__vectorTemplateOfPointerTons2__TabulatedDataType(soap, &this->ns2__DataSetType::TabulatedData);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__DataSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataSetType(struct soap *soap, const char *tag, int id, const ns2__DataSetType *a, const char *type)
{
	soap_set_attr(soap, "dataDescription", soap_ns2__DataDescriptionType2s(soap, ((ns2__DataSetType*)a)->dataDescription), 1);
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataSetType), "ns2:DataSetType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__FitDataType(soap, "ns2:FitData", -1, &(a->ns2__DataSetType::FitData), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__TabulatedDataType(soap, "ns2:TabulatedData", -1, &(a->ns2__DataSetType::TabulatedData), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DataSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataSetType * SOAP_FMAC4 soap_in_ns2__DataSetType(struct soap *soap, const char *tag, ns2__DataSetType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataSetType, sizeof(ns2__DataSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataSetType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2ns2__DataDescriptionType(soap, soap_attr_value(soap, "dataDescription", 1), &((ns2__DataSetType*)a)->dataDescription))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__FitDataType(soap, "ns2:FitData", &(a->ns2__DataSetType::FitData), "ns2:FitDataType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__TabulatedDataType(soap, "ns2:TabulatedData", &(a->ns2__DataSetType::TabulatedData), "ns2:TabulatedDataType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataSetType, 0, sizeof(ns2__DataSetType), 0, soap_copy_ns2__DataSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__DataSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataSetType);
	if (this->soap_out(soap, tag?tag:"ns2:DataSetType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataSetType * SOAP_FMAC4 soap_get_ns2__DataSetType(struct soap *soap, ns2__DataSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataSetType * SOAP_FMAC2 soap_instantiate_ns2__DataSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataSetType);
		if (size)
			*size = sizeof(ns2__DataSetType);
		((ns2__DataSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataSetType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DataSetType);
		for (int i = 0; i < n; i++)
			((ns2__DataSetType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DataSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataSetType %p -> %p\n", q, p));
	*(ns2__DataSetType*)p = *(ns2__DataSetType*)q;
}

void ns2__DataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DataType::Value = NULL;
	this->ns2__DataType::Accuracy = NULL;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__DataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueType(soap, &this->ns2__DataType::Value);
	soap_serialize_PointerTostd__string(soap, &this->ns2__DataType::Accuracy);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__DataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataType(struct soap *soap, const char *tag, int id, const ns2__DataType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataType), "ns2:DataType"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__DataType::Value)
	{	if (soap_out_PointerTons2__ValueType(soap, "ns2:Value", -1, &a->ns2__DataType::Value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Value"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Accuracy", -1, &(a->ns2__DataType::Accuracy), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataType * SOAP_FMAC4 soap_in_ns2__DataType(struct soap *soap, const char *tag, ns2__DataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataType, sizeof(ns2__DataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments2 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_Accuracy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueType(soap, "ns2:Value", &(a->ns2__DataType::Value), "ns2:ValueType"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_Accuracy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Accuracy", &(a->ns2__DataType::Accuracy), "xsd:string"))
				{	soap_flag_Accuracy1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataType, 0, sizeof(ns2__DataType), 0, soap_copy_ns2__DataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataType);
	if (this->soap_out(soap, tag?tag:"ns2:DataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataType * SOAP_FMAC4 soap_get_ns2__DataType(struct soap *soap, ns2__DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataType * SOAP_FMAC2 soap_instantiate_ns2__DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:StateEnergyType"))
	{	cp->type = SOAP_TYPE_ns2__StateEnergyType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__StateEnergyType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__StateEnergyType);
			((ns2__StateEnergyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__StateEnergyType[n]);
			if (size)
				*size = n * sizeof(ns2__StateEnergyType);
			for (int i = 0; i < n; i++)
				((ns2__StateEnergyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__StateEnergyType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataType);
		if (size)
			*size = sizeof(ns2__DataType);
		((ns2__DataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DataType);
		for (int i = 0; i < n; i++)
			((ns2__DataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataType %p -> %p\n", q, p));
	*(ns2__DataType*)p = *(ns2__DataType*)q;
}

void ns2__ChemicalElementType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->ns2__ChemicalElementType::NuclearCharge);
	this->ns2__ChemicalElementType::ElementSymbol = NULL;
	/* transient soap skipped */
}

void ns2__ChemicalElementType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ChemicalElementType::NuclearCharge, SOAP_TYPE_xsd__positiveInteger);
	soap_serialize_xsd__positiveInteger(soap, &this->ns2__ChemicalElementType::NuclearCharge);
	soap_serialize_PointerTons2__ElementSymbolType(soap, &this->ns2__ChemicalElementType::ElementSymbol);
	/* transient soap skipped */
}

int ns2__ChemicalElementType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ChemicalElementType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ChemicalElementType(struct soap *soap, const char *tag, int id, const ns2__ChemicalElementType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ChemicalElementType), type))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "ns2:NuclearCharge", -1, &(a->ns2__ChemicalElementType::NuclearCharge), ""))
		return soap->error;
	if (soap_out_PointerTons2__ElementSymbolType(soap, "ns2:ElementSymbol", -1, &(a->ns2__ChemicalElementType::ElementSymbol), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ChemicalElementType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ChemicalElementType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ChemicalElementType * SOAP_FMAC4 soap_in_ns2__ChemicalElementType(struct soap *soap, const char *tag, ns2__ChemicalElementType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ChemicalElementType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ChemicalElementType, sizeof(ns2__ChemicalElementType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ChemicalElementType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ChemicalElementType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NuclearCharge1 = 1;
	size_t soap_flag_ElementSymbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NuclearCharge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns2:NuclearCharge", &(a->ns2__ChemicalElementType::NuclearCharge), "xsd:positiveInteger"))
				{	soap_flag_NuclearCharge1--;
					continue;
				}
			if (soap_flag_ElementSymbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__ElementSymbolType(soap, "ns2:ElementSymbol", &(a->ns2__ChemicalElementType::ElementSymbol), "ns2:ElementSymbolType"))
				{	soap_flag_ElementSymbol1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ChemicalElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ChemicalElementType, 0, sizeof(ns2__ChemicalElementType), 0, soap_copy_ns2__ChemicalElementType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NuclearCharge1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ChemicalElementType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ChemicalElementType);
	if (this->soap_out(soap, tag?tag:"ns2:ChemicalElementType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ChemicalElementType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ChemicalElementType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ChemicalElementType * SOAP_FMAC4 soap_get_ns2__ChemicalElementType(struct soap *soap, ns2__ChemicalElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ChemicalElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ChemicalElementType * SOAP_FMAC2 soap_instantiate_ns2__ChemicalElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ChemicalElementType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ChemicalElementType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ChemicalElementType);
		if (size)
			*size = sizeof(ns2__ChemicalElementType);
		((ns2__ChemicalElementType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ChemicalElementType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ChemicalElementType);
		for (int i = 0; i < n; i++)
			((ns2__ChemicalElementType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ChemicalElementType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ChemicalElementType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ChemicalElementType %p -> %p\n", q, p));
	*(ns2__ChemicalElementType*)p = *(ns2__ChemicalElementType*)q;
}

void ns2__PrimaryType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PrimaryType::Comments = NULL;
	this->ns2__PrimaryType::ns2__sourceRef = NULL;
	this->ns2__PrimaryType::ns2__methodRef = NULL;
	/* transient soap skipped */
}

void ns2__PrimaryType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__PrimaryType::Comments);
	/* transient soap skipped */
}

int ns2__PrimaryType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PrimaryType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PrimaryType(struct soap *soap, const char *tag, int id, const ns2__PrimaryType *a, const char *type)
{
	if (((ns2__PrimaryType*)a)->ns2__sourceRef)
		soap_set_attr(soap, "ns2:sourceRef", ((ns2__PrimaryType*)a)->ns2__sourceRef->c_str(), 1);
	if (((ns2__PrimaryType*)a)->ns2__methodRef)
		soap_set_attr(soap, "ns2:methodRef", ((ns2__PrimaryType*)a)->ns2__methodRef->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PrimaryType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Comments", -1, &(a->ns2__PrimaryType::Comments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PrimaryType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PrimaryType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PrimaryType * SOAP_FMAC4 soap_in_ns2__PrimaryType(struct soap *soap, const char *tag, ns2__PrimaryType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PrimaryType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PrimaryType, sizeof(ns2__PrimaryType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PrimaryType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PrimaryType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns2:sourceRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__sourceRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__sourceRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ns2:methodRef", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((ns2__PrimaryType*)a)->ns2__methodRef = soap_new_std__string(soap, -1);
				((ns2__PrimaryType*)a)->ns2__methodRef->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Comments", &(a->ns2__PrimaryType::Comments), "xsd:string"))
				{	soap_flag_Comments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PrimaryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PrimaryType, 0, sizeof(ns2__PrimaryType), 0, soap_copy_ns2__PrimaryType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__PrimaryType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PrimaryType);
	if (this->soap_out(soap, tag?tag:"ns2:PrimaryType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PrimaryType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PrimaryType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PrimaryType * SOAP_FMAC4 soap_get_ns2__PrimaryType(struct soap *soap, ns2__PrimaryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PrimaryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PrimaryType * SOAP_FMAC2 soap_instantiate_ns2__PrimaryType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PrimaryType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PrimaryType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:DataType"))
	{	cp->type = SOAP_TYPE_ns2__DataType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__DataType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__DataType);
			((ns2__DataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__DataType[n]);
			if (size)
				*size = n * sizeof(ns2__DataType);
			for (int i = 0; i < n; i++)
				((ns2__DataType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__DataType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:DataSetType"))
	{	cp->type = SOAP_TYPE_ns2__DataSetType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__DataSetType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__DataSetType);
			((ns2__DataSetType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__DataSetType[n]);
			if (size)
				*size = n * sizeof(ns2__DataSetType);
			for (int i = 0; i < n; i++)
				((ns2__DataSetType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__DataSetType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:TabulatedDataType"))
	{	cp->type = SOAP_TYPE_ns2__TabulatedDataType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__TabulatedDataType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__TabulatedDataType);
			((ns2__TabulatedDataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__TabulatedDataType[n]);
			if (size)
				*size = n * sizeof(ns2__TabulatedDataType);
			for (int i = 0; i < n; i++)
				((ns2__TabulatedDataType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__TabulatedDataType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:FitDataType"))
	{	cp->type = SOAP_TYPE_ns2__FitDataType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__FitDataType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__FitDataType);
			((ns2__FitDataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__FitDataType[n]);
			if (size)
				*size = n * sizeof(ns2__FitDataType);
			for (int i = 0; i < n; i++)
				((ns2__FitDataType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__FitDataType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:FunctionType"))
	{	cp->type = SOAP_TYPE_ns2__FunctionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__FunctionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__FunctionType);
			((ns2__FunctionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__FunctionType[n]);
			if (size)
				*size = n * sizeof(ns2__FunctionType);
			for (int i = 0; i < n; i++)
				((ns2__FunctionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__FunctionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:AtomsType"))
	{	cp->type = SOAP_TYPE_ns2__AtomsType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomsType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AtomsType);
			((ns2__AtomsType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomsType[n]);
			if (size)
				*size = n * sizeof(ns2__AtomsType);
			for (int i = 0; i < n; i++)
				((ns2__AtomsType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AtomsType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:AtomType"))
	{	cp->type = SOAP_TYPE_ns2__AtomType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AtomType);
			((ns2__AtomType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomType[n]);
			if (size)
				*size = n * sizeof(ns2__AtomType);
			for (int i = 0; i < n; i++)
				((ns2__AtomType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AtomType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:IsotopeParametersType"))
	{	cp->type = SOAP_TYPE_ns2__IsotopeParametersType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__IsotopeParametersType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__IsotopeParametersType);
			((ns2__IsotopeParametersType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__IsotopeParametersType[n]);
			if (size)
				*size = n * sizeof(ns2__IsotopeParametersType);
			for (int i = 0; i < n; i++)
				((ns2__IsotopeParametersType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__IsotopeParametersType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:IonStateType"))
	{	cp->type = SOAP_TYPE_ns2__IonStateType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__IonStateType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__IonStateType);
			((ns2__IonStateType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__IonStateType[n]);
			if (size)
				*size = n * sizeof(ns2__IonStateType);
			for (int i = 0; i < n; i++)
				((ns2__IonStateType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__IonStateType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:AtomicStateType"))
	{	cp->type = SOAP_TYPE_ns2__AtomicStateType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicStateType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AtomicStateType);
			((ns2__AtomicStateType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicStateType[n]);
			if (size)
				*size = n * sizeof(ns2__AtomicStateType);
			for (int i = 0; i < n; i++)
				((ns2__AtomicStateType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AtomicStateType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:AtomicNumericalDataType"))
	{	cp->type = SOAP_TYPE_ns2__AtomicNumericalDataType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicNumericalDataType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AtomicNumericalDataType);
			((ns2__AtomicNumericalDataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicNumericalDataType[n]);
			if (size)
				*size = n * sizeof(ns2__AtomicNumericalDataType);
			for (int i = 0; i < n; i++)
				((ns2__AtomicNumericalDataType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AtomicNumericalDataType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:AtomicCompositionType"))
	{	cp->type = SOAP_TYPE_ns2__AtomicCompositionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicCompositionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AtomicCompositionType);
			((ns2__AtomicCompositionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomicCompositionType[n]);
			if (size)
				*size = n * sizeof(ns2__AtomicCompositionType);
			for (int i = 0; i < n; i++)
				((ns2__AtomicCompositionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AtomicCompositionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:AtomNType"))
	{	cp->type = SOAP_TYPE_ns2__AtomNType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomNType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AtomNType);
			((ns2__AtomNType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AtomNType[n]);
			if (size)
				*size = n * sizeof(ns2__AtomNType);
			for (int i = 0; i < n; i++)
				((ns2__AtomNType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AtomNType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:MolecularStateType"))
	{	cp->type = SOAP_TYPE_ns2__MolecularStateType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__MolecularStateType);
			((ns2__MolecularStateType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__MolecularStateType[n]);
			if (size)
				*size = n * sizeof(ns2__MolecularStateType);
			for (int i = 0; i < n; i++)
				((ns2__MolecularStateType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__MolecularStateType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:MoleculeType"))
	{	cp->type = SOAP_TYPE_ns2__MoleculeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculeType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__MoleculeType);
			((ns2__MoleculeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculeType[n]);
			if (size)
				*size = n * sizeof(ns2__MoleculeType);
			for (int i = 0; i < n; i++)
				((ns2__MoleculeType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__MoleculeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:MoleculesType"))
	{	cp->type = SOAP_TYPE_ns2__MoleculesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__MoleculesType);
			((ns2__MoleculesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__MoleculesType[n]);
			if (size)
				*size = n * sizeof(ns2__MoleculesType);
			for (int i = 0; i < n; i++)
				((ns2__MoleculesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__MoleculesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:PseudoStatisticalWeightType"))
	{	cp->type = SOAP_TYPE_ns2__PseudoStatisticalWeightType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__PseudoStatisticalWeightType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__PseudoStatisticalWeightType);
			((ns2__PseudoStatisticalWeightType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__PseudoStatisticalWeightType[n]);
			if (size)
				*size = n * sizeof(ns2__PseudoStatisticalWeightType);
			for (int i = 0; i < n; i++)
				((ns2__PseudoStatisticalWeightType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__PseudoStatisticalWeightType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:RoVibronicSplittingType"))
	{	cp->type = SOAP_TYPE_ns2__RoVibronicSplittingType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__RoVibronicSplittingType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__RoVibronicSplittingType);
			((ns2__RoVibronicSplittingType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__RoVibronicSplittingType[n]);
			if (size)
				*size = n * sizeof(ns2__RoVibronicSplittingType);
			for (int i = 0; i < n; i++)
				((ns2__RoVibronicSplittingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__RoVibronicSplittingType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SymbolType"))
	{	cp->type = SOAP_TYPE_ns2__SymbolType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SymbolType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SymbolType);
			((ns2__SymbolType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SymbolType[n]);
			if (size)
				*size = n * sizeof(ns2__SymbolType);
			for (int i = 0; i < n; i++)
				((ns2__SymbolType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SymbolType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:CharacterisationType"))
	{	cp->type = SOAP_TYPE_ns2__CharacterisationType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CharacterisationType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__CharacterisationType);
			((ns2__CharacterisationType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__CharacterisationType[n]);
			if (size)
				*size = n * sizeof(ns2__CharacterisationType);
			for (int i = 0; i < n; i++)
				((ns2__CharacterisationType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__CharacterisationType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SolidType"))
	{	cp->type = SOAP_TYPE_ns2__SolidType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SolidType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SolidType);
			((ns2__SolidType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SolidType[n]);
			if (size)
				*size = n * sizeof(ns2__SolidType);
			for (int i = 0; i < n; i++)
				((ns2__SolidType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SolidType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SolidsType"))
	{	cp->type = SOAP_TYPE_ns2__SolidsType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SolidsType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SolidsType);
			((ns2__SolidsType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SolidsType[n]);
			if (size)
				*size = n * sizeof(ns2__SolidsType);
			for (int i = 0; i < n; i++)
				((ns2__SolidsType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SolidsType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:MaterialCompositionType"))
	{	cp->type = SOAP_TYPE_ns2__MaterialCompositionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialCompositionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__MaterialCompositionType);
			((ns2__MaterialCompositionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__MaterialCompositionType[n]);
			if (size)
				*size = n * sizeof(ns2__MaterialCompositionType);
			for (int i = 0; i < n; i++)
				((ns2__MaterialCompositionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__MaterialCompositionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:RadiativeType"))
	{	cp->type = SOAP_TYPE_ns2__RadiativeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__RadiativeType);
			((ns2__RadiativeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeType[n]);
			if (size)
				*size = n * sizeof(ns2__RadiativeType);
			for (int i = 0; i < n; i++)
				((ns2__RadiativeType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__RadiativeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:RadiativeTransitionType"))
	{	cp->type = SOAP_TYPE_ns2__RadiativeTransitionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__RadiativeTransitionType);
			((ns2__RadiativeTransitionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionType[n]);
			if (size)
				*size = n * sizeof(ns2__RadiativeTransitionType);
			for (int i = 0; i < n; i++)
				((ns2__RadiativeTransitionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__RadiativeTransitionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:RadiativeTransitionProbabilityType"))
	{	cp->type = SOAP_TYPE_ns2__RadiativeTransitionProbabilityType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionProbabilityType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__RadiativeTransitionProbabilityType);
			((ns2__RadiativeTransitionProbabilityType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__RadiativeTransitionProbabilityType[n]);
			if (size)
				*size = n * sizeof(ns2__RadiativeTransitionProbabilityType);
			for (int i = 0; i < n; i++)
				((ns2__RadiativeTransitionProbabilityType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__RadiativeTransitionProbabilityType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:WavelengthWavenumberType"))
	{	cp->type = SOAP_TYPE_ns2__WavelengthWavenumberType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__WavelengthWavenumberType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__WavelengthWavenumberType);
			((ns2__WavelengthWavenumberType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__WavelengthWavenumberType[n]);
			if (size)
				*size = n * sizeof(ns2__WavelengthWavenumberType);
			for (int i = 0; i < n; i++)
				((ns2__WavelengthWavenumberType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__WavelengthWavenumberType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:EnergyWavelengthType"))
	{	cp->type = SOAP_TYPE_ns2__EnergyWavelengthType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__EnergyWavelengthType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__EnergyWavelengthType);
			((ns2__EnergyWavelengthType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__EnergyWavelengthType[n]);
			if (size)
				*size = n * sizeof(ns2__EnergyWavelengthType);
			for (int i = 0; i < n; i++)
				((ns2__EnergyWavelengthType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__EnergyWavelengthType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:NonRadiativeType"))
	{	cp->type = SOAP_TYPE_ns2__NonRadiativeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__NonRadiativeType);
			((ns2__NonRadiativeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeType[n]);
			if (size)
				*size = n * sizeof(ns2__NonRadiativeType);
			for (int i = 0; i < n; i++)
				((ns2__NonRadiativeType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__NonRadiativeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:NonRadiativeTransitionType"))
	{	cp->type = SOAP_TYPE_ns2__NonRadiativeTransitionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeTransitionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__NonRadiativeTransitionType);
			((ns2__NonRadiativeTransitionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__NonRadiativeTransitionType[n]);
			if (size)
				*size = n * sizeof(ns2__NonRadiativeTransitionType);
			for (int i = 0; i < n; i++)
				((ns2__NonRadiativeTransitionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__NonRadiativeTransitionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:CollisionsType"))
	{	cp->type = SOAP_TYPE_ns2__CollisionsType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionsType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__CollisionsType);
			((ns2__CollisionsType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionsType[n]);
			if (size)
				*size = n * sizeof(ns2__CollisionsType);
			for (int i = 0; i < n; i++)
				((ns2__CollisionsType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__CollisionsType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:CollisionalTransitionType"))
	{	cp->type = SOAP_TYPE_ns2__CollisionalTransitionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionalTransitionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__CollisionalTransitionType);
			((ns2__CollisionalTransitionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollisionalTransitionType[n]);
			if (size)
				*size = n * sizeof(ns2__CollisionalTransitionType);
			for (int i = 0; i < n; i++)
				((ns2__CollisionalTransitionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__CollisionalTransitionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:StateEnergyType"))
	{	cp->type = SOAP_TYPE_ns2__StateEnergyType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__StateEnergyType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__StateEnergyType);
			((ns2__StateEnergyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__StateEnergyType[n]);
			if (size)
				*size = n * sizeof(ns2__StateEnergyType);
			for (int i = 0; i < n; i++)
				((ns2__StateEnergyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__StateEnergyType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PrimaryType);
		if (size)
			*size = sizeof(ns2__PrimaryType);
		((ns2__PrimaryType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PrimaryType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PrimaryType);
		for (int i = 0; i < n; i++)
			((ns2__PrimaryType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PrimaryType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PrimaryType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PrimaryType %p -> %p\n", q, p));
	*(ns2__PrimaryType*)p = *(ns2__PrimaryType*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__token, 0, sizeof(std::string), 0, soap_copy_xsd__token);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag?tag:"xsd:token", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__positiveInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__positiveInteger, 0, sizeof(std::string), 0, soap_copy_xsd__positiveInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag?tag:"xsd:positiveInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__gYear(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__gYear), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__gYear(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__gYear, 0, sizeof(std::string), 0, soap_copy_xsd__gYear);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__gYear(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__gYear);
	if (soap_out_xsd__gYear(soap, tag?tag:"xsd:gYear", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__gYear(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__gYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__date, 0, sizeof(std::string), 0, soap_copy_xsd__date);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREFS(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__IDREFS), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__IDREFS(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREFS, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREFS, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__IDREFS, 0, sizeof(std::string), 0, soap_copy_xsd__IDREFS);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREFS(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREFS);
	if (soap_out_xsd__IDREFS(soap, tag?tag:"xsd:IDREFS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__IDREFS(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREFS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__IDREF), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__IDREF(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__IDREF, 0, sizeof(std::string), 0, soap_copy_xsd__IDREF);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	if (soap_out_xsd__IDREF(soap, tag?tag:"xsd:IDREF", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__DataTableType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__DataTableType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__DataTableType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__DataTableType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__DataTableType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__DataTableType, 0, sizeof(std::string), 0, soap_copy_xsd__DataTableType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__DataTableType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__DataTableType);
	if (soap_out_xsd__DataTableType(soap, tag?tag:"xsd:DataTableType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__DataTableType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__DataTableType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getS(struct soap *soap, struct ns2__getS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->species1);
	soap_default_std__string(soap, &a->species2);
	soap_default_unsignedInt(soap, &a->s);
	soap_default_double(soap, &a->x0);
	soap_default_double(soap, &a->Tmin);
	soap_default_double(soap, &a->Tmax);
	soap_default_double(soap, &a->Npoints);
	soap_default_bool(soap, &a->logaritmic);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getS(struct soap *soap, const struct ns2__getS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->species1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->species1);
	soap_embedded(soap, &a->species2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->species2);
	soap_embedded(soap, &a->x0, SOAP_TYPE_double);
	soap_embedded(soap, &a->Tmin, SOAP_TYPE_double);
	soap_embedded(soap, &a->Tmax, SOAP_TYPE_double);
	soap_embedded(soap, &a->Npoints, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getS(struct soap *soap, const char *tag, int id, const struct ns2__getS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getS), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:species1", -1, &a->species1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:species2", -1, &a->species2, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "ns2:s", -1, &a->s, ""))
		return soap->error;
	if (soap_out_double(soap, "ns2:x0", -1, &a->x0, ""))
		return soap->error;
	if (soap_out_double(soap, "ns2:Tmin", -1, &a->Tmin, ""))
		return soap->error;
	if (soap_out_double(soap, "ns2:Tmax", -1, &a->Tmax, ""))
		return soap->error;
	if (soap_out_double(soap, "ns2:Npoints", -1, &a->Npoints, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns2:logaritmic", -1, &a->logaritmic, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getS * SOAP_FMAC4 soap_in_ns2__getS(struct soap *soap, const char *tag, struct ns2__getS *a, const char *type)
{
	size_t soap_flag_species1 = 1;
	size_t soap_flag_species2 = 1;
	size_t soap_flag_s = 1;
	size_t soap_flag_x0 = 1;
	size_t soap_flag_Tmin = 1;
	size_t soap_flag_Tmax = 1;
	size_t soap_flag_Npoints = 1;
	size_t soap_flag_logaritmic = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getS, sizeof(struct ns2__getS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns2__getS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_species1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:species1", &a->species1, "xsd:string"))
				{	soap_flag_species1--;
					continue;
				}
			if (soap_flag_species2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:species2", &a->species2, "xsd:string"))
				{	soap_flag_species2--;
					continue;
				}
			if (soap_flag_s && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "ns2:s", &a->s, "xsd:unsignedInt"))
				{	soap_flag_s--;
					continue;
				}
			if (soap_flag_x0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:x0", &a->x0, "xsd:double"))
				{	soap_flag_x0--;
					continue;
				}
			if (soap_flag_Tmin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:Tmin", &a->Tmin, "xsd:double"))
				{	soap_flag_Tmin--;
					continue;
				}
			if (soap_flag_Tmax && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:Tmax", &a->Tmax, "xsd:double"))
				{	soap_flag_Tmax--;
					continue;
				}
			if (soap_flag_Npoints && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:Npoints", &a->Npoints, "xsd:double"))
				{	soap_flag_Npoints--;
					continue;
				}
			if (soap_flag_logaritmic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns2:logaritmic", &a->logaritmic, "xsd:boolean"))
				{	soap_flag_logaritmic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getS, 0, sizeof(struct ns2__getS), 0, soap_copy_ns2__getS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_species1 > 0 || soap_flag_species2 > 0 || soap_flag_s > 0 || soap_flag_x0 > 0 || soap_flag_Tmin > 0 || soap_flag_Tmax > 0 || soap_flag_Npoints > 0 || soap_flag_logaritmic > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getS(struct soap *soap, const struct ns2__getS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getS);
	if (soap_out_ns2__getS(soap, tag?tag:"ns2:getS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__getS * SOAP_FMAC4 soap_get_ns2__getS(struct soap *soap, struct ns2__getS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__getS * SOAP_FMAC2 soap_instantiate_ns2__getS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__getS);
		if (size)
			*size = sizeof(struct ns2__getS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__getS[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns2__getS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns2__getS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getS %p -> %p\n", q, p));
	*(struct ns2__getS*)p = *(struct ns2__getS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getSResponse(struct soap *soap, struct ns2__getSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__DataTableType(soap, &a->dat);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getSResponse(struct soap *soap, const struct ns2__getSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__DataTableType(soap, &a->dat);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSResponse(struct soap *soap, const char *tag, int id, const struct ns2__getSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSResponse), type))
		return soap->error;
	soap_element_result(soap, "ns2:dat");
	if (soap_out_xsd__DataTableType(soap, "ns2:dat", -1, &a->dat, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getSResponse * SOAP_FMAC4 soap_in_ns2__getSResponse(struct soap *soap, const char *tag, struct ns2__getSResponse *a, const char *type)
{
	size_t soap_flag_dat = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSResponse, sizeof(struct ns2__getSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns2__getSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__DataTableType(soap, "ns2:dat", &a->dat, "xsd:DataTableType"))
				{	soap_flag_dat--;
					continue;
				}
			soap_check_result(soap, "ns2:dat");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSResponse, 0, sizeof(struct ns2__getSResponse), 0, soap_copy_ns2__getSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dat > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getSResponse(struct soap *soap, const struct ns2__getSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getSResponse);
	if (soap_out_ns2__getSResponse(soap, tag?tag:"ns2:getSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__getSResponse * SOAP_FMAC4 soap_get_ns2__getSResponse(struct soap *soap, struct ns2__getSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__getSResponse * SOAP_FMAC2 soap_instantiate_ns2__getSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__getSResponse);
		if (size)
			*size = sizeof(struct ns2__getSResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__getSResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns2__getSResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns2__getSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getSResponse %p -> %p\n", q, p));
	*(struct ns2__getSResponse*)p = *(struct ns2__getSResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_CharacterisationType(struct soap *soap, int choice, const union _ns2__union_CharacterisationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_CharacterisationType_IntValue:
		soap_serialize_PointerToxsd__integer(soap, &a->IntValue);
		break;
	case SOAP_UNION__ns2__union_CharacterisationType_FloatValue:
		break;
	case SOAP_UNION__ns2__union_CharacterisationType_StringValue:
		soap_serialize_PointerTostd__string(soap, &a->StringValue);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_CharacterisationType(struct soap *soap, int choice, const union _ns2__union_CharacterisationType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_CharacterisationType_IntValue:
		return soap_out_PointerToxsd__integer(soap, "ns2:IntValue", -1, &a->IntValue, "");
	case SOAP_UNION__ns2__union_CharacterisationType_FloatValue:
		return soap_out_float(soap, "ns2:FloatValue", -1, &a->FloatValue, "");
	case SOAP_UNION__ns2__union_CharacterisationType_StringValue:
		return soap_out_PointerTostd__string(soap, "ns2:StringValue", -1, &a->StringValue, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_CharacterisationType * SOAP_FMAC4 soap_in__ns2__union_CharacterisationType(struct soap *soap, int *choice, union _ns2__union_CharacterisationType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->IntValue = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__integer(soap, "ns2:IntValue", &a->IntValue, "xsd:integer"))
	{	*choice = SOAP_UNION__ns2__union_CharacterisationType_IntValue;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_float(soap, "ns2:FloatValue", &a->FloatValue, "xsd:float"))
	{	*choice = SOAP_UNION__ns2__union_CharacterisationType_FloatValue;
		return a;
	}
	a->StringValue = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "ns2:StringValue", &a->StringValue, "xsd:string"))
	{	*choice = SOAP_UNION__ns2__union_CharacterisationType_StringValue;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_MaterialComponentType(struct soap *soap, int choice, const union _ns2__union_MaterialComponentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_MaterialComponentType_StoichiometricValue:
		soap_serialize_PointerToxsd__decimal(soap, &a->StoichiometricValue);
		break;
	case SOAP_UNION__ns2__union_MaterialComponentType_Percentage:
		soap_serialize_PointerToxsd__decimal(soap, &a->Percentage);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_MaterialComponentType(struct soap *soap, int choice, const union _ns2__union_MaterialComponentType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_MaterialComponentType_StoichiometricValue:
		return soap_out_PointerToxsd__decimal(soap, "ns2:StoichiometricValue", -1, &a->StoichiometricValue, "");
	case SOAP_UNION__ns2__union_MaterialComponentType_Percentage:
		return soap_out_PointerToxsd__decimal(soap, "ns2:Percentage", -1, &a->Percentage, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_MaterialComponentType * SOAP_FMAC4 soap_in__ns2__union_MaterialComponentType(struct soap *soap, int *choice, union _ns2__union_MaterialComponentType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->StoichiometricValue = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__decimal(soap, "ns2:StoichiometricValue", &a->StoichiometricValue, "xsd:decimal"))
	{	*choice = SOAP_UNION__ns2__union_MaterialComponentType_StoichiometricValue;
		return a;
	}
	a->Percentage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__decimal(soap, "ns2:Percentage", &a->Percentage, "xsd:decimal"))
	{	*choice = SOAP_UNION__ns2__union_MaterialComponentType_Percentage;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, int choice, const union _ns2__union_HyperfineQuantumNumbersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_ISum:
		soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &a->ISum);
		break;
	case SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_IntermediateHyperfineQuantumNumber:
		soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &a->IntermediateHyperfineQuantumNumber);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, int choice, const union _ns2__union_HyperfineQuantumNumbersType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_ISum:
		return soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:ISum", -1, &a->ISum, "");
	case SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_IntermediateHyperfineQuantumNumber:
		return soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:IntermediateHyperfineQuantumNumber", -1, &a->IntermediateHyperfineQuantumNumber, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_HyperfineQuantumNumbersType * SOAP_FMAC4 soap_in__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, int *choice, union _ns2__union_HyperfineQuantumNumbersType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->ISum = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:ISum", &a->ISum, "ns2:ComplexMolecularQuantumNumberType"))
	{	*choice = SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_ISum;
		return a;
	}
	a->IntermediateHyperfineQuantumNumber = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, "ns2:IntermediateHyperfineQuantumNumber", &a->IntermediateHyperfineQuantumNumber, "ns2:ComplexMolecularQuantumNumberType"))
	{	*choice = SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_IntermediateHyperfineQuantumNumber;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_RotationalComponentType(struct soap *soap, int choice, const union _ns2__union_RotationalComponentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_RotationalComponentType_DiatomAndLinearPolyatomic:
		soap_serialize_PointerTons2__DiatomAndLinearPolyatomicType(soap, &a->DiatomAndLinearPolyatomic);
		break;
	case SOAP_UNION__ns2__union_RotationalComponentType_NonLinearPolyatomic:
		soap_serialize_PointerTons2__NonLinearPolyatomicType(soap, &a->NonLinearPolyatomic);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_RotationalComponentType(struct soap *soap, int choice, const union _ns2__union_RotationalComponentType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_RotationalComponentType_DiatomAndLinearPolyatomic:
		return soap_out_PointerTons2__DiatomAndLinearPolyatomicType(soap, "ns2:DiatomAndLinearPolyatomic", -1, &a->DiatomAndLinearPolyatomic, "");
	case SOAP_UNION__ns2__union_RotationalComponentType_NonLinearPolyatomic:
		return soap_out_PointerTons2__NonLinearPolyatomicType(soap, "ns2:NonLinearPolyatomic", -1, &a->NonLinearPolyatomic, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_RotationalComponentType * SOAP_FMAC4 soap_in__ns2__union_RotationalComponentType(struct soap *soap, int *choice, union _ns2__union_RotationalComponentType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->DiatomAndLinearPolyatomic = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__DiatomAndLinearPolyatomicType(soap, "ns2:DiatomAndLinearPolyatomic", &a->DiatomAndLinearPolyatomic, "ns2:DiatomAndLinearPolyatomicType"))
	{	*choice = SOAP_UNION__ns2__union_RotationalComponentType_DiatomAndLinearPolyatomic;
		return a;
	}
	a->NonLinearPolyatomic = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__NonLinearPolyatomicType(soap, "ns2:NonLinearPolyatomic", &a->NonLinearPolyatomic, "ns2:NonLinearPolyatomicType"))
	{	*choice = SOAP_UNION__ns2__union_RotationalComponentType_NonLinearPolyatomic;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_NonLinearPolyatomicType(struct soap *soap, int choice, const union _ns2__union_NonLinearPolyatomicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecNoHyperF:
		soap_serialize_PointerTons2__NonLinearNoElecNoHyperFType(soap, &a->NonLinearNoElecNoHyperF);
		break;
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecHyperF:
		soap_serialize_PointerTons2__NonLinearNoElecHyperFType(soap, &a->NonLinearNoElecHyperF);
		break;
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecNoHyperF:
		soap_serialize_PointerTons2__NonLinearElecNoHyperFType(soap, &a->NonLinearElecNoHyperF);
		break;
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecHyperF:
		soap_serialize_PointerTons2__NonLinearElecHyperFType(soap, &a->NonLinearElecHyperF);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_NonLinearPolyatomicType(struct soap *soap, int choice, const union _ns2__union_NonLinearPolyatomicType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecNoHyperF:
		return soap_out_PointerTons2__NonLinearNoElecNoHyperFType(soap, "ns2:NonLinearNoElecNoHyperF", -1, &a->NonLinearNoElecNoHyperF, "");
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecHyperF:
		return soap_out_PointerTons2__NonLinearNoElecHyperFType(soap, "ns2:NonLinearNoElecHyperF", -1, &a->NonLinearNoElecHyperF, "");
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecNoHyperF:
		return soap_out_PointerTons2__NonLinearElecNoHyperFType(soap, "ns2:NonLinearElecNoHyperF", -1, &a->NonLinearElecNoHyperF, "");
	case SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecHyperF:
		return soap_out_PointerTons2__NonLinearElecHyperFType(soap, "ns2:NonLinearElecHyperF", -1, &a->NonLinearElecHyperF, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_NonLinearPolyatomicType * SOAP_FMAC4 soap_in__ns2__union_NonLinearPolyatomicType(struct soap *soap, int *choice, union _ns2__union_NonLinearPolyatomicType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->NonLinearNoElecNoHyperF = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__NonLinearNoElecNoHyperFType(soap, "ns2:NonLinearNoElecNoHyperF", &a->NonLinearNoElecNoHyperF, "ns2:NonLinearNoElecNoHyperFType"))
	{	*choice = SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecNoHyperF;
		return a;
	}
	a->NonLinearNoElecHyperF = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__NonLinearNoElecHyperFType(soap, "ns2:NonLinearNoElecHyperF", &a->NonLinearNoElecHyperF, "ns2:NonLinearNoElecHyperFType"))
	{	*choice = SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearNoElecHyperF;
		return a;
	}
	a->NonLinearElecNoHyperF = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__NonLinearElecNoHyperFType(soap, "ns2:NonLinearElecNoHyperF", &a->NonLinearElecNoHyperF, "ns2:NonLinearElecNoHyperFType"))
	{	*choice = SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecNoHyperF;
		return a;
	}
	a->NonLinearElecHyperF = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__NonLinearElecHyperFType(soap, "ns2:NonLinearElecHyperF", &a->NonLinearElecHyperF, "ns2:NonLinearElecHyperFType"))
	{	*choice = SOAP_UNION__ns2__union_NonLinearPolyatomicType_NonLinearElecHyperF;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_DiatomAndLinearPolyatomicType(struct soap *soap, int choice, const union _ns2__union_DiatomAndLinearPolyatomicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecNoHyperF:
		soap_serialize_PointerTons2__LinearNoElecNoHyperFType(soap, &a->LinearNoElecNoHyperF);
		break;
	case SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecHyperF:
		soap_serialize_PointerTons2__LinearNoElecHyperFType(soap, &a->LinearNoElecHyperF);
		break;
	case SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearElecCoupling:
		soap_serialize_PointerTons2__LinearElecCouplingType(soap, &a->LinearElecCoupling);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_DiatomAndLinearPolyatomicType(struct soap *soap, int choice, const union _ns2__union_DiatomAndLinearPolyatomicType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecNoHyperF:
		return soap_out_PointerTons2__LinearNoElecNoHyperFType(soap, "ns2:LinearNoElecNoHyperF", -1, &a->LinearNoElecNoHyperF, "");
	case SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecHyperF:
		return soap_out_PointerTons2__LinearNoElecHyperFType(soap, "ns2:LinearNoElecHyperF", -1, &a->LinearNoElecHyperF, "");
	case SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearElecCoupling:
		return soap_out_PointerTons2__LinearElecCouplingType(soap, "ns2:LinearElecCoupling", -1, &a->LinearElecCoupling, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_DiatomAndLinearPolyatomicType * SOAP_FMAC4 soap_in__ns2__union_DiatomAndLinearPolyatomicType(struct soap *soap, int *choice, union _ns2__union_DiatomAndLinearPolyatomicType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->LinearNoElecNoHyperF = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__LinearNoElecNoHyperFType(soap, "ns2:LinearNoElecNoHyperF", &a->LinearNoElecNoHyperF, "ns2:LinearNoElecNoHyperFType"))
	{	*choice = SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecNoHyperF;
		return a;
	}
	a->LinearNoElecHyperF = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__LinearNoElecHyperFType(soap, "ns2:LinearNoElecHyperF", &a->LinearNoElecHyperF, "ns2:LinearNoElecHyperFType"))
	{	*choice = SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearNoElecHyperF;
		return a;
	}
	a->LinearElecCoupling = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__LinearElecCouplingType(soap, "ns2:LinearElecCoupling", &a->LinearElecCoupling, "ns2:LinearElecCouplingType"))
	{	*choice = SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_LinearElecCoupling;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataSetsType(struct soap *soap, ns2__DataSetsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataSetsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataSetsType(struct soap *soap, const char *tag, int id, ns2__DataSetsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataSetsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DataSetsType ** SOAP_FMAC4 soap_in_PointerTons2__DataSetsType(struct soap *soap, const char *tag, ns2__DataSetsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DataSetsType **)soap_malloc(soap, sizeof(ns2__DataSetsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DataSetsType *)soap_instantiate_ns2__DataSetsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DataSetsType ** p = (ns2__DataSetsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataSetsType, sizeof(ns2__DataSetsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataSetsType(struct soap *soap, ns2__DataSetsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataSetsType);
	if (soap_out_PointerTons2__DataSetsType(soap, tag?tag:"ns2:DataSetsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DataSetsType ** SOAP_FMAC4 soap_get_PointerTons2__DataSetsType(struct soap *soap, ns2__DataSetsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataSetsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ProductsType(struct soap *soap, ns2__ProductsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ProductsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ProductsType(struct soap *soap, const char *tag, int id, ns2__ProductsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ProductsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ProductsType ** SOAP_FMAC4 soap_in_PointerTons2__ProductsType(struct soap *soap, const char *tag, ns2__ProductsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ProductsType **)soap_malloc(soap, sizeof(ns2__ProductsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ProductsType *)soap_instantiate_ns2__ProductsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ProductsType ** p = (ns2__ProductsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ProductsType, sizeof(ns2__ProductsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ProductsType(struct soap *soap, ns2__ProductsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ProductsType);
	if (soap_out_PointerTons2__ProductsType(soap, tag?tag:"ns2:ProductsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ProductsType ** SOAP_FMAC4 soap_get_PointerTons2__ProductsType(struct soap *soap, ns2__ProductsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ProductsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReactantsType(struct soap *soap, ns2__ReactantsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReactantsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReactantsType(struct soap *soap, const char *tag, int id, ns2__ReactantsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReactantsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReactantsType ** SOAP_FMAC4 soap_in_PointerTons2__ReactantsType(struct soap *soap, const char *tag, ns2__ReactantsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReactantsType **)soap_malloc(soap, sizeof(ns2__ReactantsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReactantsType *)soap_instantiate_ns2__ReactantsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ReactantsType ** p = (ns2__ReactantsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReactantsType, sizeof(ns2__ReactantsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReactantsType(struct soap *soap, ns2__ReactantsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReactantsType);
	if (soap_out_PointerTons2__ReactantsType(soap, tag?tag:"ns2:ReactantsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReactantsType ** SOAP_FMAC4 soap_get_PointerTons2__ReactantsType(struct soap *soap, ns2__ReactantsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReactantsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CollisionalProcessClassType(struct soap *soap, ns2__CollisionalProcessClassType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CollisionalProcessClassType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CollisionalProcessClassType(struct soap *soap, const char *tag, int id, ns2__CollisionalProcessClassType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CollisionalProcessClassType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CollisionalProcessClassType ** SOAP_FMAC4 soap_in_PointerTons2__CollisionalProcessClassType(struct soap *soap, const char *tag, ns2__CollisionalProcessClassType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CollisionalProcessClassType **)soap_malloc(soap, sizeof(ns2__CollisionalProcessClassType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CollisionalProcessClassType *)soap_instantiate_ns2__CollisionalProcessClassType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CollisionalProcessClassType ** p = (ns2__CollisionalProcessClassType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CollisionalProcessClassType, sizeof(ns2__CollisionalProcessClassType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CollisionalProcessClassType(struct soap *soap, ns2__CollisionalProcessClassType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CollisionalProcessClassType);
	if (soap_out_PointerTons2__CollisionalProcessClassType(soap, tag?tag:"ns2:CollisionalProcessClassType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CollisionalProcessClassType ** SOAP_FMAC4 soap_get_PointerTons2__CollisionalProcessClassType(struct soap *soap, ns2__CollisionalProcessClassType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CollisionalProcessClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CollisionalTransitionType(struct soap *soap, ns2__CollisionalTransitionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CollisionalTransitionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CollisionalTransitionType(struct soap *soap, const char *tag, int id, ns2__CollisionalTransitionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CollisionalTransitionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CollisionalTransitionType ** SOAP_FMAC4 soap_in_PointerTons2__CollisionalTransitionType(struct soap *soap, const char *tag, ns2__CollisionalTransitionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CollisionalTransitionType **)soap_malloc(soap, sizeof(ns2__CollisionalTransitionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CollisionalTransitionType *)soap_instantiate_ns2__CollisionalTransitionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CollisionalTransitionType ** p = (ns2__CollisionalTransitionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CollisionalTransitionType, sizeof(ns2__CollisionalTransitionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CollisionalTransitionType(struct soap *soap, ns2__CollisionalTransitionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CollisionalTransitionType);
	if (soap_out_PointerTons2__CollisionalTransitionType(soap, tag?tag:"ns2:CollisionalTransitionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CollisionalTransitionType ** SOAP_FMAC4 soap_get_PointerTons2__CollisionalTransitionType(struct soap *soap, ns2__CollisionalTransitionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CollisionalTransitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonRadiativeTransitionType(struct soap *soap, ns2__NonRadiativeTransitionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonRadiativeTransitionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonRadiativeTransitionType(struct soap *soap, const char *tag, int id, ns2__NonRadiativeTransitionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonRadiativeTransitionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonRadiativeTransitionType ** SOAP_FMAC4 soap_in_PointerTons2__NonRadiativeTransitionType(struct soap *soap, const char *tag, ns2__NonRadiativeTransitionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonRadiativeTransitionType **)soap_malloc(soap, sizeof(ns2__NonRadiativeTransitionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonRadiativeTransitionType *)soap_instantiate_ns2__NonRadiativeTransitionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonRadiativeTransitionType ** p = (ns2__NonRadiativeTransitionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonRadiativeTransitionType, sizeof(ns2__NonRadiativeTransitionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonRadiativeTransitionType(struct soap *soap, ns2__NonRadiativeTransitionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonRadiativeTransitionType);
	if (soap_out_PointerTons2__NonRadiativeTransitionType(soap, tag?tag:"ns2:NonRadiativeTransitionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonRadiativeTransitionType ** SOAP_FMAC4 soap_get_PointerTons2__NonRadiativeTransitionType(struct soap *soap, ns2__NonRadiativeTransitionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonRadiativeTransitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WavelengthWavenumberType(struct soap *soap, ns2__WavelengthWavenumberType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WavelengthWavenumberType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WavelengthWavenumberType(struct soap *soap, const char *tag, int id, ns2__WavelengthWavenumberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WavelengthWavenumberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__WavelengthWavenumberType ** SOAP_FMAC4 soap_in_PointerTons2__WavelengthWavenumberType(struct soap *soap, const char *tag, ns2__WavelengthWavenumberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__WavelengthWavenumberType **)soap_malloc(soap, sizeof(ns2__WavelengthWavenumberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__WavelengthWavenumberType *)soap_instantiate_ns2__WavelengthWavenumberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__WavelengthWavenumberType ** p = (ns2__WavelengthWavenumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WavelengthWavenumberType, sizeof(ns2__WavelengthWavenumberType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WavelengthWavenumberType(struct soap *soap, ns2__WavelengthWavenumberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WavelengthWavenumberType);
	if (soap_out_PointerTons2__WavelengthWavenumberType(soap, tag?tag:"ns2:WavelengthWavenumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__WavelengthWavenumberType ** SOAP_FMAC4 soap_get_PointerTons2__WavelengthWavenumberType(struct soap *soap, ns2__WavelengthWavenumberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WavelengthWavenumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MultipoleType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MultipoleType))
		soap_serialize_ns2__MultipoleType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MultipoleType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MultipoleType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MultipoleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__MultipoleType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MultipoleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MultipoleType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MultipoleType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MultipoleType);
	if (soap_out_PointerTons2__MultipoleType(soap, tag?tag:"ns2:MultipoleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__MultipoleType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MultipoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, ns2__RadiativeTransitionProbabilityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, const char *tag, int id, ns2__RadiativeTransitionProbabilityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RadiativeTransitionProbabilityType ** SOAP_FMAC4 soap_in_PointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, const char *tag, ns2__RadiativeTransitionProbabilityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RadiativeTransitionProbabilityType **)soap_malloc(soap, sizeof(ns2__RadiativeTransitionProbabilityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RadiativeTransitionProbabilityType *)soap_instantiate_ns2__RadiativeTransitionProbabilityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RadiativeTransitionProbabilityType ** p = (ns2__RadiativeTransitionProbabilityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RadiativeTransitionProbabilityType, sizeof(ns2__RadiativeTransitionProbabilityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, ns2__RadiativeTransitionProbabilityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RadiativeTransitionProbabilityType);
	if (soap_out_PointerTons2__RadiativeTransitionProbabilityType(soap, tag?tag:"ns2:RadiativeTransitionProbabilityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RadiativeTransitionProbabilityType ** SOAP_FMAC4 soap_get_PointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, ns2__RadiativeTransitionProbabilityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RadiativeTransitionProbabilityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StateRef(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StateRef))
		soap_serialize_ns2__StateRef(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StateRef(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StateRef);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__StateRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__StateRef(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__StateRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StateRef, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StateRef(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__StateRef);
	if (soap_out_PointerTons2__StateRef(soap, tag?tag:"ns2:StateRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__StateRef(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StateRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EnergyWavelengthType(struct soap *soap, ns2__EnergyWavelengthType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EnergyWavelengthType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EnergyWavelengthType(struct soap *soap, const char *tag, int id, ns2__EnergyWavelengthType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EnergyWavelengthType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EnergyWavelengthType ** SOAP_FMAC4 soap_in_PointerTons2__EnergyWavelengthType(struct soap *soap, const char *tag, ns2__EnergyWavelengthType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EnergyWavelengthType **)soap_malloc(soap, sizeof(ns2__EnergyWavelengthType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EnergyWavelengthType *)soap_instantiate_ns2__EnergyWavelengthType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EnergyWavelengthType ** p = (ns2__EnergyWavelengthType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EnergyWavelengthType, sizeof(ns2__EnergyWavelengthType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EnergyWavelengthType(struct soap *soap, ns2__EnergyWavelengthType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EnergyWavelengthType);
	if (soap_out_PointerTons2__EnergyWavelengthType(soap, tag?tag:"ns2:EnergyWavelengthType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EnergyWavelengthType ** SOAP_FMAC4 soap_get_PointerTons2__EnergyWavelengthType(struct soap *soap, ns2__EnergyWavelengthType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EnergyWavelengthType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RadiativeTransitionType(struct soap *soap, ns2__RadiativeTransitionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RadiativeTransitionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RadiativeTransitionType(struct soap *soap, const char *tag, int id, ns2__RadiativeTransitionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RadiativeTransitionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RadiativeTransitionType ** SOAP_FMAC4 soap_in_PointerTons2__RadiativeTransitionType(struct soap *soap, const char *tag, ns2__RadiativeTransitionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RadiativeTransitionType **)soap_malloc(soap, sizeof(ns2__RadiativeTransitionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RadiativeTransitionType *)soap_instantiate_ns2__RadiativeTransitionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RadiativeTransitionType ** p = (ns2__RadiativeTransitionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RadiativeTransitionType, sizeof(ns2__RadiativeTransitionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RadiativeTransitionType(struct soap *soap, ns2__RadiativeTransitionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RadiativeTransitionType);
	if (soap_out_PointerTons2__RadiativeTransitionType(soap, tag?tag:"ns2:RadiativeTransitionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RadiativeTransitionType ** SOAP_FMAC4 soap_get_PointerTons2__RadiativeTransitionType(struct soap *soap, ns2__RadiativeTransitionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RadiativeTransitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MaterialComponentType(struct soap *soap, ns2__MaterialComponentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MaterialComponentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MaterialComponentType(struct soap *soap, const char *tag, int id, ns2__MaterialComponentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MaterialComponentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MaterialComponentType ** SOAP_FMAC4 soap_in_PointerTons2__MaterialComponentType(struct soap *soap, const char *tag, ns2__MaterialComponentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MaterialComponentType **)soap_malloc(soap, sizeof(ns2__MaterialComponentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MaterialComponentType *)soap_instantiate_ns2__MaterialComponentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MaterialComponentType ** p = (ns2__MaterialComponentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MaterialComponentType, sizeof(ns2__MaterialComponentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MaterialComponentType(struct soap *soap, ns2__MaterialComponentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MaterialComponentType);
	if (soap_out_PointerTons2__MaterialComponentType(soap, tag?tag:"ns2:MaterialComponentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MaterialComponentType ** SOAP_FMAC4 soap_get_PointerTons2__MaterialComponentType(struct soap *soap, ns2__MaterialComponentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MaterialComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SolidType(struct soap *soap, ns2__SolidType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SolidType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SolidType(struct soap *soap, const char *tag, int id, ns2__SolidType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SolidType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SolidType ** SOAP_FMAC4 soap_in_PointerTons2__SolidType(struct soap *soap, const char *tag, ns2__SolidType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SolidType **)soap_malloc(soap, sizeof(ns2__SolidType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SolidType *)soap_instantiate_ns2__SolidType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SolidType ** p = (ns2__SolidType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SolidType, sizeof(ns2__SolidType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SolidType(struct soap *soap, ns2__SolidType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SolidType);
	if (soap_out_PointerTons2__SolidType(soap, tag?tag:"ns2:SolidType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SolidType ** SOAP_FMAC4 soap_get_PointerTons2__SolidType(struct soap *soap, ns2__SolidType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SolidType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MaterialType(struct soap *soap, ns2__MaterialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MaterialType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MaterialType(struct soap *soap, const char *tag, int id, ns2__MaterialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MaterialType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MaterialType ** SOAP_FMAC4 soap_in_PointerTons2__MaterialType(struct soap *soap, const char *tag, ns2__MaterialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MaterialType **)soap_malloc(soap, sizeof(ns2__MaterialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MaterialType *)soap_instantiate_ns2__MaterialType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MaterialType ** p = (ns2__MaterialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MaterialType, sizeof(ns2__MaterialType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MaterialType(struct soap *soap, ns2__MaterialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MaterialType);
	if (soap_out_PointerTons2__MaterialType(soap, tag?tag:"ns2:MaterialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MaterialType ** SOAP_FMAC4 soap_get_PointerTons2__MaterialType(struct soap *soap, ns2__MaterialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MaterialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SimpleSymbolType(struct soap *soap, ns2__SimpleSymbolType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SimpleSymbolType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SimpleSymbolType(struct soap *soap, const char *tag, int id, ns2__SimpleSymbolType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SimpleSymbolType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SimpleSymbolType ** SOAP_FMAC4 soap_in_PointerTons2__SimpleSymbolType(struct soap *soap, const char *tag, ns2__SimpleSymbolType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SimpleSymbolType **)soap_malloc(soap, sizeof(ns2__SimpleSymbolType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SimpleSymbolType *)soap_instantiate_ns2__SimpleSymbolType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SimpleSymbolType ** p = (ns2__SimpleSymbolType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SimpleSymbolType, sizeof(ns2__SimpleSymbolType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SimpleSymbolType(struct soap *soap, ns2__SimpleSymbolType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SimpleSymbolType);
	if (soap_out_PointerTons2__SimpleSymbolType(soap, tag?tag:"ns2:SimpleSymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SimpleSymbolType ** SOAP_FMAC4 soap_get_PointerTons2__SimpleSymbolType(struct soap *soap, ns2__SimpleSymbolType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SimpleSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MoleculeType(struct soap *soap, ns2__MoleculeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MoleculeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MoleculeType(struct soap *soap, const char *tag, int id, ns2__MoleculeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MoleculeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MoleculeType ** SOAP_FMAC4 soap_in_PointerTons2__MoleculeType(struct soap *soap, const char *tag, ns2__MoleculeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MoleculeType **)soap_malloc(soap, sizeof(ns2__MoleculeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MoleculeType *)soap_instantiate_ns2__MoleculeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MoleculeType ** p = (ns2__MoleculeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MoleculeType, sizeof(ns2__MoleculeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MoleculeType(struct soap *soap, ns2__MoleculeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MoleculeType);
	if (soap_out_PointerTons2__MoleculeType(soap, tag?tag:"ns2:MoleculeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MoleculeType ** SOAP_FMAC4 soap_get_PointerTons2__MoleculeType(struct soap *soap, ns2__MoleculeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MoleculeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MolecularStateType(struct soap *soap, ns2__MolecularStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MolecularStateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MolecularStateType(struct soap *soap, const char *tag, int id, ns2__MolecularStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MolecularStateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MolecularStateType ** SOAP_FMAC4 soap_in_PointerTons2__MolecularStateType(struct soap *soap, const char *tag, ns2__MolecularStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MolecularStateType **)soap_malloc(soap, sizeof(ns2__MolecularStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MolecularStateType *)soap_instantiate_ns2__MolecularStateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MolecularStateType ** p = (ns2__MolecularStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MolecularStateType, sizeof(ns2__MolecularStateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MolecularStateType(struct soap *soap, ns2__MolecularStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MolecularStateType);
	if (soap_out_PointerTons2__MolecularStateType(soap, tag?tag:"ns2:MolecularStateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MolecularStateType ** SOAP_FMAC4 soap_get_PointerTons2__MolecularStateType(struct soap *soap, ns2__MolecularStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MolecularStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MolecularChemicalSpeciesType(struct soap *soap, ns2__MolecularChemicalSpeciesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MolecularChemicalSpeciesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MolecularChemicalSpeciesType(struct soap *soap, const char *tag, int id, ns2__MolecularChemicalSpeciesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MolecularChemicalSpeciesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MolecularChemicalSpeciesType ** SOAP_FMAC4 soap_in_PointerTons2__MolecularChemicalSpeciesType(struct soap *soap, const char *tag, ns2__MolecularChemicalSpeciesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MolecularChemicalSpeciesType **)soap_malloc(soap, sizeof(ns2__MolecularChemicalSpeciesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MolecularChemicalSpeciesType *)soap_instantiate_ns2__MolecularChemicalSpeciesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MolecularChemicalSpeciesType ** p = (ns2__MolecularChemicalSpeciesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MolecularChemicalSpeciesType, sizeof(ns2__MolecularChemicalSpeciesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MolecularChemicalSpeciesType(struct soap *soap, ns2__MolecularChemicalSpeciesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MolecularChemicalSpeciesType);
	if (soap_out_PointerTons2__MolecularChemicalSpeciesType(soap, tag?tag:"ns2:MolecularChemicalSpeciesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MolecularChemicalSpeciesType ** SOAP_FMAC4 soap_get_PointerTons2__MolecularChemicalSpeciesType(struct soap *soap, ns2__MolecularChemicalSpeciesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MolecularChemicalSpeciesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ElectronicHomeType(struct soap *soap, ns2__ElectronicHomeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ElectronicHomeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ElectronicHomeType(struct soap *soap, const char *tag, int id, ns2__ElectronicHomeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ElectronicHomeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ElectronicHomeType ** SOAP_FMAC4 soap_in_PointerTons2__ElectronicHomeType(struct soap *soap, const char *tag, ns2__ElectronicHomeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ElectronicHomeType **)soap_malloc(soap, sizeof(ns2__ElectronicHomeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ElectronicHomeType *)soap_instantiate_ns2__ElectronicHomeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ElectronicHomeType ** p = (ns2__ElectronicHomeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ElectronicHomeType, sizeof(ns2__ElectronicHomeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ElectronicHomeType(struct soap *soap, ns2__ElectronicHomeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ElectronicHomeType);
	if (soap_out_PointerTons2__ElectronicHomeType(soap, tag?tag:"ns2:ElectronicHomeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ElectronicHomeType ** SOAP_FMAC4 soap_get_PointerTons2__ElectronicHomeType(struct soap *soap, ns2__ElectronicHomeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ElectronicHomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MolecularStateCharacterisationType(struct soap *soap, ns2__MolecularStateCharacterisationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MolecularStateCharacterisationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MolecularStateCharacterisationType(struct soap *soap, const char *tag, int id, ns2__MolecularStateCharacterisationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MolecularStateCharacterisationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MolecularStateCharacterisationType ** SOAP_FMAC4 soap_in_PointerTons2__MolecularStateCharacterisationType(struct soap *soap, const char *tag, ns2__MolecularStateCharacterisationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MolecularStateCharacterisationType **)soap_malloc(soap, sizeof(ns2__MolecularStateCharacterisationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MolecularStateCharacterisationType *)soap_instantiate_ns2__MolecularStateCharacterisationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MolecularStateCharacterisationType ** p = (ns2__MolecularStateCharacterisationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MolecularStateCharacterisationType, sizeof(ns2__MolecularStateCharacterisationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MolecularStateCharacterisationType(struct soap *soap, ns2__MolecularStateCharacterisationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MolecularStateCharacterisationType);
	if (soap_out_PointerTons2__MolecularStateCharacterisationType(soap, tag?tag:"ns2:MolecularStateCharacterisationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MolecularStateCharacterisationType ** SOAP_FMAC4 soap_get_PointerTons2__MolecularStateCharacterisationType(struct soap *soap, ns2__MolecularStateCharacterisationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MolecularStateCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__IDREF(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__IDREF))
		soap_serialize_xsd__IDREF(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__IDREF(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__IDREF);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__IDREF(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__IDREF(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__IDREF(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__IDREF, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__IDREF(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__IDREF);
	if (soap_out_PointerToxsd__IDREF(soap, tag?tag:"xsd:IDREF", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__IDREF(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ModesListType(struct soap *soap, enum ns2__ModesListType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ModesListType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ModesListType(struct soap *soap, const char *tag, int id, enum ns2__ModesListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ModesListType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ModesListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ModesListType ** SOAP_FMAC4 soap_in_PointerTons2__ModesListType(struct soap *soap, const char *tag, enum ns2__ModesListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ModesListType **)soap_malloc(soap, sizeof(enum ns2__ModesListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ModesListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ModesListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ModesListType, sizeof(enum ns2__ModesListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ModesListType(struct soap *soap, enum ns2__ModesListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ModesListType);
	if (soap_out_PointerTons2__ModesListType(soap, tag?tag:"ns2:ModesListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ModesListType ** SOAP_FMAC4 soap_get_PointerTons2__ModesListType(struct soap *soap, enum ns2__ModesListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ModesListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomicComponentType(struct soap *soap, ns2__AtomicComponentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomicComponentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomicComponentType(struct soap *soap, const char *tag, int id, ns2__AtomicComponentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomicComponentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomicComponentType ** SOAP_FMAC4 soap_in_PointerTons2__AtomicComponentType(struct soap *soap, const char *tag, ns2__AtomicComponentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomicComponentType **)soap_malloc(soap, sizeof(ns2__AtomicComponentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomicComponentType *)soap_instantiate_ns2__AtomicComponentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomicComponentType ** p = (ns2__AtomicComponentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomicComponentType, sizeof(ns2__AtomicComponentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomicComponentType(struct soap *soap, ns2__AtomicComponentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomicComponentType);
	if (soap_out_PointerTons2__AtomicComponentType(soap, tag?tag:"ns2:AtomicComponentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomicComponentType ** SOAP_FMAC4 soap_get_PointerTons2__AtomicComponentType(struct soap *soap, ns2__AtomicComponentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomicComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomicCompositionType(struct soap *soap, ns2__AtomicCompositionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomicCompositionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomicCompositionType(struct soap *soap, const char *tag, int id, ns2__AtomicCompositionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomicCompositionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomicCompositionType ** SOAP_FMAC4 soap_in_PointerTons2__AtomicCompositionType(struct soap *soap, const char *tag, ns2__AtomicCompositionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomicCompositionType **)soap_malloc(soap, sizeof(ns2__AtomicCompositionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomicCompositionType *)soap_instantiate_ns2__AtomicCompositionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomicCompositionType ** p = (ns2__AtomicCompositionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomicCompositionType, sizeof(ns2__AtomicCompositionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomicCompositionType(struct soap *soap, ns2__AtomicCompositionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomicCompositionType);
	if (soap_out_PointerTons2__AtomicCompositionType(soap, tag?tag:"ns2:AtomicCompositionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomicCompositionType ** SOAP_FMAC4 soap_get_PointerTons2__AtomicCompositionType(struct soap *soap, ns2__AtomicCompositionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomicCompositionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomicQuantumNumbersType(struct soap *soap, ns2__AtomicQuantumNumbersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomicQuantumNumbersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomicQuantumNumbersType(struct soap *soap, const char *tag, int id, ns2__AtomicQuantumNumbersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomicQuantumNumbersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomicQuantumNumbersType ** SOAP_FMAC4 soap_in_PointerTons2__AtomicQuantumNumbersType(struct soap *soap, const char *tag, ns2__AtomicQuantumNumbersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomicQuantumNumbersType **)soap_malloc(soap, sizeof(ns2__AtomicQuantumNumbersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomicQuantumNumbersType *)soap_instantiate_ns2__AtomicQuantumNumbersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomicQuantumNumbersType ** p = (ns2__AtomicQuantumNumbersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomicQuantumNumbersType, sizeof(ns2__AtomicQuantumNumbersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomicQuantumNumbersType(struct soap *soap, ns2__AtomicQuantumNumbersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomicQuantumNumbersType);
	if (soap_out_PointerTons2__AtomicQuantumNumbersType(soap, tag?tag:"ns2:AtomicQuantumNumbersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomicQuantumNumbersType ** SOAP_FMAC4 soap_get_PointerTons2__AtomicQuantumNumbersType(struct soap *soap, ns2__AtomicQuantumNumbersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomicQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomicNumericalDataType(struct soap *soap, ns2__AtomicNumericalDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomicNumericalDataType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomicNumericalDataType(struct soap *soap, const char *tag, int id, ns2__AtomicNumericalDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomicNumericalDataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomicNumericalDataType ** SOAP_FMAC4 soap_in_PointerTons2__AtomicNumericalDataType(struct soap *soap, const char *tag, ns2__AtomicNumericalDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomicNumericalDataType **)soap_malloc(soap, sizeof(ns2__AtomicNumericalDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomicNumericalDataType *)soap_instantiate_ns2__AtomicNumericalDataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomicNumericalDataType ** p = (ns2__AtomicNumericalDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomicNumericalDataType, sizeof(ns2__AtomicNumericalDataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomicNumericalDataType(struct soap *soap, ns2__AtomicNumericalDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomicNumericalDataType);
	if (soap_out_PointerTons2__AtomicNumericalDataType(soap, tag?tag:"ns2:AtomicNumericalDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomicNumericalDataType ** SOAP_FMAC4 soap_get_PointerTons2__AtomicNumericalDataType(struct soap *soap, ns2__AtomicNumericalDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomicNumericalDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomicStateType(struct soap *soap, ns2__AtomicStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomicStateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomicStateType(struct soap *soap, const char *tag, int id, ns2__AtomicStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomicStateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomicStateType ** SOAP_FMAC4 soap_in_PointerTons2__AtomicStateType(struct soap *soap, const char *tag, ns2__AtomicStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomicStateType **)soap_malloc(soap, sizeof(ns2__AtomicStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomicStateType *)soap_instantiate_ns2__AtomicStateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomicStateType ** p = (ns2__AtomicStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomicStateType, sizeof(ns2__AtomicStateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomicStateType(struct soap *soap, ns2__AtomicStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomicStateType);
	if (soap_out_PointerTons2__AtomicStateType(soap, tag?tag:"ns2:AtomicStateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomicStateType ** SOAP_FMAC4 soap_get_PointerTons2__AtomicStateType(struct soap *soap, ns2__AtomicStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomicStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IsotopeType(struct soap *soap, ns2__IsotopeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IsotopeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IsotopeType(struct soap *soap, const char *tag, int id, ns2__IsotopeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IsotopeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__IsotopeType ** SOAP_FMAC4 soap_in_PointerTons2__IsotopeType(struct soap *soap, const char *tag, ns2__IsotopeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__IsotopeType **)soap_malloc(soap, sizeof(ns2__IsotopeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__IsotopeType *)soap_instantiate_ns2__IsotopeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__IsotopeType ** p = (ns2__IsotopeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IsotopeType, sizeof(ns2__IsotopeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IsotopeType(struct soap *soap, ns2__IsotopeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IsotopeType);
	if (soap_out_PointerTons2__IsotopeType(soap, tag?tag:"ns2:IsotopeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__IsotopeType ** SOAP_FMAC4 soap_get_PointerTons2__IsotopeType(struct soap *soap, ns2__IsotopeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IsotopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomType(struct soap *soap, ns2__AtomType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomType(struct soap *soap, const char *tag, int id, ns2__AtomType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomType ** SOAP_FMAC4 soap_in_PointerTons2__AtomType(struct soap *soap, const char *tag, ns2__AtomType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomType **)soap_malloc(soap, sizeof(ns2__AtomType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomType *)soap_instantiate_ns2__AtomType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomType ** p = (ns2__AtomType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomType, sizeof(ns2__AtomType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomType(struct soap *soap, ns2__AtomType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomType);
	if (soap_out_PointerTons2__AtomType(soap, tag?tag:"ns2:AtomType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomType ** SOAP_FMAC4 soap_get_PointerTons2__AtomType(struct soap *soap, ns2__AtomType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParametersType(struct soap *soap, ns2__ParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParametersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParametersType(struct soap *soap, const char *tag, int id, ns2__ParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParametersType ** SOAP_FMAC4 soap_in_PointerTons2__ParametersType(struct soap *soap, const char *tag, ns2__ParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParametersType **)soap_malloc(soap, sizeof(ns2__ParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParametersType *)soap_instantiate_ns2__ParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParametersType ** p = (ns2__ParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParametersType, sizeof(ns2__ParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParametersType(struct soap *soap, ns2__ParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParametersType);
	if (soap_out_PointerTons2__ParametersType(soap, tag?tag:"ns2:ParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParametersType ** SOAP_FMAC4 soap_get_PointerTons2__ParametersType(struct soap *soap, ns2__ParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArgumentsType(struct soap *soap, ns2__ArgumentsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArgumentsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArgumentsType(struct soap *soap, const char *tag, int id, ns2__ArgumentsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArgumentsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArgumentsType ** SOAP_FMAC4 soap_in_PointerTons2__ArgumentsType(struct soap *soap, const char *tag, ns2__ArgumentsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArgumentsType **)soap_malloc(soap, sizeof(ns2__ArgumentsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArgumentsType *)soap_instantiate_ns2__ArgumentsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ArgumentsType ** p = (ns2__ArgumentsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArgumentsType, sizeof(ns2__ArgumentsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArgumentsType(struct soap *soap, ns2__ArgumentsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArgumentsType);
	if (soap_out_PointerTons2__ArgumentsType(soap, tag?tag:"ns2:ArgumentsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ArgumentsType ** SOAP_FMAC4 soap_get_PointerTons2__ArgumentsType(struct soap *soap, ns2__ArgumentsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArgumentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExpressionType(struct soap *soap, ns2__ExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ExpressionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExpressionType(struct soap *soap, const char *tag, int id, ns2__ExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExpressionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ExpressionType ** SOAP_FMAC4 soap_in_PointerTons2__ExpressionType(struct soap *soap, const char *tag, ns2__ExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ExpressionType **)soap_malloc(soap, sizeof(ns2__ExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ExpressionType *)soap_instantiate_ns2__ExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ExpressionType ** p = (ns2__ExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExpressionType, sizeof(ns2__ExpressionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExpressionType(struct soap *soap, ns2__ExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ExpressionType);
	if (soap_out_PointerTons2__ExpressionType(soap, tag?tag:"ns2:ExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ExpressionType ** SOAP_FMAC4 soap_get_PointerTons2__ExpressionType(struct soap *soap, ns2__ExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FitParametersType(struct soap *soap, ns2__FitParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FitParametersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FitParametersType(struct soap *soap, const char *tag, int id, ns2__FitParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FitParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FitParametersType ** SOAP_FMAC4 soap_in_PointerTons2__FitParametersType(struct soap *soap, const char *tag, ns2__FitParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FitParametersType **)soap_malloc(soap, sizeof(ns2__FitParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FitParametersType *)soap_instantiate_ns2__FitParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FitParametersType ** p = (ns2__FitParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FitParametersType, sizeof(ns2__FitParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FitParametersType(struct soap *soap, ns2__FitParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FitParametersType);
	if (soap_out_PointerTons2__FitParametersType(soap, tag?tag:"ns2:FitParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FitParametersType ** SOAP_FMAC4 soap_get_PointerTons2__FitParametersType(struct soap *soap, ns2__FitParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FitParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FitValidityLimitsType(struct soap *soap, ns2__FitValidityLimitsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FitValidityLimitsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FitValidityLimitsType(struct soap *soap, const char *tag, int id, ns2__FitValidityLimitsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FitValidityLimitsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FitValidityLimitsType ** SOAP_FMAC4 soap_in_PointerTons2__FitValidityLimitsType(struct soap *soap, const char *tag, ns2__FitValidityLimitsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FitValidityLimitsType **)soap_malloc(soap, sizeof(ns2__FitValidityLimitsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FitValidityLimitsType *)soap_instantiate_ns2__FitValidityLimitsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FitValidityLimitsType ** p = (ns2__FitValidityLimitsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FitValidityLimitsType, sizeof(ns2__FitValidityLimitsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FitValidityLimitsType(struct soap *soap, ns2__FitValidityLimitsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FitValidityLimitsType);
	if (soap_out_PointerTons2__FitValidityLimitsType(soap, tag?tag:"ns2:FitValidityLimitsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FitValidityLimitsType ** SOAP_FMAC4 soap_get_PointerTons2__FitValidityLimitsType(struct soap *soap, ns2__FitValidityLimitsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FitValidityLimitsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReferenceFrameType(struct soap *soap, enum ns2__ReferenceFrameType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ReferenceFrameType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReferenceFrameType(struct soap *soap, const char *tag, int id, enum ns2__ReferenceFrameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReferenceFrameType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ReferenceFrameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ReferenceFrameType ** SOAP_FMAC4 soap_in_PointerTons2__ReferenceFrameType(struct soap *soap, const char *tag, enum ns2__ReferenceFrameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ReferenceFrameType **)soap_malloc(soap, sizeof(enum ns2__ReferenceFrameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ReferenceFrameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ReferenceFrameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReferenceFrameType, sizeof(enum ns2__ReferenceFrameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReferenceFrameType(struct soap *soap, enum ns2__ReferenceFrameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReferenceFrameType);
	if (soap_out_PointerTons2__ReferenceFrameType(soap, tag?tag:"ns2:ReferenceFrameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReferenceFrameType ** SOAP_FMAC4 soap_get_PointerTons2__ReferenceFrameType(struct soap *soap, enum ns2__ReferenceFrameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReferenceFrameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataXYType(struct soap *soap, ns2__DataXYType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataXYType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataXYType(struct soap *soap, const char *tag, int id, ns2__DataXYType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataXYType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DataXYType ** SOAP_FMAC4 soap_in_PointerTons2__DataXYType(struct soap *soap, const char *tag, ns2__DataXYType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DataXYType **)soap_malloc(soap, sizeof(ns2__DataXYType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DataXYType *)soap_instantiate_ns2__DataXYType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DataXYType ** p = (ns2__DataXYType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataXYType, sizeof(ns2__DataXYType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataXYType(struct soap *soap, ns2__DataXYType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataXYType);
	if (soap_out_PointerTons2__DataXYType(soap, tag?tag:"ns2:DataXYType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DataXYType ** SOAP_FMAC4 soap_get_PointerTons2__DataXYType(struct soap *soap, ns2__DataXYType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataXYType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TabulatedDataType(struct soap *soap, ns2__TabulatedDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TabulatedDataType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TabulatedDataType(struct soap *soap, const char *tag, int id, ns2__TabulatedDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TabulatedDataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TabulatedDataType ** SOAP_FMAC4 soap_in_PointerTons2__TabulatedDataType(struct soap *soap, const char *tag, ns2__TabulatedDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TabulatedDataType **)soap_malloc(soap, sizeof(ns2__TabulatedDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TabulatedDataType *)soap_instantiate_ns2__TabulatedDataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__TabulatedDataType ** p = (ns2__TabulatedDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TabulatedDataType, sizeof(ns2__TabulatedDataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TabulatedDataType(struct soap *soap, ns2__TabulatedDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TabulatedDataType);
	if (soap_out_PointerTons2__TabulatedDataType(soap, tag?tag:"ns2:TabulatedDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TabulatedDataType ** SOAP_FMAC4 soap_get_PointerTons2__TabulatedDataType(struct soap *soap, ns2__TabulatedDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TabulatedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FitDataType(struct soap *soap, ns2__FitDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FitDataType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FitDataType(struct soap *soap, const char *tag, int id, ns2__FitDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FitDataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FitDataType ** SOAP_FMAC4 soap_in_PointerTons2__FitDataType(struct soap *soap, const char *tag, ns2__FitDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FitDataType **)soap_malloc(soap, sizeof(ns2__FitDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FitDataType *)soap_instantiate_ns2__FitDataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FitDataType ** p = (ns2__FitDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FitDataType, sizeof(ns2__FitDataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FitDataType(struct soap *soap, ns2__FitDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FitDataType);
	if (soap_out_PointerTons2__FitDataType(soap, tag?tag:"ns2:FitDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FitDataType ** SOAP_FMAC4 soap_get_PointerTons2__FitDataType(struct soap *soap, ns2__FitDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FitDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueType(struct soap *soap, ns2__ValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueType(struct soap *soap, const char *tag, int id, ns2__ValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueType ** SOAP_FMAC4 soap_in_PointerTons2__ValueType(struct soap *soap, const char *tag, ns2__ValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueType **)soap_malloc(soap, sizeof(ns2__ValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueType *)soap_instantiate_ns2__ValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueType ** p = (ns2__ValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueType, sizeof(ns2__ValueType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueType(struct soap *soap, ns2__ValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueType);
	if (soap_out_PointerTons2__ValueType(soap, tag?tag:"ns2:ValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueType ** SOAP_FMAC4 soap_get_PointerTons2__ValueType(struct soap *soap, ns2__ValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParticlesType(struct soap *soap, ns2__ParticlesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParticlesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParticlesType(struct soap *soap, const char *tag, int id, ns2__ParticlesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParticlesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParticlesType ** SOAP_FMAC4 soap_in_PointerTons2__ParticlesType(struct soap *soap, const char *tag, ns2__ParticlesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParticlesType **)soap_malloc(soap, sizeof(ns2__ParticlesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParticlesType *)soap_instantiate_ns2__ParticlesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParticlesType ** p = (ns2__ParticlesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParticlesType, sizeof(ns2__ParticlesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParticlesType(struct soap *soap, ns2__ParticlesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParticlesType);
	if (soap_out_PointerTons2__ParticlesType(soap, tag?tag:"ns2:ParticlesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParticlesType ** SOAP_FMAC4 soap_get_PointerTons2__ParticlesType(struct soap *soap, ns2__ParticlesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParticlesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SolidsType(struct soap *soap, ns2__SolidsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SolidsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SolidsType(struct soap *soap, const char *tag, int id, ns2__SolidsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SolidsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SolidsType ** SOAP_FMAC4 soap_in_PointerTons2__SolidsType(struct soap *soap, const char *tag, ns2__SolidsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SolidsType **)soap_malloc(soap, sizeof(ns2__SolidsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SolidsType *)soap_instantiate_ns2__SolidsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SolidsType ** p = (ns2__SolidsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SolidsType, sizeof(ns2__SolidsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SolidsType(struct soap *soap, ns2__SolidsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SolidsType);
	if (soap_out_PointerTons2__SolidsType(soap, tag?tag:"ns2:SolidsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SolidsType ** SOAP_FMAC4 soap_get_PointerTons2__SolidsType(struct soap *soap, ns2__SolidsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SolidsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MoleculesType(struct soap *soap, ns2__MoleculesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MoleculesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MoleculesType(struct soap *soap, const char *tag, int id, ns2__MoleculesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MoleculesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MoleculesType ** SOAP_FMAC4 soap_in_PointerTons2__MoleculesType(struct soap *soap, const char *tag, ns2__MoleculesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MoleculesType **)soap_malloc(soap, sizeof(ns2__MoleculesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MoleculesType *)soap_instantiate_ns2__MoleculesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MoleculesType ** p = (ns2__MoleculesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MoleculesType, sizeof(ns2__MoleculesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MoleculesType(struct soap *soap, ns2__MoleculesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MoleculesType);
	if (soap_out_PointerTons2__MoleculesType(soap, tag?tag:"ns2:MoleculesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MoleculesType ** SOAP_FMAC4 soap_get_PointerTons2__MoleculesType(struct soap *soap, ns2__MoleculesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MoleculesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomsType(struct soap *soap, ns2__AtomsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomsType(struct soap *soap, const char *tag, int id, ns2__AtomsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomsType ** SOAP_FMAC4 soap_in_PointerTons2__AtomsType(struct soap *soap, const char *tag, ns2__AtomsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomsType **)soap_malloc(soap, sizeof(ns2__AtomsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomsType *)soap_instantiate_ns2__AtomsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomsType ** p = (ns2__AtomsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomsType, sizeof(ns2__AtomsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomsType(struct soap *soap, ns2__AtomsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomsType);
	if (soap_out_PointerTons2__AtomsType(soap, tag?tag:"ns2:AtomsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomsType ** SOAP_FMAC4 soap_get_PointerTons2__AtomsType(struct soap *soap, ns2__AtomsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CollisionsType(struct soap *soap, ns2__CollisionsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CollisionsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CollisionsType(struct soap *soap, const char *tag, int id, ns2__CollisionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CollisionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CollisionsType ** SOAP_FMAC4 soap_in_PointerTons2__CollisionsType(struct soap *soap, const char *tag, ns2__CollisionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CollisionsType **)soap_malloc(soap, sizeof(ns2__CollisionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CollisionsType *)soap_instantiate_ns2__CollisionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CollisionsType ** p = (ns2__CollisionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CollisionsType, sizeof(ns2__CollisionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CollisionsType(struct soap *soap, ns2__CollisionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CollisionsType);
	if (soap_out_PointerTons2__CollisionsType(soap, tag?tag:"ns2:CollisionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CollisionsType ** SOAP_FMAC4 soap_get_PointerTons2__CollisionsType(struct soap *soap, ns2__CollisionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CollisionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonRadiativeType(struct soap *soap, ns2__NonRadiativeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonRadiativeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonRadiativeType(struct soap *soap, const char *tag, int id, ns2__NonRadiativeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonRadiativeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonRadiativeType ** SOAP_FMAC4 soap_in_PointerTons2__NonRadiativeType(struct soap *soap, const char *tag, ns2__NonRadiativeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonRadiativeType **)soap_malloc(soap, sizeof(ns2__NonRadiativeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonRadiativeType *)soap_instantiate_ns2__NonRadiativeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonRadiativeType ** p = (ns2__NonRadiativeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonRadiativeType, sizeof(ns2__NonRadiativeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonRadiativeType(struct soap *soap, ns2__NonRadiativeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonRadiativeType);
	if (soap_out_PointerTons2__NonRadiativeType(soap, tag?tag:"ns2:NonRadiativeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonRadiativeType ** SOAP_FMAC4 soap_get_PointerTons2__NonRadiativeType(struct soap *soap, ns2__NonRadiativeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonRadiativeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RadiativeType(struct soap *soap, ns2__RadiativeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RadiativeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RadiativeType(struct soap *soap, const char *tag, int id, ns2__RadiativeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RadiativeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RadiativeType ** SOAP_FMAC4 soap_in_PointerTons2__RadiativeType(struct soap *soap, const char *tag, ns2__RadiativeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RadiativeType **)soap_malloc(soap, sizeof(ns2__RadiativeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RadiativeType *)soap_instantiate_ns2__RadiativeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RadiativeType ** p = (ns2__RadiativeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RadiativeType, sizeof(ns2__RadiativeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RadiativeType(struct soap *soap, ns2__RadiativeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RadiativeType);
	if (soap_out_PointerTons2__RadiativeType(soap, tag?tag:"ns2:RadiativeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RadiativeType ** SOAP_FMAC4 soap_get_PointerTons2__RadiativeType(struct soap *soap, ns2__RadiativeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RadiativeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FunctionsType(struct soap *soap, ns2__FunctionsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FunctionsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FunctionsType(struct soap *soap, const char *tag, int id, ns2__FunctionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FunctionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FunctionsType ** SOAP_FMAC4 soap_in_PointerTons2__FunctionsType(struct soap *soap, const char *tag, ns2__FunctionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FunctionsType **)soap_malloc(soap, sizeof(ns2__FunctionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FunctionsType *)soap_instantiate_ns2__FunctionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FunctionsType ** p = (ns2__FunctionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FunctionsType, sizeof(ns2__FunctionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FunctionsType(struct soap *soap, ns2__FunctionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FunctionsType);
	if (soap_out_PointerTons2__FunctionsType(soap, tag?tag:"ns2:FunctionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FunctionsType ** SOAP_FMAC4 soap_get_PointerTons2__FunctionsType(struct soap *soap, ns2__FunctionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FunctionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MethodsType(struct soap *soap, ns2__MethodsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MethodsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MethodsType(struct soap *soap, const char *tag, int id, ns2__MethodsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MethodsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MethodsType ** SOAP_FMAC4 soap_in_PointerTons2__MethodsType(struct soap *soap, const char *tag, ns2__MethodsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MethodsType **)soap_malloc(soap, sizeof(ns2__MethodsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MethodsType *)soap_instantiate_ns2__MethodsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MethodsType ** p = (ns2__MethodsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MethodsType, sizeof(ns2__MethodsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MethodsType(struct soap *soap, ns2__MethodsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MethodsType);
	if (soap_out_PointerTons2__MethodsType(soap, tag?tag:"ns2:MethodsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MethodsType ** SOAP_FMAC4 soap_get_PointerTons2__MethodsType(struct soap *soap, ns2__MethodsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MethodsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SourcesType(struct soap *soap, ns2__SourcesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SourcesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SourcesType(struct soap *soap, const char *tag, int id, ns2__SourcesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SourcesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SourcesType ** SOAP_FMAC4 soap_in_PointerTons2__SourcesType(struct soap *soap, const char *tag, ns2__SourcesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SourcesType **)soap_malloc(soap, sizeof(ns2__SourcesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SourcesType *)soap_instantiate_ns2__SourcesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SourcesType ** p = (ns2__SourcesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SourcesType, sizeof(ns2__SourcesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SourcesType(struct soap *soap, ns2__SourcesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SourcesType);
	if (soap_out_PointerTons2__SourcesType(soap, tag?tag:"ns2:SourcesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SourcesType ** SOAP_FMAC4 soap_get_PointerTons2__SourcesType(struct soap *soap, ns2__SourcesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SourcesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ProcessesType(struct soap *soap, ns2__ProcessesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ProcessesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ProcessesType(struct soap *soap, const char *tag, int id, ns2__ProcessesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ProcessesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ProcessesType ** SOAP_FMAC4 soap_in_PointerTons2__ProcessesType(struct soap *soap, const char *tag, ns2__ProcessesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ProcessesType **)soap_malloc(soap, sizeof(ns2__ProcessesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ProcessesType *)soap_instantiate_ns2__ProcessesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ProcessesType ** p = (ns2__ProcessesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ProcessesType, sizeof(ns2__ProcessesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ProcessesType(struct soap *soap, ns2__ProcessesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ProcessesType);
	if (soap_out_PointerTons2__ProcessesType(soap, tag?tag:"ns2:ProcessesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ProcessesType ** SOAP_FMAC4 soap_get_PointerTons2__ProcessesType(struct soap *soap, ns2__ProcessesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ProcessesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StatesType(struct soap *soap, ns2__StatesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StatesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StatesType(struct soap *soap, const char *tag, int id, ns2__StatesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StatesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__StatesType ** SOAP_FMAC4 soap_in_PointerTons2__StatesType(struct soap *soap, const char *tag, ns2__StatesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__StatesType **)soap_malloc(soap, sizeof(ns2__StatesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__StatesType *)soap_instantiate_ns2__StatesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__StatesType ** p = (ns2__StatesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StatesType, sizeof(ns2__StatesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StatesType(struct soap *soap, ns2__StatesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__StatesType);
	if (soap_out_PointerTons2__StatesType(soap, tag?tag:"ns2:StatesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__StatesType ** SOAP_FMAC4 soap_get_PointerTons2__StatesType(struct soap *soap, ns2__StatesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StatesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IAEACodeType(struct soap *soap, enum ns2__IAEACodeType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__IAEACodeType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IAEACodeType(struct soap *soap, const char *tag, int id, enum ns2__IAEACodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IAEACodeType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IAEACodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__IAEACodeType ** SOAP_FMAC4 soap_in_PointerTons2__IAEACodeType(struct soap *soap, const char *tag, enum ns2__IAEACodeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__IAEACodeType **)soap_malloc(soap, sizeof(enum ns2__IAEACodeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IAEACodeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__IAEACodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IAEACodeType, sizeof(enum ns2__IAEACodeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IAEACodeType(struct soap *soap, enum ns2__IAEACodeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IAEACodeType);
	if (soap_out_PointerTons2__IAEACodeType(soap, tag?tag:"ns2:IAEACodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IAEACodeType ** SOAP_FMAC4 soap_get_PointerTons2__IAEACodeType(struct soap *soap, enum ns2__IAEACodeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IAEACodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MaterialCompositionType(struct soap *soap, ns2__MaterialCompositionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MaterialCompositionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MaterialCompositionType(struct soap *soap, const char *tag, int id, ns2__MaterialCompositionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MaterialCompositionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MaterialCompositionType ** SOAP_FMAC4 soap_in_PointerTons2__MaterialCompositionType(struct soap *soap, const char *tag, ns2__MaterialCompositionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MaterialCompositionType **)soap_malloc(soap, sizeof(ns2__MaterialCompositionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MaterialCompositionType *)soap_instantiate_ns2__MaterialCompositionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MaterialCompositionType ** p = (ns2__MaterialCompositionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MaterialCompositionType, sizeof(ns2__MaterialCompositionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MaterialCompositionType(struct soap *soap, ns2__MaterialCompositionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MaterialCompositionType);
	if (soap_out_PointerTons2__MaterialCompositionType(soap, tag?tag:"ns2:MaterialCompositionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MaterialCompositionType ** SOAP_FMAC4 soap_get_PointerTons2__MaterialCompositionType(struct soap *soap, ns2__MaterialCompositionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MaterialCompositionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__decimal);
	if (soap_out_PointerToxsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ChemicalElementType(struct soap *soap, ns2__ChemicalElementType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ChemicalElementType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ChemicalElementType(struct soap *soap, const char *tag, int id, ns2__ChemicalElementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ChemicalElementType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ChemicalElementType ** SOAP_FMAC4 soap_in_PointerTons2__ChemicalElementType(struct soap *soap, const char *tag, ns2__ChemicalElementType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ChemicalElementType **)soap_malloc(soap, sizeof(ns2__ChemicalElementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ChemicalElementType *)soap_instantiate_ns2__ChemicalElementType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ChemicalElementType ** p = (ns2__ChemicalElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ChemicalElementType, sizeof(ns2__ChemicalElementType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ChemicalElementType(struct soap *soap, ns2__ChemicalElementType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ChemicalElementType);
	if (soap_out_PointerTons2__ChemicalElementType(soap, tag?tag:"ns2:ChemicalElementType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ChemicalElementType ** SOAP_FMAC4 soap_get_PointerTons2__ChemicalElementType(struct soap *soap, ns2__ChemicalElementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ChemicalElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParticleNameType(struct soap *soap, enum ns2__ParticleNameType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ParticleNameType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParticleNameType(struct soap *soap, const char *tag, int id, enum ns2__ParticleNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParticleNameType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ParticleNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ParticleNameType ** SOAP_FMAC4 soap_in_PointerTons2__ParticleNameType(struct soap *soap, const char *tag, enum ns2__ParticleNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ParticleNameType **)soap_malloc(soap, sizeof(enum ns2__ParticleNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ParticleNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ParticleNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParticleNameType, sizeof(enum ns2__ParticleNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParticleNameType(struct soap *soap, enum ns2__ParticleNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParticleNameType);
	if (soap_out_PointerTons2__ParticleNameType(soap, tag?tag:"ns2:ParticleNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ParticleNameType ** SOAP_FMAC4 soap_get_PointerTons2__ParticleNameType(struct soap *soap, enum ns2__ParticleNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParticleNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParticlePropertiesType(struct soap *soap, ns2__ParticlePropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParticlePropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParticlePropertiesType(struct soap *soap, const char *tag, int id, ns2__ParticlePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParticlePropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParticlePropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__ParticlePropertiesType(struct soap *soap, const char *tag, ns2__ParticlePropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParticlePropertiesType **)soap_malloc(soap, sizeof(ns2__ParticlePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParticlePropertiesType *)soap_instantiate_ns2__ParticlePropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParticlePropertiesType ** p = (ns2__ParticlePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParticlePropertiesType, sizeof(ns2__ParticlePropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParticlePropertiesType(struct soap *soap, ns2__ParticlePropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParticlePropertiesType);
	if (soap_out_PointerTons2__ParticlePropertiesType(soap, tag?tag:"ns2:ParticlePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParticlePropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__ParticlePropertiesType(struct soap *soap, ns2__ParticlePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParticlePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParticleType(struct soap *soap, ns2__ParticleType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParticleType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParticleType(struct soap *soap, const char *tag, int id, ns2__ParticleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParticleType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParticleType ** SOAP_FMAC4 soap_in_PointerTons2__ParticleType(struct soap *soap, const char *tag, ns2__ParticleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParticleType **)soap_malloc(soap, sizeof(ns2__ParticleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParticleType *)soap_instantiate_ns2__ParticleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParticleType ** p = (ns2__ParticleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParticleType, sizeof(ns2__ParticleType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParticleType(struct soap *soap, ns2__ParticleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParticleType);
	if (soap_out_PointerTons2__ParticleType(soap, tag?tag:"ns2:ParticleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParticleType ** SOAP_FMAC4 soap_get_PointerTons2__ParticleType(struct soap *soap, ns2__ParticleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParticleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, __ns2__union_HyperfineQuantumNumbersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, const char *tag, int id, __ns2__union_HyperfineQuantumNumbersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns2__union_HyperfineQuantumNumbersType ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, const char *tag, __ns2__union_HyperfineQuantumNumbersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_HyperfineQuantumNumbersType **)soap_malloc(soap, sizeof(__ns2__union_HyperfineQuantumNumbersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_HyperfineQuantumNumbersType *)soap_instantiate___ns2__union_HyperfineQuantumNumbersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns2__union_HyperfineQuantumNumbersType ** p = (__ns2__union_HyperfineQuantumNumbersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_HyperfineQuantumNumbersType, sizeof(__ns2__union_HyperfineQuantumNumbersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, __ns2__union_HyperfineQuantumNumbersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_HyperfineQuantumNumbersType);
	if (soap_out_PointerTo__ns2__union_HyperfineQuantumNumbersType(soap, tag?tag:"-ns2:union-HyperfineQuantumNumbersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_HyperfineQuantumNumbersType ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_HyperfineQuantumNumbersType(struct soap *soap, __ns2__union_HyperfineQuantumNumbersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_HyperfineQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__C2SymmetriesType(struct soap *soap, ns2__C2SymmetriesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__C2SymmetriesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__C2SymmetriesType(struct soap *soap, const char *tag, int id, ns2__C2SymmetriesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__C2SymmetriesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__C2SymmetriesType ** SOAP_FMAC4 soap_in_PointerTons2__C2SymmetriesType(struct soap *soap, const char *tag, ns2__C2SymmetriesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__C2SymmetriesType **)soap_malloc(soap, sizeof(ns2__C2SymmetriesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__C2SymmetriesType *)soap_instantiate_ns2__C2SymmetriesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__C2SymmetriesType ** p = (ns2__C2SymmetriesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__C2SymmetriesType, sizeof(ns2__C2SymmetriesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__C2SymmetriesType(struct soap *soap, ns2__C2SymmetriesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__C2SymmetriesType);
	if (soap_out_PointerTons2__C2SymmetriesType(soap, tag?tag:"ns2:C2SymmetriesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__C2SymmetriesType ** SOAP_FMAC4 soap_get_PointerTons2__C2SymmetriesType(struct soap *soap, ns2__C2SymmetriesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__C2SymmetriesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RoVibronicSplittingType(struct soap *soap, ns2__RoVibronicSplittingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RoVibronicSplittingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RoVibronicSplittingType(struct soap *soap, const char *tag, int id, ns2__RoVibronicSplittingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RoVibronicSplittingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RoVibronicSplittingType ** SOAP_FMAC4 soap_in_PointerTons2__RoVibronicSplittingType(struct soap *soap, const char *tag, ns2__RoVibronicSplittingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RoVibronicSplittingType **)soap_malloc(soap, sizeof(ns2__RoVibronicSplittingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RoVibronicSplittingType *)soap_instantiate_ns2__RoVibronicSplittingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RoVibronicSplittingType ** p = (ns2__RoVibronicSplittingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RoVibronicSplittingType, sizeof(ns2__RoVibronicSplittingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RoVibronicSplittingType(struct soap *soap, ns2__RoVibronicSplittingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RoVibronicSplittingType);
	if (soap_out_PointerTons2__RoVibronicSplittingType(soap, tag?tag:"ns2:RoVibronicSplittingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RoVibronicSplittingType ** SOAP_FMAC4 soap_get_PointerTons2__RoVibronicSplittingType(struct soap *soap, ns2__RoVibronicSplittingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RoVibronicSplittingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MolecularProjectionType(struct soap *soap, ns2__MolecularProjectionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MolecularProjectionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MolecularProjectionType(struct soap *soap, const char *tag, int id, ns2__MolecularProjectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MolecularProjectionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MolecularProjectionType ** SOAP_FMAC4 soap_in_PointerTons2__MolecularProjectionType(struct soap *soap, const char *tag, ns2__MolecularProjectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MolecularProjectionType **)soap_malloc(soap, sizeof(ns2__MolecularProjectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MolecularProjectionType *)soap_instantiate_ns2__MolecularProjectionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MolecularProjectionType ** p = (ns2__MolecularProjectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MolecularProjectionType, sizeof(ns2__MolecularProjectionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MolecularProjectionType(struct soap *soap, ns2__MolecularProjectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MolecularProjectionType);
	if (soap_out_PointerTons2__MolecularProjectionType(soap, tag?tag:"ns2:MolecularProjectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MolecularProjectionType ** SOAP_FMAC4 soap_get_PointerTons2__MolecularProjectionType(struct soap *soap, ns2__MolecularProjectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MolecularProjectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HyperfineCouplingBType(struct soap *soap, ns2__HyperfineCouplingBType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HyperfineCouplingBType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HyperfineCouplingBType(struct soap *soap, const char *tag, int id, ns2__HyperfineCouplingBType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HyperfineCouplingBType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HyperfineCouplingBType ** SOAP_FMAC4 soap_in_PointerTons2__HyperfineCouplingBType(struct soap *soap, const char *tag, ns2__HyperfineCouplingBType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HyperfineCouplingBType **)soap_malloc(soap, sizeof(ns2__HyperfineCouplingBType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HyperfineCouplingBType *)soap_instantiate_ns2__HyperfineCouplingBType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HyperfineCouplingBType ** p = (ns2__HyperfineCouplingBType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HyperfineCouplingBType, sizeof(ns2__HyperfineCouplingBType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HyperfineCouplingBType(struct soap *soap, ns2__HyperfineCouplingBType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HyperfineCouplingBType);
	if (soap_out_PointerTons2__HyperfineCouplingBType(soap, tag?tag:"ns2:HyperfineCouplingBType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HyperfineCouplingBType ** SOAP_FMAC4 soap_get_PointerTons2__HyperfineCouplingBType(struct soap *soap, ns2__HyperfineCouplingBType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HyperfineCouplingBType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HundCaseBType(struct soap *soap, ns2__HundCaseBType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HundCaseBType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HundCaseBType(struct soap *soap, const char *tag, int id, ns2__HundCaseBType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HundCaseBType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HundCaseBType ** SOAP_FMAC4 soap_in_PointerTons2__HundCaseBType(struct soap *soap, const char *tag, ns2__HundCaseBType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HundCaseBType **)soap_malloc(soap, sizeof(ns2__HundCaseBType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HundCaseBType *)soap_instantiate_ns2__HundCaseBType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HundCaseBType ** p = (ns2__HundCaseBType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HundCaseBType, sizeof(ns2__HundCaseBType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HundCaseBType(struct soap *soap, ns2__HundCaseBType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HundCaseBType);
	if (soap_out_PointerTons2__HundCaseBType(soap, tag?tag:"ns2:HundCaseBType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HundCaseBType ** SOAP_FMAC4 soap_get_PointerTons2__HundCaseBType(struct soap *soap, ns2__HundCaseBType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HundCaseBType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HyperfineCaseABetaType(struct soap *soap, ns2__HyperfineCaseABetaType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HyperfineCaseABetaType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HyperfineCaseABetaType(struct soap *soap, const char *tag, int id, ns2__HyperfineCaseABetaType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HyperfineCaseABetaType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HyperfineCaseABetaType ** SOAP_FMAC4 soap_in_PointerTons2__HyperfineCaseABetaType(struct soap *soap, const char *tag, ns2__HyperfineCaseABetaType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HyperfineCaseABetaType **)soap_malloc(soap, sizeof(ns2__HyperfineCaseABetaType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HyperfineCaseABetaType *)soap_instantiate_ns2__HyperfineCaseABetaType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HyperfineCaseABetaType ** p = (ns2__HyperfineCaseABetaType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HyperfineCaseABetaType, sizeof(ns2__HyperfineCaseABetaType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HyperfineCaseABetaType(struct soap *soap, ns2__HyperfineCaseABetaType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HyperfineCaseABetaType);
	if (soap_out_PointerTons2__HyperfineCaseABetaType(soap, tag?tag:"ns2:HyperfineCaseABetaType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HyperfineCaseABetaType ** SOAP_FMAC4 soap_get_PointerTons2__HyperfineCaseABetaType(struct soap *soap, ns2__HyperfineCaseABetaType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HyperfineCaseABetaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HyperfineCaseAAlphaType(struct soap *soap, ns2__HyperfineCaseAAlphaType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HyperfineCaseAAlphaType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HyperfineCaseAAlphaType(struct soap *soap, const char *tag, int id, ns2__HyperfineCaseAAlphaType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HyperfineCaseAAlphaType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HyperfineCaseAAlphaType ** SOAP_FMAC4 soap_in_PointerTons2__HyperfineCaseAAlphaType(struct soap *soap, const char *tag, ns2__HyperfineCaseAAlphaType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HyperfineCaseAAlphaType **)soap_malloc(soap, sizeof(ns2__HyperfineCaseAAlphaType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HyperfineCaseAAlphaType *)soap_instantiate_ns2__HyperfineCaseAAlphaType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HyperfineCaseAAlphaType ** p = (ns2__HyperfineCaseAAlphaType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HyperfineCaseAAlphaType, sizeof(ns2__HyperfineCaseAAlphaType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HyperfineCaseAAlphaType(struct soap *soap, ns2__HyperfineCaseAAlphaType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HyperfineCaseAAlphaType);
	if (soap_out_PointerTons2__HyperfineCaseAAlphaType(soap, tag?tag:"ns2:HyperfineCaseAAlphaType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HyperfineCaseAAlphaType ** SOAP_FMAC4 soap_get_PointerTons2__HyperfineCaseAAlphaType(struct soap *soap, ns2__HyperfineCaseAAlphaType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HyperfineCaseAAlphaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HundCaseAType(struct soap *soap, ns2__HundCaseAType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HundCaseAType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HundCaseAType(struct soap *soap, const char *tag, int id, ns2__HundCaseAType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HundCaseAType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HundCaseAType ** SOAP_FMAC4 soap_in_PointerTons2__HundCaseAType(struct soap *soap, const char *tag, ns2__HundCaseAType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HundCaseAType **)soap_malloc(soap, sizeof(ns2__HundCaseAType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HundCaseAType *)soap_instantiate_ns2__HundCaseAType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HundCaseAType ** p = (ns2__HundCaseAType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HundCaseAType, sizeof(ns2__HundCaseAType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HundCaseAType(struct soap *soap, ns2__HundCaseAType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HundCaseAType);
	if (soap_out_PointerTons2__HundCaseAType(soap, tag?tag:"ns2:HundCaseAType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HundCaseAType ** SOAP_FMAC4 soap_get_PointerTons2__HundCaseAType(struct soap *soap, ns2__HundCaseAType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HundCaseAType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EfSymmetryType(struct soap *soap, enum ns2__EfSymmetryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__EfSymmetryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EfSymmetryType(struct soap *soap, const char *tag, int id, enum ns2__EfSymmetryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EfSymmetryType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EfSymmetryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__EfSymmetryType ** SOAP_FMAC4 soap_in_PointerTons2__EfSymmetryType(struct soap *soap, const char *tag, enum ns2__EfSymmetryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__EfSymmetryType **)soap_malloc(soap, sizeof(enum ns2__EfSymmetryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EfSymmetryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__EfSymmetryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EfSymmetryType, sizeof(enum ns2__EfSymmetryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EfSymmetryType(struct soap *soap, enum ns2__EfSymmetryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EfSymmetryType);
	if (soap_out_PointerTons2__EfSymmetryType(soap, tag?tag:"ns2:EfSymmetryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EfSymmetryType ** SOAP_FMAC4 soap_get_PointerTons2__EfSymmetryType(struct soap *soap, enum ns2__EfSymmetryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EfSymmetryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HyperfineQuantumNumbersType(struct soap *soap, ns2__HyperfineQuantumNumbersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HyperfineQuantumNumbersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HyperfineQuantumNumbersType(struct soap *soap, const char *tag, int id, ns2__HyperfineQuantumNumbersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HyperfineQuantumNumbersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HyperfineQuantumNumbersType ** SOAP_FMAC4 soap_in_PointerTons2__HyperfineQuantumNumbersType(struct soap *soap, const char *tag, ns2__HyperfineQuantumNumbersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HyperfineQuantumNumbersType **)soap_malloc(soap, sizeof(ns2__HyperfineQuantumNumbersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HyperfineQuantumNumbersType *)soap_instantiate_ns2__HyperfineQuantumNumbersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HyperfineQuantumNumbersType ** p = (ns2__HyperfineQuantumNumbersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HyperfineQuantumNumbersType, sizeof(ns2__HyperfineQuantumNumbersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HyperfineQuantumNumbersType(struct soap *soap, ns2__HyperfineQuantumNumbersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HyperfineQuantumNumbersType);
	if (soap_out_PointerTons2__HyperfineQuantumNumbersType(soap, tag?tag:"ns2:HyperfineQuantumNumbersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HyperfineQuantumNumbersType ** SOAP_FMAC4 soap_get_PointerTons2__HyperfineQuantumNumbersType(struct soap *soap, ns2__HyperfineQuantumNumbersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HyperfineQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, ns2__ComplexMolecularQuantumNumberType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, const char *tag, int id, ns2__ComplexMolecularQuantumNumberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ComplexMolecularQuantumNumberType ** SOAP_FMAC4 soap_in_PointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, const char *tag, ns2__ComplexMolecularQuantumNumberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ComplexMolecularQuantumNumberType **)soap_malloc(soap, sizeof(ns2__ComplexMolecularQuantumNumberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ComplexMolecularQuantumNumberType *)soap_instantiate_ns2__ComplexMolecularQuantumNumberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ComplexMolecularQuantumNumberType ** p = (ns2__ComplexMolecularQuantumNumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType, sizeof(ns2__ComplexMolecularQuantumNumberType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, ns2__ComplexMolecularQuantumNumberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ComplexMolecularQuantumNumberType);
	if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, tag?tag:"ns2:ComplexMolecularQuantumNumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ComplexMolecularQuantumNumberType ** SOAP_FMAC4 soap_get_PointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, ns2__ComplexMolecularQuantumNumberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VibrationalComponentType(struct soap *soap, ns2__VibrationalComponentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VibrationalComponentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VibrationalComponentType(struct soap *soap, const char *tag, int id, ns2__VibrationalComponentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VibrationalComponentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VibrationalComponentType ** SOAP_FMAC4 soap_in_PointerTons2__VibrationalComponentType(struct soap *soap, const char *tag, ns2__VibrationalComponentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VibrationalComponentType **)soap_malloc(soap, sizeof(ns2__VibrationalComponentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VibrationalComponentType *)soap_instantiate_ns2__VibrationalComponentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VibrationalComponentType ** p = (ns2__VibrationalComponentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VibrationalComponentType, sizeof(ns2__VibrationalComponentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VibrationalComponentType(struct soap *soap, ns2__VibrationalComponentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VibrationalComponentType);
	if (soap_out_PointerTons2__VibrationalComponentType(soap, tag?tag:"ns2:VibrationalComponentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VibrationalComponentType ** SOAP_FMAC4 soap_get_PointerTons2__VibrationalComponentType(struct soap *soap, ns2__VibrationalComponentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VibrationalComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RotationalHomeType(struct soap *soap, ns2__RotationalHomeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RotationalHomeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RotationalHomeType(struct soap *soap, const char *tag, int id, ns2__RotationalHomeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RotationalHomeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RotationalHomeType ** SOAP_FMAC4 soap_in_PointerTons2__RotationalHomeType(struct soap *soap, const char *tag, ns2__RotationalHomeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RotationalHomeType **)soap_malloc(soap, sizeof(ns2__RotationalHomeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RotationalHomeType *)soap_instantiate_ns2__RotationalHomeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RotationalHomeType ** p = (ns2__RotationalHomeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RotationalHomeType, sizeof(ns2__RotationalHomeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RotationalHomeType(struct soap *soap, ns2__RotationalHomeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RotationalHomeType);
	if (soap_out_PointerTons2__RotationalHomeType(soap, tag?tag:"ns2:RotationalHomeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RotationalHomeType ** SOAP_FMAC4 soap_get_PointerTons2__RotationalHomeType(struct soap *soap, ns2__RotationalHomeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RotationalHomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VibrationalQuantumNumbersType(struct soap *soap, ns2__VibrationalQuantumNumbersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VibrationalQuantumNumbersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VibrationalQuantumNumbersType(struct soap *soap, const char *tag, int id, ns2__VibrationalQuantumNumbersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VibrationalQuantumNumbersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VibrationalQuantumNumbersType ** SOAP_FMAC4 soap_in_PointerTons2__VibrationalQuantumNumbersType(struct soap *soap, const char *tag, ns2__VibrationalQuantumNumbersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VibrationalQuantumNumbersType **)soap_malloc(soap, sizeof(ns2__VibrationalQuantumNumbersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VibrationalQuantumNumbersType *)soap_instantiate_ns2__VibrationalQuantumNumbersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VibrationalQuantumNumbersType ** p = (ns2__VibrationalQuantumNumbersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VibrationalQuantumNumbersType, sizeof(ns2__VibrationalQuantumNumbersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VibrationalQuantumNumbersType(struct soap *soap, ns2__VibrationalQuantumNumbersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VibrationalQuantumNumbersType);
	if (soap_out_PointerTons2__VibrationalQuantumNumbersType(soap, tag?tag:"ns2:VibrationalQuantumNumbersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VibrationalQuantumNumbersType ** SOAP_FMAC4 soap_get_PointerTons2__VibrationalQuantumNumbersType(struct soap *soap, ns2__VibrationalQuantumNumbersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VibrationalQuantumNumbersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VibrationalCharacterisationType(struct soap *soap, ns2__VibrationalCharacterisationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VibrationalCharacterisationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VibrationalCharacterisationType(struct soap *soap, const char *tag, int id, ns2__VibrationalCharacterisationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VibrationalCharacterisationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VibrationalCharacterisationType ** SOAP_FMAC4 soap_in_PointerTons2__VibrationalCharacterisationType(struct soap *soap, const char *tag, ns2__VibrationalCharacterisationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VibrationalCharacterisationType **)soap_malloc(soap, sizeof(ns2__VibrationalCharacterisationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VibrationalCharacterisationType *)soap_instantiate_ns2__VibrationalCharacterisationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VibrationalCharacterisationType ** p = (ns2__VibrationalCharacterisationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VibrationalCharacterisationType, sizeof(ns2__VibrationalCharacterisationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VibrationalCharacterisationType(struct soap *soap, ns2__VibrationalCharacterisationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VibrationalCharacterisationType);
	if (soap_out_PointerTons2__VibrationalCharacterisationType(soap, tag?tag:"ns2:VibrationalCharacterisationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VibrationalCharacterisationType ** SOAP_FMAC4 soap_get_PointerTons2__VibrationalCharacterisationType(struct soap *soap, ns2__VibrationalCharacterisationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VibrationalCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CentralSymbolType(struct soap *soap, ns2__CentralSymbolType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CentralSymbolType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CentralSymbolType(struct soap *soap, const char *tag, int id, ns2__CentralSymbolType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CentralSymbolType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CentralSymbolType ** SOAP_FMAC4 soap_in_PointerTons2__CentralSymbolType(struct soap *soap, const char *tag, ns2__CentralSymbolType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CentralSymbolType **)soap_malloc(soap, sizeof(ns2__CentralSymbolType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CentralSymbolType *)soap_instantiate_ns2__CentralSymbolType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CentralSymbolType ** p = (ns2__CentralSymbolType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CentralSymbolType, sizeof(ns2__CentralSymbolType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CentralSymbolType(struct soap *soap, ns2__CentralSymbolType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CentralSymbolType);
	if (soap_out_PointerTons2__CentralSymbolType(soap, tag?tag:"ns2:CentralSymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CentralSymbolType ** SOAP_FMAC4 soap_get_PointerTons2__CentralSymbolType(struct soap *soap, ns2__CentralSymbolType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CentralSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RotationalComponentType(struct soap *soap, ns2__RotationalComponentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RotationalComponentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RotationalComponentType(struct soap *soap, const char *tag, int id, ns2__RotationalComponentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RotationalComponentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RotationalComponentType ** SOAP_FMAC4 soap_in_PointerTons2__RotationalComponentType(struct soap *soap, const char *tag, ns2__RotationalComponentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RotationalComponentType **)soap_malloc(soap, sizeof(ns2__RotationalComponentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RotationalComponentType *)soap_instantiate_ns2__RotationalComponentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RotationalComponentType ** p = (ns2__RotationalComponentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RotationalComponentType, sizeof(ns2__RotationalComponentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RotationalComponentType(struct soap *soap, ns2__RotationalComponentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RotationalComponentType);
	if (soap_out_PointerTons2__RotationalComponentType(soap, tag?tag:"ns2:RotationalComponentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RotationalComponentType ** SOAP_FMAC4 soap_get_PointerTons2__RotationalComponentType(struct soap *soap, ns2__RotationalComponentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RotationalComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RotationalCharacterisationType(struct soap *soap, ns2__RotationalCharacterisationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RotationalCharacterisationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RotationalCharacterisationType(struct soap *soap, const char *tag, int id, ns2__RotationalCharacterisationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RotationalCharacterisationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RotationalCharacterisationType ** SOAP_FMAC4 soap_in_PointerTons2__RotationalCharacterisationType(struct soap *soap, const char *tag, ns2__RotationalCharacterisationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RotationalCharacterisationType **)soap_malloc(soap, sizeof(ns2__RotationalCharacterisationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RotationalCharacterisationType *)soap_instantiate_ns2__RotationalCharacterisationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RotationalCharacterisationType ** p = (ns2__RotationalCharacterisationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RotationalCharacterisationType, sizeof(ns2__RotationalCharacterisationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RotationalCharacterisationType(struct soap *soap, ns2__RotationalCharacterisationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RotationalCharacterisationType);
	if (soap_out_PointerTons2__RotationalCharacterisationType(soap, tag?tag:"ns2:RotationalCharacterisationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RotationalCharacterisationType ** SOAP_FMAC4 soap_get_PointerTons2__RotationalCharacterisationType(struct soap *soap, ns2__RotationalCharacterisationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RotationalCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonLinearPolyatomicType(struct soap *soap, ns2__NonLinearPolyatomicType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonLinearPolyatomicType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonLinearPolyatomicType(struct soap *soap, const char *tag, int id, ns2__NonLinearPolyatomicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonLinearPolyatomicType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonLinearPolyatomicType ** SOAP_FMAC4 soap_in_PointerTons2__NonLinearPolyatomicType(struct soap *soap, const char *tag, ns2__NonLinearPolyatomicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonLinearPolyatomicType **)soap_malloc(soap, sizeof(ns2__NonLinearPolyatomicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonLinearPolyatomicType *)soap_instantiate_ns2__NonLinearPolyatomicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonLinearPolyatomicType ** p = (ns2__NonLinearPolyatomicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonLinearPolyatomicType, sizeof(ns2__NonLinearPolyatomicType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonLinearPolyatomicType(struct soap *soap, ns2__NonLinearPolyatomicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonLinearPolyatomicType);
	if (soap_out_PointerTons2__NonLinearPolyatomicType(soap, tag?tag:"ns2:NonLinearPolyatomicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonLinearPolyatomicType ** SOAP_FMAC4 soap_get_PointerTons2__NonLinearPolyatomicType(struct soap *soap, ns2__NonLinearPolyatomicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonLinearPolyatomicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DiatomAndLinearPolyatomicType(struct soap *soap, ns2__DiatomAndLinearPolyatomicType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DiatomAndLinearPolyatomicType(struct soap *soap, const char *tag, int id, ns2__DiatomAndLinearPolyatomicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DiatomAndLinearPolyatomicType ** SOAP_FMAC4 soap_in_PointerTons2__DiatomAndLinearPolyatomicType(struct soap *soap, const char *tag, ns2__DiatomAndLinearPolyatomicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DiatomAndLinearPolyatomicType **)soap_malloc(soap, sizeof(ns2__DiatomAndLinearPolyatomicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DiatomAndLinearPolyatomicType *)soap_instantiate_ns2__DiatomAndLinearPolyatomicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DiatomAndLinearPolyatomicType ** p = (ns2__DiatomAndLinearPolyatomicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DiatomAndLinearPolyatomicType, sizeof(ns2__DiatomAndLinearPolyatomicType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DiatomAndLinearPolyatomicType(struct soap *soap, ns2__DiatomAndLinearPolyatomicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DiatomAndLinearPolyatomicType);
	if (soap_out_PointerTons2__DiatomAndLinearPolyatomicType(soap, tag?tag:"ns2:DiatomAndLinearPolyatomicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DiatomAndLinearPolyatomicType ** SOAP_FMAC4 soap_get_PointerTons2__DiatomAndLinearPolyatomicType(struct soap *soap, ns2__DiatomAndLinearPolyatomicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DiatomAndLinearPolyatomicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PermutationSymmetryType(struct soap *soap, enum ns2__PermutationSymmetryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__PermutationSymmetryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PermutationSymmetryType(struct soap *soap, const char *tag, int id, enum ns2__PermutationSymmetryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PermutationSymmetryType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PermutationSymmetryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__PermutationSymmetryType ** SOAP_FMAC4 soap_in_PointerTons2__PermutationSymmetryType(struct soap *soap, const char *tag, enum ns2__PermutationSymmetryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__PermutationSymmetryType **)soap_malloc(soap, sizeof(enum ns2__PermutationSymmetryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PermutationSymmetryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__PermutationSymmetryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PermutationSymmetryType, sizeof(enum ns2__PermutationSymmetryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PermutationSymmetryType(struct soap *soap, enum ns2__PermutationSymmetryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PermutationSymmetryType);
	if (soap_out_PointerTons2__PermutationSymmetryType(soap, tag?tag:"ns2:PermutationSymmetryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PermutationSymmetryType ** SOAP_FMAC4 soap_get_PointerTons2__PermutationSymmetryType(struct soap *soap, enum ns2__PermutationSymmetryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PermutationSymmetryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonLinearElecHyperFType(struct soap *soap, ns2__NonLinearElecHyperFType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonLinearElecHyperFType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonLinearElecHyperFType(struct soap *soap, const char *tag, int id, ns2__NonLinearElecHyperFType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonLinearElecHyperFType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonLinearElecHyperFType ** SOAP_FMAC4 soap_in_PointerTons2__NonLinearElecHyperFType(struct soap *soap, const char *tag, ns2__NonLinearElecHyperFType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonLinearElecHyperFType **)soap_malloc(soap, sizeof(ns2__NonLinearElecHyperFType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonLinearElecHyperFType *)soap_instantiate_ns2__NonLinearElecHyperFType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonLinearElecHyperFType ** p = (ns2__NonLinearElecHyperFType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonLinearElecHyperFType, sizeof(ns2__NonLinearElecHyperFType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonLinearElecHyperFType(struct soap *soap, ns2__NonLinearElecHyperFType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonLinearElecHyperFType);
	if (soap_out_PointerTons2__NonLinearElecHyperFType(soap, tag?tag:"ns2:NonLinearElecHyperFType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonLinearElecHyperFType ** SOAP_FMAC4 soap_get_PointerTons2__NonLinearElecHyperFType(struct soap *soap, ns2__NonLinearElecHyperFType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonLinearElecHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonLinearElecNoHyperFType(struct soap *soap, ns2__NonLinearElecNoHyperFType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonLinearElecNoHyperFType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonLinearElecNoHyperFType(struct soap *soap, const char *tag, int id, ns2__NonLinearElecNoHyperFType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonLinearElecNoHyperFType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonLinearElecNoHyperFType ** SOAP_FMAC4 soap_in_PointerTons2__NonLinearElecNoHyperFType(struct soap *soap, const char *tag, ns2__NonLinearElecNoHyperFType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonLinearElecNoHyperFType **)soap_malloc(soap, sizeof(ns2__NonLinearElecNoHyperFType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonLinearElecNoHyperFType *)soap_instantiate_ns2__NonLinearElecNoHyperFType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonLinearElecNoHyperFType ** p = (ns2__NonLinearElecNoHyperFType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonLinearElecNoHyperFType, sizeof(ns2__NonLinearElecNoHyperFType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonLinearElecNoHyperFType(struct soap *soap, ns2__NonLinearElecNoHyperFType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonLinearElecNoHyperFType);
	if (soap_out_PointerTons2__NonLinearElecNoHyperFType(soap, tag?tag:"ns2:NonLinearElecNoHyperFType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonLinearElecNoHyperFType ** SOAP_FMAC4 soap_get_PointerTons2__NonLinearElecNoHyperFType(struct soap *soap, ns2__NonLinearElecNoHyperFType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonLinearElecNoHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonLinearNoElecHyperFType(struct soap *soap, ns2__NonLinearNoElecHyperFType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonLinearNoElecHyperFType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonLinearNoElecHyperFType(struct soap *soap, const char *tag, int id, ns2__NonLinearNoElecHyperFType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonLinearNoElecHyperFType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecHyperFType ** SOAP_FMAC4 soap_in_PointerTons2__NonLinearNoElecHyperFType(struct soap *soap, const char *tag, ns2__NonLinearNoElecHyperFType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonLinearNoElecHyperFType **)soap_malloc(soap, sizeof(ns2__NonLinearNoElecHyperFType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonLinearNoElecHyperFType *)soap_instantiate_ns2__NonLinearNoElecHyperFType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonLinearNoElecHyperFType ** p = (ns2__NonLinearNoElecHyperFType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonLinearNoElecHyperFType, sizeof(ns2__NonLinearNoElecHyperFType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonLinearNoElecHyperFType(struct soap *soap, ns2__NonLinearNoElecHyperFType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonLinearNoElecHyperFType);
	if (soap_out_PointerTons2__NonLinearNoElecHyperFType(soap, tag?tag:"ns2:NonLinearNoElecHyperFType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonLinearNoElecHyperFType ** SOAP_FMAC4 soap_get_PointerTons2__NonLinearNoElecHyperFType(struct soap *soap, ns2__NonLinearNoElecHyperFType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonLinearNoElecHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NonLinearNoElecNoHyperFType(struct soap *soap, ns2__NonLinearNoElecNoHyperFType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NonLinearNoElecNoHyperFType(struct soap *soap, const char *tag, int id, ns2__NonLinearNoElecNoHyperFType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NonLinearNoElecNoHyperFType ** SOAP_FMAC4 soap_in_PointerTons2__NonLinearNoElecNoHyperFType(struct soap *soap, const char *tag, ns2__NonLinearNoElecNoHyperFType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NonLinearNoElecNoHyperFType **)soap_malloc(soap, sizeof(ns2__NonLinearNoElecNoHyperFType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NonLinearNoElecNoHyperFType *)soap_instantiate_ns2__NonLinearNoElecNoHyperFType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NonLinearNoElecNoHyperFType ** p = (ns2__NonLinearNoElecNoHyperFType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NonLinearNoElecNoHyperFType, sizeof(ns2__NonLinearNoElecNoHyperFType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NonLinearNoElecNoHyperFType(struct soap *soap, ns2__NonLinearNoElecNoHyperFType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NonLinearNoElecNoHyperFType);
	if (soap_out_PointerTons2__NonLinearNoElecNoHyperFType(soap, tag?tag:"ns2:NonLinearNoElecNoHyperFType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NonLinearNoElecNoHyperFType ** SOAP_FMAC4 soap_get_PointerTons2__NonLinearNoElecNoHyperFType(struct soap *soap, ns2__NonLinearNoElecNoHyperFType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NonLinearNoElecNoHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BondArrayType(struct soap *soap, ns2__BondArrayType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BondArrayType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BondArrayType(struct soap *soap, const char *tag, int id, ns2__BondArrayType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BondArrayType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BondArrayType ** SOAP_FMAC4 soap_in_PointerTons2__BondArrayType(struct soap *soap, const char *tag, ns2__BondArrayType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BondArrayType **)soap_malloc(soap, sizeof(ns2__BondArrayType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BondArrayType *)soap_instantiate_ns2__BondArrayType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__BondArrayType ** p = (ns2__BondArrayType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BondArrayType, sizeof(ns2__BondArrayType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BondArrayType(struct soap *soap, ns2__BondArrayType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BondArrayType);
	if (soap_out_PointerTons2__BondArrayType(soap, tag?tag:"ns2:BondArrayType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BondArrayType ** SOAP_FMAC4 soap_get_PointerTons2__BondArrayType(struct soap *soap, ns2__BondArrayType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BondArrayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomArrayType(struct soap *soap, ns2__AtomArrayType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomArrayType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomArrayType(struct soap *soap, const char *tag, int id, ns2__AtomArrayType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomArrayType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomArrayType ** SOAP_FMAC4 soap_in_PointerTons2__AtomArrayType(struct soap *soap, const char *tag, ns2__AtomArrayType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomArrayType **)soap_malloc(soap, sizeof(ns2__AtomArrayType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomArrayType *)soap_instantiate_ns2__AtomArrayType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomArrayType ** p = (ns2__AtomArrayType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomArrayType, sizeof(ns2__AtomArrayType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomArrayType(struct soap *soap, ns2__AtomArrayType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomArrayType);
	if (soap_out_PointerTons2__AtomArrayType(soap, tag?tag:"ns2:AtomArrayType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomArrayType ** SOAP_FMAC4 soap_get_PointerTons2__AtomArrayType(struct soap *soap, ns2__AtomArrayType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomArrayType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PseudoStatisticalWeightType(struct soap *soap, ns2__PseudoStatisticalWeightType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PseudoStatisticalWeightType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PseudoStatisticalWeightType(struct soap *soap, const char *tag, int id, ns2__PseudoStatisticalWeightType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PseudoStatisticalWeightType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PseudoStatisticalWeightType ** SOAP_FMAC4 soap_in_PointerTons2__PseudoStatisticalWeightType(struct soap *soap, const char *tag, ns2__PseudoStatisticalWeightType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PseudoStatisticalWeightType **)soap_malloc(soap, sizeof(ns2__PseudoStatisticalWeightType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PseudoStatisticalWeightType *)soap_instantiate_ns2__PseudoStatisticalWeightType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PseudoStatisticalWeightType ** p = (ns2__PseudoStatisticalWeightType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PseudoStatisticalWeightType, sizeof(ns2__PseudoStatisticalWeightType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PseudoStatisticalWeightType(struct soap *soap, ns2__PseudoStatisticalWeightType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PseudoStatisticalWeightType);
	if (soap_out_PointerTons2__PseudoStatisticalWeightType(soap, tag?tag:"ns2:PseudoStatisticalWeightType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PseudoStatisticalWeightType ** SOAP_FMAC4 soap_get_PointerTons2__PseudoStatisticalWeightType(struct soap *soap, ns2__PseudoStatisticalWeightType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PseudoStatisticalWeightType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StateEnergyType(struct soap *soap, ns2__StateEnergyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StateEnergyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StateEnergyType(struct soap *soap, const char *tag, int id, ns2__StateEnergyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StateEnergyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__StateEnergyType ** SOAP_FMAC4 soap_in_PointerTons2__StateEnergyType(struct soap *soap, const char *tag, ns2__StateEnergyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__StateEnergyType **)soap_malloc(soap, sizeof(ns2__StateEnergyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__StateEnergyType *)soap_instantiate_ns2__StateEnergyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__StateEnergyType ** p = (ns2__StateEnergyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StateEnergyType, sizeof(ns2__StateEnergyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StateEnergyType(struct soap *soap, ns2__StateEnergyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__StateEnergyType);
	if (soap_out_PointerTons2__StateEnergyType(soap, tag?tag:"ns2:StateEnergyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__StateEnergyType ** SOAP_FMAC4 soap_get_PointerTons2__StateEnergyType(struct soap *soap, ns2__StateEnergyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StateEnergyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CharacterisationType(struct soap *soap, ns2__CharacterisationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CharacterisationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CharacterisationType(struct soap *soap, const char *tag, int id, ns2__CharacterisationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CharacterisationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CharacterisationType ** SOAP_FMAC4 soap_in_PointerTons2__CharacterisationType(struct soap *soap, const char *tag, ns2__CharacterisationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CharacterisationType **)soap_malloc(soap, sizeof(ns2__CharacterisationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CharacterisationType *)soap_instantiate_ns2__CharacterisationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CharacterisationType ** p = (ns2__CharacterisationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CharacterisationType, sizeof(ns2__CharacterisationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CharacterisationType(struct soap *soap, ns2__CharacterisationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CharacterisationType);
	if (soap_out_PointerTons2__CharacterisationType(soap, tag?tag:"ns2:CharacterisationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CharacterisationType ** SOAP_FMAC4 soap_get_PointerTons2__CharacterisationType(struct soap *soap, ns2__CharacterisationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataType(struct soap *soap, ns2__DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataType(struct soap *soap, const char *tag, int id, ns2__DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DataType ** SOAP_FMAC4 soap_in_PointerTons2__DataType(struct soap *soap, const char *tag, ns2__DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DataType **)soap_malloc(soap, sizeof(ns2__DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DataType *)soap_instantiate_ns2__DataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DataType ** p = (ns2__DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataType, sizeof(ns2__DataType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StateEnergyType, sizeof(ns2__StateEnergyType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataType(struct soap *soap, ns2__DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataType);
	if (soap_out_PointerTons2__DataType(soap, tag?tag:"ns2:DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DataType ** SOAP_FMAC4 soap_get_PointerTons2__DataType(struct soap *soap, ns2__DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HinderedMotionType(struct soap *soap, ns2__HinderedMotionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HinderedMotionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HinderedMotionType(struct soap *soap, const char *tag, int id, ns2__HinderedMotionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HinderedMotionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HinderedMotionType ** SOAP_FMAC4 soap_in_PointerTons2__HinderedMotionType(struct soap *soap, const char *tag, ns2__HinderedMotionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HinderedMotionType **)soap_malloc(soap, sizeof(ns2__HinderedMotionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HinderedMotionType *)soap_instantiate_ns2__HinderedMotionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HinderedMotionType ** p = (ns2__HinderedMotionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HinderedMotionType, sizeof(ns2__HinderedMotionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HinderedMotionType(struct soap *soap, ns2__HinderedMotionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HinderedMotionType);
	if (soap_out_PointerTons2__HinderedMotionType(soap, tag?tag:"ns2:HinderedMotionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HinderedMotionType ** SOAP_FMAC4 soap_get_PointerTons2__HinderedMotionType(struct soap *soap, ns2__HinderedMotionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HinderedMotionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AsymmetricProjectionType(struct soap *soap, ns2__AsymmetricProjectionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AsymmetricProjectionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AsymmetricProjectionType(struct soap *soap, const char *tag, int id, ns2__AsymmetricProjectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AsymmetricProjectionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AsymmetricProjectionType ** SOAP_FMAC4 soap_in_PointerTons2__AsymmetricProjectionType(struct soap *soap, const char *tag, ns2__AsymmetricProjectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AsymmetricProjectionType **)soap_malloc(soap, sizeof(ns2__AsymmetricProjectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AsymmetricProjectionType *)soap_instantiate_ns2__AsymmetricProjectionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AsymmetricProjectionType ** p = (ns2__AsymmetricProjectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AsymmetricProjectionType, sizeof(ns2__AsymmetricProjectionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AsymmetricProjectionType(struct soap *soap, ns2__AsymmetricProjectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AsymmetricProjectionType);
	if (soap_out_PointerTons2__AsymmetricProjectionType(soap, tag?tag:"ns2:AsymmetricProjectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AsymmetricProjectionType ** SOAP_FMAC4 soap_get_PointerTons2__AsymmetricProjectionType(struct soap *soap, ns2__AsymmetricProjectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AsymmetricProjectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MolecularPropertiesType(struct soap *soap, ns2__MolecularPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MolecularPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MolecularPropertiesType(struct soap *soap, const char *tag, int id, ns2__MolecularPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MolecularPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MolecularPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__MolecularPropertiesType(struct soap *soap, const char *tag, ns2__MolecularPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MolecularPropertiesType **)soap_malloc(soap, sizeof(ns2__MolecularPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MolecularPropertiesType *)soap_instantiate_ns2__MolecularPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MolecularPropertiesType ** p = (ns2__MolecularPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MolecularPropertiesType, sizeof(ns2__MolecularPropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MolecularPropertiesType(struct soap *soap, ns2__MolecularPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MolecularPropertiesType);
	if (soap_out_PointerTons2__MolecularPropertiesType(soap, tag?tag:"ns2:MolecularPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MolecularPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__MolecularPropertiesType(struct soap *soap, ns2__MolecularPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MolecularPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MoleculeNuclearSpinsType(struct soap *soap, ns2__MoleculeNuclearSpinsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MoleculeNuclearSpinsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MoleculeNuclearSpinsType(struct soap *soap, const char *tag, int id, ns2__MoleculeNuclearSpinsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MoleculeNuclearSpinsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MoleculeNuclearSpinsType ** SOAP_FMAC4 soap_in_PointerTons2__MoleculeNuclearSpinsType(struct soap *soap, const char *tag, ns2__MoleculeNuclearSpinsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MoleculeNuclearSpinsType **)soap_malloc(soap, sizeof(ns2__MoleculeNuclearSpinsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MoleculeNuclearSpinsType *)soap_instantiate_ns2__MoleculeNuclearSpinsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MoleculeNuclearSpinsType ** p = (ns2__MoleculeNuclearSpinsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MoleculeNuclearSpinsType, sizeof(ns2__MoleculeNuclearSpinsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MoleculeNuclearSpinsType(struct soap *soap, ns2__MoleculeNuclearSpinsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MoleculeNuclearSpinsType);
	if (soap_out_PointerTons2__MoleculeNuclearSpinsType(soap, tag?tag:"ns2:MoleculeNuclearSpinsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MoleculeNuclearSpinsType ** SOAP_FMAC4 soap_get_PointerTons2__MoleculeNuclearSpinsType(struct soap *soap, ns2__MoleculeNuclearSpinsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MoleculeNuclearSpinsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ElectronicComponentType(struct soap *soap, ns2__ElectronicComponentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ElectronicComponentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ElectronicComponentType(struct soap *soap, const char *tag, int id, ns2__ElectronicComponentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ElectronicComponentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ElectronicComponentType ** SOAP_FMAC4 soap_in_PointerTons2__ElectronicComponentType(struct soap *soap, const char *tag, ns2__ElectronicComponentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ElectronicComponentType **)soap_malloc(soap, sizeof(ns2__ElectronicComponentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ElectronicComponentType *)soap_instantiate_ns2__ElectronicComponentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ElectronicComponentType ** p = (ns2__ElectronicComponentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ElectronicComponentType, sizeof(ns2__ElectronicComponentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ElectronicComponentType(struct soap *soap, ns2__ElectronicComponentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ElectronicComponentType);
	if (soap_out_PointerTons2__ElectronicComponentType(soap, tag?tag:"ns2:ElectronicComponentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ElectronicComponentType ** SOAP_FMAC4 soap_get_PointerTons2__ElectronicComponentType(struct soap *soap, ns2__ElectronicComponentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ElectronicComponentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VibrationalHomeType(struct soap *soap, ns2__VibrationalHomeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VibrationalHomeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VibrationalHomeType(struct soap *soap, const char *tag, int id, ns2__VibrationalHomeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VibrationalHomeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VibrationalHomeType ** SOAP_FMAC4 soap_in_PointerTons2__VibrationalHomeType(struct soap *soap, const char *tag, ns2__VibrationalHomeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VibrationalHomeType **)soap_malloc(soap, sizeof(ns2__VibrationalHomeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VibrationalHomeType *)soap_instantiate_ns2__VibrationalHomeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VibrationalHomeType ** p = (ns2__VibrationalHomeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VibrationalHomeType, sizeof(ns2__VibrationalHomeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VibrationalHomeType(struct soap *soap, ns2__VibrationalHomeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VibrationalHomeType);
	if (soap_out_PointerTons2__VibrationalHomeType(soap, tag?tag:"ns2:VibrationalHomeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VibrationalHomeType ** SOAP_FMAC4 soap_get_PointerTons2__VibrationalHomeType(struct soap *soap, ns2__VibrationalHomeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VibrationalHomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ElectronicCharacterisationType(struct soap *soap, ns2__ElectronicCharacterisationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ElectronicCharacterisationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ElectronicCharacterisationType(struct soap *soap, const char *tag, int id, ns2__ElectronicCharacterisationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ElectronicCharacterisationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ElectronicCharacterisationType ** SOAP_FMAC4 soap_in_PointerTons2__ElectronicCharacterisationType(struct soap *soap, const char *tag, ns2__ElectronicCharacterisationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ElectronicCharacterisationType **)soap_malloc(soap, sizeof(ns2__ElectronicCharacterisationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ElectronicCharacterisationType *)soap_instantiate_ns2__ElectronicCharacterisationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ElectronicCharacterisationType ** p = (ns2__ElectronicCharacterisationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ElectronicCharacterisationType, sizeof(ns2__ElectronicCharacterisationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ElectronicCharacterisationType(struct soap *soap, ns2__ElectronicCharacterisationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ElectronicCharacterisationType);
	if (soap_out_PointerTons2__ElectronicCharacterisationType(soap, tag?tag:"ns2:ElectronicCharacterisationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ElectronicCharacterisationType ** SOAP_FMAC4 soap_get_PointerTons2__ElectronicCharacterisationType(struct soap *soap, ns2__ElectronicCharacterisationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ElectronicCharacterisationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReferencedTextType(struct soap *soap, ns2__ReferencedTextType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReferencedTextType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReferencedTextType(struct soap *soap, const char *tag, int id, ns2__ReferencedTextType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReferencedTextType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReferencedTextType ** SOAP_FMAC4 soap_in_PointerTons2__ReferencedTextType(struct soap *soap, const char *tag, ns2__ReferencedTextType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReferencedTextType **)soap_malloc(soap, sizeof(ns2__ReferencedTextType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReferencedTextType *)soap_instantiate_ns2__ReferencedTextType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ReferencedTextType ** p = (ns2__ReferencedTextType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReferencedTextType, sizeof(ns2__ReferencedTextType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReferencedTextType(struct soap *soap, ns2__ReferencedTextType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReferencedTextType);
	if (soap_out_PointerTons2__ReferencedTextType(soap, tag?tag:"ns2:ReferencedTextType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReferencedTextType ** SOAP_FMAC4 soap_get_PointerTons2__ReferencedTextType(struct soap *soap, ns2__ReferencedTextType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReferencedTextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SymbolType(struct soap *soap, ns2__SymbolType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SymbolType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SymbolType(struct soap *soap, const char *tag, int id, ns2__SymbolType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SymbolType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SymbolType ** SOAP_FMAC4 soap_in_PointerTons2__SymbolType(struct soap *soap, const char *tag, ns2__SymbolType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SymbolType **)soap_malloc(soap, sizeof(ns2__SymbolType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SymbolType *)soap_instantiate_ns2__SymbolType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SymbolType ** p = (ns2__SymbolType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SymbolType, sizeof(ns2__SymbolType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SymbolType(struct soap *soap, ns2__SymbolType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SymbolType);
	if (soap_out_PointerTons2__SymbolType(soap, tag?tag:"ns2:SymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SymbolType ** SOAP_FMAC4 soap_get_PointerTons2__SymbolType(struct soap *soap, ns2__SymbolType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LinearElecCouplingType(struct soap *soap, ns2__LinearElecCouplingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LinearElecCouplingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LinearElecCouplingType(struct soap *soap, const char *tag, int id, ns2__LinearElecCouplingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LinearElecCouplingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LinearElecCouplingType ** SOAP_FMAC4 soap_in_PointerTons2__LinearElecCouplingType(struct soap *soap, const char *tag, ns2__LinearElecCouplingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LinearElecCouplingType **)soap_malloc(soap, sizeof(ns2__LinearElecCouplingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LinearElecCouplingType *)soap_instantiate_ns2__LinearElecCouplingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LinearElecCouplingType ** p = (ns2__LinearElecCouplingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LinearElecCouplingType, sizeof(ns2__LinearElecCouplingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LinearElecCouplingType(struct soap *soap, ns2__LinearElecCouplingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LinearElecCouplingType);
	if (soap_out_PointerTons2__LinearElecCouplingType(soap, tag?tag:"ns2:LinearElecCouplingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LinearElecCouplingType ** SOAP_FMAC4 soap_get_PointerTons2__LinearElecCouplingType(struct soap *soap, ns2__LinearElecCouplingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LinearElecCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LinearNoElecHyperFType(struct soap *soap, ns2__LinearNoElecHyperFType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LinearNoElecHyperFType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LinearNoElecHyperFType(struct soap *soap, const char *tag, int id, ns2__LinearNoElecHyperFType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LinearNoElecHyperFType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LinearNoElecHyperFType ** SOAP_FMAC4 soap_in_PointerTons2__LinearNoElecHyperFType(struct soap *soap, const char *tag, ns2__LinearNoElecHyperFType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LinearNoElecHyperFType **)soap_malloc(soap, sizeof(ns2__LinearNoElecHyperFType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LinearNoElecHyperFType *)soap_instantiate_ns2__LinearNoElecHyperFType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LinearNoElecHyperFType ** p = (ns2__LinearNoElecHyperFType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LinearNoElecHyperFType, sizeof(ns2__LinearNoElecHyperFType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LinearNoElecHyperFType(struct soap *soap, ns2__LinearNoElecHyperFType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LinearNoElecHyperFType);
	if (soap_out_PointerTons2__LinearNoElecHyperFType(soap, tag?tag:"ns2:LinearNoElecHyperFType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LinearNoElecHyperFType ** SOAP_FMAC4 soap_get_PointerTons2__LinearNoElecHyperFType(struct soap *soap, ns2__LinearNoElecHyperFType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LinearNoElecHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LinearNoElecNoHyperFType(struct soap *soap, ns2__LinearNoElecNoHyperFType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LinearNoElecNoHyperFType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LinearNoElecNoHyperFType(struct soap *soap, const char *tag, int id, ns2__LinearNoElecNoHyperFType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LinearNoElecNoHyperFType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LinearNoElecNoHyperFType ** SOAP_FMAC4 soap_in_PointerTons2__LinearNoElecNoHyperFType(struct soap *soap, const char *tag, ns2__LinearNoElecNoHyperFType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LinearNoElecNoHyperFType **)soap_malloc(soap, sizeof(ns2__LinearNoElecNoHyperFType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LinearNoElecNoHyperFType *)soap_instantiate_ns2__LinearNoElecNoHyperFType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LinearNoElecNoHyperFType ** p = (ns2__LinearNoElecNoHyperFType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LinearNoElecNoHyperFType, sizeof(ns2__LinearNoElecNoHyperFType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LinearNoElecNoHyperFType(struct soap *soap, ns2__LinearNoElecNoHyperFType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LinearNoElecNoHyperFType);
	if (soap_out_PointerTons2__LinearNoElecNoHyperFType(soap, tag?tag:"ns2:LinearNoElecNoHyperFType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LinearNoElecNoHyperFType ** SOAP_FMAC4 soap_get_PointerTons2__LinearNoElecNoHyperFType(struct soap *soap, ns2__LinearNoElecNoHyperFType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LinearNoElecNoHyperFType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BondType(struct soap *soap, ns2__BondType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BondType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BondType(struct soap *soap, const char *tag, int id, ns2__BondType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BondType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BondType ** SOAP_FMAC4 soap_in_PointerTons2__BondType(struct soap *soap, const char *tag, ns2__BondType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BondType **)soap_malloc(soap, sizeof(ns2__BondType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BondType *)soap_instantiate_ns2__BondType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__BondType ** p = (ns2__BondType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BondType, sizeof(ns2__BondType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BondType(struct soap *soap, ns2__BondType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BondType);
	if (soap_out_PointerTons2__BondType(soap, tag?tag:"ns2:BondType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BondType ** SOAP_FMAC4 soap_get_PointerTons2__BondType(struct soap *soap, ns2__BondType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BondType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__IDREFS(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__IDREFS))
		soap_serialize_xsd__IDREFS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__IDREFS(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__IDREFS);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__IDREFS(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__IDREFS(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__IDREFS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__IDREFS, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__IDREFS(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__IDREFS);
	if (soap_out_PointerToxsd__IDREFS(soap, tag?tag:"xsd:IDREFS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__IDREFS(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__IDREFS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomNType(struct soap *soap, ns2__AtomNType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomNType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomNType(struct soap *soap, const char *tag, int id, ns2__AtomNType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomNType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomNType ** SOAP_FMAC4 soap_in_PointerTons2__AtomNType(struct soap *soap, const char *tag, ns2__AtomNType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomNType **)soap_malloc(soap, sizeof(ns2__AtomNType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomNType *)soap_instantiate_ns2__AtomNType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomNType ** p = (ns2__AtomNType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomNType, sizeof(ns2__AtomNType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomNType(struct soap *soap, ns2__AtomNType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomNType);
	if (soap_out_PointerTons2__AtomNType(soap, tag?tag:"ns2:AtomNType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomNType ** SOAP_FMAC4 soap_get_PointerTons2__AtomNType(struct soap *soap, ns2__AtomNType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomNType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MolecularQuantumNumberType(struct soap *soap, ns2__MolecularQuantumNumberType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MolecularQuantumNumberType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MolecularQuantumNumberType(struct soap *soap, const char *tag, int id, ns2__MolecularQuantumNumberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MolecularQuantumNumberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MolecularQuantumNumberType ** SOAP_FMAC4 soap_in_PointerTons2__MolecularQuantumNumberType(struct soap *soap, const char *tag, ns2__MolecularQuantumNumberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MolecularQuantumNumberType **)soap_malloc(soap, sizeof(ns2__MolecularQuantumNumberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MolecularQuantumNumberType *)soap_instantiate_ns2__MolecularQuantumNumberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MolecularQuantumNumberType ** p = (ns2__MolecularQuantumNumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MolecularQuantumNumberType, sizeof(ns2__MolecularQuantumNumberType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__MolecularQuantumNumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType, sizeof(ns2__ComplexMolecularQuantumNumberType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MolecularQuantumNumberType(struct soap *soap, ns2__MolecularQuantumNumberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MolecularQuantumNumberType);
	if (soap_out_PointerTons2__MolecularQuantumNumberType(soap, tag?tag:"ns2:MolecularQuantumNumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MolecularQuantumNumberType ** SOAP_FMAC4 soap_get_PointerTons2__MolecularQuantumNumberType(struct soap *soap, ns2__MolecularQuantumNumberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MolecularQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MagneticQuantumNumberType(struct soap *soap, ns2__MagneticQuantumNumberType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MagneticQuantumNumberType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MagneticQuantumNumberType(struct soap *soap, const char *tag, int id, ns2__MagneticQuantumNumberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MagneticQuantumNumberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MagneticQuantumNumberType ** SOAP_FMAC4 soap_in_PointerTons2__MagneticQuantumNumberType(struct soap *soap, const char *tag, ns2__MagneticQuantumNumberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MagneticQuantumNumberType **)soap_malloc(soap, sizeof(ns2__MagneticQuantumNumberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MagneticQuantumNumberType *)soap_instantiate_ns2__MagneticQuantumNumberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MagneticQuantumNumberType ** p = (ns2__MagneticQuantumNumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MagneticQuantumNumberType, sizeof(ns2__MagneticQuantumNumberType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MagneticQuantumNumberType(struct soap *soap, ns2__MagneticQuantumNumberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MagneticQuantumNumberType);
	if (soap_out_PointerTons2__MagneticQuantumNumberType(soap, tag?tag:"ns2:MagneticQuantumNumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MagneticQuantumNumberType ** SOAP_FMAC4 soap_get_PointerTons2__MagneticQuantumNumberType(struct soap *soap, ns2__MagneticQuantumNumberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MagneticQuantumNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SuperShellType(struct soap *soap, ns2__SuperShellType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SuperShellType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SuperShellType(struct soap *soap, const char *tag, int id, ns2__SuperShellType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SuperShellType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SuperShellType ** SOAP_FMAC4 soap_in_PointerTons2__SuperShellType(struct soap *soap, const char *tag, ns2__SuperShellType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SuperShellType **)soap_malloc(soap, sizeof(ns2__SuperShellType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SuperShellType *)soap_instantiate_ns2__SuperShellType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SuperShellType ** p = (ns2__SuperShellType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SuperShellType, sizeof(ns2__SuperShellType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SuperShellType(struct soap *soap, ns2__SuperShellType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SuperShellType);
	if (soap_out_PointerTons2__SuperShellType(soap, tag?tag:"ns2:SuperShellType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SuperShellType ** SOAP_FMAC4 soap_get_PointerTons2__SuperShellType(struct soap *soap, ns2__SuperShellType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SuperShellType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ID);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__ID);
	if (soap_out_PointerToxsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShellPairType(struct soap *soap, ns2__ShellPairType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShellPairType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShellPairType(struct soap *soap, const char *tag, int id, ns2__ShellPairType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShellPairType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ShellPairType ** SOAP_FMAC4 soap_in_PointerTons2__ShellPairType(struct soap *soap, const char *tag, ns2__ShellPairType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ShellPairType **)soap_malloc(soap, sizeof(ns2__ShellPairType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ShellPairType *)soap_instantiate_ns2__ShellPairType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ShellPairType ** p = (ns2__ShellPairType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShellPairType, sizeof(ns2__ShellPairType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShellPairType(struct soap *soap, ns2__ShellPairType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ShellPairType);
	if (soap_out_PointerTons2__ShellPairType(soap, tag?tag:"ns2:ShellPairType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ShellPairType ** SOAP_FMAC4 soap_get_PointerTons2__ShellPairType(struct soap *soap, ns2__ShellPairType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShellPairType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShellType(struct soap *soap, ns2__ShellType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShellType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShellType(struct soap *soap, const char *tag, int id, ns2__ShellType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShellType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ShellType ** SOAP_FMAC4 soap_in_PointerTons2__ShellType(struct soap *soap, const char *tag, ns2__ShellType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ShellType **)soap_malloc(soap, sizeof(ns2__ShellType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ShellType *)soap_instantiate_ns2__ShellType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ShellType ** p = (ns2__ShellType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShellType, sizeof(ns2__ShellType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShellType(struct soap *soap, ns2__ShellType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ShellType);
	if (soap_out_PointerTons2__ShellType(soap, tag?tag:"ns2:ShellType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ShellType ** SOAP_FMAC4 soap_get_PointerTons2__ShellType(struct soap *soap, ns2__ShellType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShellType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShellsType(struct soap *soap, ns2__ShellsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShellsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShellsType(struct soap *soap, const char *tag, int id, ns2__ShellsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShellsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ShellsType ** SOAP_FMAC4 soap_in_PointerTons2__ShellsType(struct soap *soap, const char *tag, ns2__ShellsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ShellsType **)soap_malloc(soap, sizeof(ns2__ShellsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ShellsType *)soap_instantiate_ns2__ShellsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ShellsType ** p = (ns2__ShellsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShellsType, sizeof(ns2__ShellsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShellsType(struct soap *soap, ns2__ShellsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ShellsType);
	if (soap_out_PointerTons2__ShellsType(soap, tag?tag:"ns2:ShellsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ShellsType ** SOAP_FMAC4 soap_get_PointerTons2__ShellsType(struct soap *soap, ns2__ShellsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShellsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AtomicCoreType(struct soap *soap, ns2__AtomicCoreType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AtomicCoreType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AtomicCoreType(struct soap *soap, const char *tag, int id, ns2__AtomicCoreType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AtomicCoreType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AtomicCoreType ** SOAP_FMAC4 soap_in_PointerTons2__AtomicCoreType(struct soap *soap, const char *tag, ns2__AtomicCoreType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AtomicCoreType **)soap_malloc(soap, sizeof(ns2__AtomicCoreType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AtomicCoreType *)soap_instantiate_ns2__AtomicCoreType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AtomicCoreType ** p = (ns2__AtomicCoreType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AtomicCoreType, sizeof(ns2__AtomicCoreType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AtomicCoreType(struct soap *soap, ns2__AtomicCoreType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AtomicCoreType);
	if (soap_out_PointerTons2__AtomicCoreType(soap, tag?tag:"ns2:AtomicCoreType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AtomicCoreType ** SOAP_FMAC4 soap_get_PointerTons2__AtomicCoreType(struct soap *soap, ns2__AtomicCoreType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AtomicCoreType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AngularMomentumProjectionType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AngularMomentumProjectionType))
		soap_serialize_ns2__AngularMomentumProjectionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AngularMomentumProjectionType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AngularMomentumProjectionType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AngularMomentumProjectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__AngularMomentumProjectionType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AngularMomentumProjectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AngularMomentumProjectionType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AngularMomentumProjectionType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AngularMomentumProjectionType);
	if (soap_out_PointerTons2__AngularMomentumProjectionType(soap, tag?tag:"ns2:AngularMomentumProjectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__AngularMomentumProjectionType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AngularMomentumProjectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParityType(struct soap *soap, enum ns2__ParityType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ParityType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParityType(struct soap *soap, const char *tag, int id, enum ns2__ParityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParityType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ParityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ParityType ** SOAP_FMAC4 soap_in_PointerTons2__ParityType(struct soap *soap, const char *tag, enum ns2__ParityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ParityType **)soap_malloc(soap, sizeof(enum ns2__ParityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ParityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ParityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParityType, sizeof(enum ns2__ParityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParityType(struct soap *soap, enum ns2__ParityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParityType);
	if (soap_out_PointerTons2__ParityType(soap, tag?tag:"ns2:ParityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ParityType ** SOAP_FMAC4 soap_get_PointerTons2__ParityType(struct soap *soap, enum ns2__ParityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MixingCoefficientType(struct soap *soap, ns2__MixingCoefficientType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MixingCoefficientType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MixingCoefficientType(struct soap *soap, const char *tag, int id, ns2__MixingCoefficientType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MixingCoefficientType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MixingCoefficientType ** SOAP_FMAC4 soap_in_PointerTons2__MixingCoefficientType(struct soap *soap, const char *tag, ns2__MixingCoefficientType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MixingCoefficientType **)soap_malloc(soap, sizeof(ns2__MixingCoefficientType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MixingCoefficientType *)soap_instantiate_ns2__MixingCoefficientType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MixingCoefficientType ** p = (ns2__MixingCoefficientType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MixingCoefficientType, sizeof(ns2__MixingCoefficientType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MixingCoefficientType(struct soap *soap, ns2__MixingCoefficientType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MixingCoefficientType);
	if (soap_out_PointerTons2__MixingCoefficientType(soap, tag?tag:"ns2:MixingCoefficientType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MixingCoefficientType ** SOAP_FMAC4 soap_get_PointerTons2__MixingCoefficientType(struct soap *soap, ns2__MixingCoefficientType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MixingCoefficientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SuperConfigurationType(struct soap *soap, ns2__SuperConfigurationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SuperConfigurationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SuperConfigurationType(struct soap *soap, const char *tag, int id, ns2__SuperConfigurationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SuperConfigurationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SuperConfigurationType ** SOAP_FMAC4 soap_in_PointerTons2__SuperConfigurationType(struct soap *soap, const char *tag, ns2__SuperConfigurationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SuperConfigurationType **)soap_malloc(soap, sizeof(ns2__SuperConfigurationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SuperConfigurationType *)soap_instantiate_ns2__SuperConfigurationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SuperConfigurationType ** p = (ns2__SuperConfigurationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SuperConfigurationType, sizeof(ns2__SuperConfigurationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SuperConfigurationType(struct soap *soap, ns2__SuperConfigurationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SuperConfigurationType);
	if (soap_out_PointerTons2__SuperConfigurationType(soap, tag?tag:"ns2:SuperConfigurationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SuperConfigurationType ** SOAP_FMAC4 soap_get_PointerTons2__SuperConfigurationType(struct soap *soap, ns2__SuperConfigurationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SuperConfigurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TermType(struct soap *soap, ns2__TermType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TermType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TermType(struct soap *soap, const char *tag, int id, ns2__TermType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TermType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TermType ** SOAP_FMAC4 soap_in_PointerTons2__TermType(struct soap *soap, const char *tag, ns2__TermType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TermType **)soap_malloc(soap, sizeof(ns2__TermType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TermType *)soap_instantiate_ns2__TermType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__TermType ** p = (ns2__TermType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TermType, sizeof(ns2__TermType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TermType(struct soap *soap, ns2__TermType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TermType);
	if (soap_out_PointerTons2__TermType(soap, tag?tag:"ns2:TermType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TermType ** SOAP_FMAC4 soap_get_PointerTons2__TermType(struct soap *soap, ns2__TermType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TermType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConfigurationType(struct soap *soap, ns2__ConfigurationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConfigurationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConfigurationType(struct soap *soap, const char *tag, int id, ns2__ConfigurationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConfigurationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ConfigurationType ** SOAP_FMAC4 soap_in_PointerTons2__ConfigurationType(struct soap *soap, const char *tag, ns2__ConfigurationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ConfigurationType **)soap_malloc(soap, sizeof(ns2__ConfigurationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ConfigurationType *)soap_instantiate_ns2__ConfigurationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ConfigurationType ** p = (ns2__ConfigurationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConfigurationType, sizeof(ns2__ConfigurationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConfigurationType(struct soap *soap, ns2__ConfigurationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConfigurationType);
	if (soap_out_PointerTons2__ConfigurationType(soap, tag?tag:"ns2:ConfigurationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ConfigurationType ** SOAP_FMAC4 soap_get_PointerTons2__ConfigurationType(struct soap *soap, ns2__ConfigurationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConfigurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IonStateType(struct soap *soap, ns2__IonStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IonStateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IonStateType(struct soap *soap, const char *tag, int id, ns2__IonStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IonStateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__IonStateType ** SOAP_FMAC4 soap_in_PointerTons2__IonStateType(struct soap *soap, const char *tag, ns2__IonStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__IonStateType **)soap_malloc(soap, sizeof(ns2__IonStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__IonStateType *)soap_instantiate_ns2__IonStateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__IonStateType ** p = (ns2__IonStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IonStateType, sizeof(ns2__IonStateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IonStateType(struct soap *soap, ns2__IonStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IonStateType);
	if (soap_out_PointerTons2__IonStateType(soap, tag?tag:"ns2:IonStateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__IonStateType ** SOAP_FMAC4 soap_get_PointerTons2__IonStateType(struct soap *soap, ns2__IonStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IonStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IsotopeParametersType(struct soap *soap, ns2__IsotopeParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IsotopeParametersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IsotopeParametersType(struct soap *soap, const char *tag, int id, ns2__IsotopeParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IsotopeParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__IsotopeParametersType ** SOAP_FMAC4 soap_in_PointerTons2__IsotopeParametersType(struct soap *soap, const char *tag, ns2__IsotopeParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__IsotopeParametersType **)soap_malloc(soap, sizeof(ns2__IsotopeParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__IsotopeParametersType *)soap_instantiate_ns2__IsotopeParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__IsotopeParametersType ** p = (ns2__IsotopeParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IsotopeParametersType, sizeof(ns2__IsotopeParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IsotopeParametersType(struct soap *soap, ns2__IsotopeParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IsotopeParametersType);
	if (soap_out_PointerTons2__IsotopeParametersType(soap, tag?tag:"ns2:IsotopeParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__IsotopeParametersType ** SOAP_FMAC4 soap_get_PointerTons2__IsotopeParametersType(struct soap *soap, ns2__IsotopeParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IsotopeParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FunctionType(struct soap *soap, ns2__FunctionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FunctionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FunctionType(struct soap *soap, const char *tag, int id, ns2__FunctionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FunctionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FunctionType ** SOAP_FMAC4 soap_in_PointerTons2__FunctionType(struct soap *soap, const char *tag, ns2__FunctionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FunctionType **)soap_malloc(soap, sizeof(ns2__FunctionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FunctionType *)soap_instantiate_ns2__FunctionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FunctionType ** p = (ns2__FunctionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FunctionType, sizeof(ns2__FunctionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FunctionType(struct soap *soap, ns2__FunctionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FunctionType);
	if (soap_out_PointerTons2__FunctionType(soap, tag?tag:"ns2:FunctionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FunctionType ** SOAP_FMAC4 soap_get_PointerTons2__FunctionType(struct soap *soap, ns2__FunctionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FunctionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__functionRef(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__functionRef))
		soap_serialize__ns2__functionRef(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__functionRef(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__functionRef);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__functionRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_ns2__functionRef(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__functionRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__functionRef, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__functionRef(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__functionRef);
	if (soap_out_PointerTo_ns2__functionRef(soap, tag?tag:"ns2:functionRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_ns2__functionRef(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__functionRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MethodType(struct soap *soap, ns2__MethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MethodType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MethodType(struct soap *soap, const char *tag, int id, ns2__MethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MethodType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MethodType ** SOAP_FMAC4 soap_in_PointerTons2__MethodType(struct soap *soap, const char *tag, ns2__MethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MethodType **)soap_malloc(soap, sizeof(ns2__MethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MethodType *)soap_instantiate_ns2__MethodType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MethodType ** p = (ns2__MethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MethodType, sizeof(ns2__MethodType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MethodType(struct soap *soap, ns2__MethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MethodType);
	if (soap_out_PointerTons2__MethodType(soap, tag?tag:"ns2:MethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MethodType ** SOAP_FMAC4 soap_get_PointerTons2__MethodType(struct soap *soap, ns2__MethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AuthorType(struct soap *soap, ns2__AuthorType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AuthorType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AuthorType(struct soap *soap, const char *tag, int id, ns2__AuthorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AuthorType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AuthorType ** SOAP_FMAC4 soap_in_PointerTons2__AuthorType(struct soap *soap, const char *tag, ns2__AuthorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AuthorType **)soap_malloc(soap, sizeof(ns2__AuthorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AuthorType *)soap_instantiate_ns2__AuthorType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AuthorType ** p = (ns2__AuthorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AuthorType, sizeof(ns2__AuthorType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AuthorType(struct soap *soap, ns2__AuthorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AuthorType);
	if (soap_out_PointerTons2__AuthorType(soap, tag?tag:"ns2:AuthorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AuthorType ** SOAP_FMAC4 soap_get_PointerTons2__AuthorType(struct soap *soap, ns2__AuthorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AuthorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__date(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__date))
		soap_serialize_xsd__date(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__date(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__date);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__date(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__date(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__date, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__date(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__date);
	if (soap_out_PointerToxsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__date(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EditorsType(struct soap *soap, ns2__EditorsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EditorsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EditorsType(struct soap *soap, const char *tag, int id, ns2__EditorsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EditorsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EditorsType ** SOAP_FMAC4 soap_in_PointerTons2__EditorsType(struct soap *soap, const char *tag, ns2__EditorsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EditorsType **)soap_malloc(soap, sizeof(ns2__EditorsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EditorsType *)soap_instantiate_ns2__EditorsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EditorsType ** p = (ns2__EditorsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EditorsType, sizeof(ns2__EditorsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EditorsType(struct soap *soap, ns2__EditorsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EditorsType);
	if (soap_out_PointerTons2__EditorsType(soap, tag?tag:"ns2:EditorsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EditorsType ** SOAP_FMAC4 soap_get_PointerTons2__EditorsType(struct soap *soap, ns2__EditorsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EditorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__token);
	if (soap_out_PointerToxsd__token(soap, tag?tag:"xsd:token", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AuthorsType(struct soap *soap, ns2__AuthorsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AuthorsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AuthorsType(struct soap *soap, const char *tag, int id, ns2__AuthorsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AuthorsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AuthorsType ** SOAP_FMAC4 soap_in_PointerTons2__AuthorsType(struct soap *soap, const char *tag, ns2__AuthorsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AuthorsType **)soap_malloc(soap, sizeof(ns2__AuthorsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AuthorsType *)soap_instantiate_ns2__AuthorsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AuthorsType ** p = (ns2__AuthorsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AuthorsType, sizeof(ns2__AuthorsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AuthorsType(struct soap *soap, ns2__AuthorsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AuthorsType);
	if (soap_out_PointerTons2__AuthorsType(soap, tag?tag:"ns2:AuthorsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AuthorsType ** SOAP_FMAC4 soap_get_PointerTons2__AuthorsType(struct soap *soap, ns2__AuthorsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AuthorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SourceType(struct soap *soap, ns2__SourceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SourceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SourceType(struct soap *soap, const char *tag, int id, ns2__SourceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SourceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SourceType ** SOAP_FMAC4 soap_in_PointerTons2__SourceType(struct soap *soap, const char *tag, ns2__SourceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SourceType **)soap_malloc(soap, sizeof(ns2__SourceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SourceType *)soap_instantiate_ns2__SourceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SourceType ** p = (ns2__SourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SourceType, sizeof(ns2__SourceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SourceType(struct soap *soap, ns2__SourceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SourceType);
	if (soap_out_PointerTons2__SourceType(soap, tag?tag:"ns2:SourceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SourceType ** SOAP_FMAC4 soap_get_PointerTons2__SourceType(struct soap *soap, ns2__SourceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LKCouplingType(struct soap *soap, ns2__LKCouplingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LKCouplingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LKCouplingType(struct soap *soap, const char *tag, int id, ns2__LKCouplingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LKCouplingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LKCouplingType ** SOAP_FMAC4 soap_in_PointerTons2__LKCouplingType(struct soap *soap, const char *tag, ns2__LKCouplingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LKCouplingType **)soap_malloc(soap, sizeof(ns2__LKCouplingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LKCouplingType *)soap_instantiate_ns2__LKCouplingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LKCouplingType ** p = (ns2__LKCouplingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LKCouplingType, sizeof(ns2__LKCouplingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LKCouplingType(struct soap *soap, ns2__LKCouplingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LKCouplingType);
	if (soap_out_PointerTons2__LKCouplingType(soap, tag?tag:"ns2:LKCouplingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LKCouplingType ** SOAP_FMAC4 soap_get_PointerTons2__LKCouplingType(struct soap *soap, ns2__LKCouplingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LKCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__jKCouplingType(struct soap *soap, ns2__jKCouplingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__jKCouplingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__jKCouplingType(struct soap *soap, const char *tag, int id, ns2__jKCouplingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__jKCouplingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__jKCouplingType ** SOAP_FMAC4 soap_in_PointerTons2__jKCouplingType(struct soap *soap, const char *tag, ns2__jKCouplingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__jKCouplingType **)soap_malloc(soap, sizeof(ns2__jKCouplingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__jKCouplingType *)soap_instantiate_ns2__jKCouplingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__jKCouplingType ** p = (ns2__jKCouplingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__jKCouplingType, sizeof(ns2__jKCouplingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__jKCouplingType(struct soap *soap, ns2__jKCouplingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__jKCouplingType);
	if (soap_out_PointerTons2__jKCouplingType(soap, tag?tag:"ns2:jKCouplingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__jKCouplingType ** SOAP_FMAC4 soap_get_PointerTons2__jKCouplingType(struct soap *soap, ns2__jKCouplingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__jKCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__jjCouplingType(struct soap *soap, ns2__jjCouplingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__jjCouplingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__jjCouplingType(struct soap *soap, const char *tag, int id, ns2__jjCouplingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__jjCouplingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__jjCouplingType ** SOAP_FMAC4 soap_in_PointerTons2__jjCouplingType(struct soap *soap, const char *tag, ns2__jjCouplingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__jjCouplingType **)soap_malloc(soap, sizeof(ns2__jjCouplingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__jjCouplingType *)soap_instantiate_ns2__jjCouplingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__jjCouplingType ** p = (ns2__jjCouplingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__jjCouplingType, sizeof(ns2__jjCouplingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__jjCouplingType(struct soap *soap, ns2__jjCouplingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__jjCouplingType);
	if (soap_out_PointerTons2__jjCouplingType(soap, tag?tag:"ns2:jjCouplingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__jjCouplingType ** SOAP_FMAC4 soap_get_PointerTons2__jjCouplingType(struct soap *soap, ns2__jjCouplingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__jjCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LSCouplingType(struct soap *soap, ns2__LSCouplingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LSCouplingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LSCouplingType(struct soap *soap, const char *tag, int id, ns2__LSCouplingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LSCouplingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LSCouplingType ** SOAP_FMAC4 soap_in_PointerTons2__LSCouplingType(struct soap *soap, const char *tag, ns2__LSCouplingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LSCouplingType **)soap_malloc(soap, sizeof(ns2__LSCouplingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LSCouplingType *)soap_instantiate_ns2__LSCouplingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LSCouplingType ** p = (ns2__LSCouplingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LSCouplingType, sizeof(ns2__LSCouplingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LSCouplingType(struct soap *soap, ns2__LSCouplingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LSCouplingType);
	if (soap_out_PointerTons2__LSCouplingType(soap, tag?tag:"ns2:LSCouplingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LSCouplingType ** SOAP_FMAC4 soap_get_PointerTons2__LSCouplingType(struct soap *soap, ns2__LSCouplingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LSCouplingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OrbitalAngularMomentumSymbolType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType))
		soap_serialize_ns2__OrbitalAngularMomentumSymbolType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OrbitalAngularMomentumSymbolType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__OrbitalAngularMomentumSymbolType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__OrbitalAngularMomentumSymbolType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__OrbitalAngularMomentumSymbolType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OrbitalAngularMomentumSymbolType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OrbitalAngularMomentumSymbolType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OrbitalAngularMomentumSymbolType);
	if (soap_out_PointerTons2__OrbitalAngularMomentumSymbolType(soap, tag?tag:"ns2:OrbitalAngularMomentumSymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__OrbitalAngularMomentumSymbolType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OrbitalAngularMomentumSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__LSCouplingType_Seniority(struct soap *soap, _ns2__LSCouplingType_Seniority *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__LSCouplingType_Seniority))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__LSCouplingType_Seniority(struct soap *soap, const char *tag, int id, _ns2__LSCouplingType_Seniority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__LSCouplingType_Seniority);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__LSCouplingType_Seniority ** SOAP_FMAC4 soap_in_PointerTo_ns2__LSCouplingType_Seniority(struct soap *soap, const char *tag, _ns2__LSCouplingType_Seniority **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__LSCouplingType_Seniority **)soap_malloc(soap, sizeof(_ns2__LSCouplingType_Seniority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__LSCouplingType_Seniority *)soap_instantiate__ns2__LSCouplingType_Seniority(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__LSCouplingType_Seniority ** p = (_ns2__LSCouplingType_Seniority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__LSCouplingType_Seniority, sizeof(_ns2__LSCouplingType_Seniority), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__LSCouplingType_Seniority(struct soap *soap, _ns2__LSCouplingType_Seniority *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__LSCouplingType_Seniority);
	if (soap_out_PointerTo_ns2__LSCouplingType_Seniority(soap, tag?tag:"ns2:LSCouplingType-Seniority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__LSCouplingType_Seniority ** SOAP_FMAC4 soap_get_PointerTo_ns2__LSCouplingType_Seniority(struct soap *soap, _ns2__LSCouplingType_Seniority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__LSCouplingType_Seniority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__positiveInteger(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__positiveInteger))
		soap_serialize_xsd__positiveInteger(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__positiveInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__positiveInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__positiveInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__positiveInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__positiveInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__positiveInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__positiveInteger);
	if (soap_out_PointerToxsd__positiveInteger(soap, tag?tag:"xsd:positiveInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__positiveInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OrbitalAngularMomentumType(struct soap *soap, ns2__OrbitalAngularMomentumType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OrbitalAngularMomentumType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OrbitalAngularMomentumType(struct soap *soap, const char *tag, int id, ns2__OrbitalAngularMomentumType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OrbitalAngularMomentumType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OrbitalAngularMomentumType ** SOAP_FMAC4 soap_in_PointerTons2__OrbitalAngularMomentumType(struct soap *soap, const char *tag, ns2__OrbitalAngularMomentumType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OrbitalAngularMomentumType **)soap_malloc(soap, sizeof(ns2__OrbitalAngularMomentumType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OrbitalAngularMomentumType *)soap_instantiate_ns2__OrbitalAngularMomentumType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OrbitalAngularMomentumType ** p = (ns2__OrbitalAngularMomentumType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OrbitalAngularMomentumType, sizeof(ns2__OrbitalAngularMomentumType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OrbitalAngularMomentumType(struct soap *soap, ns2__OrbitalAngularMomentumType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OrbitalAngularMomentumType);
	if (soap_out_PointerTons2__OrbitalAngularMomentumType(soap, tag?tag:"ns2:OrbitalAngularMomentumType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OrbitalAngularMomentumType ** SOAP_FMAC4 soap_get_PointerTons2__OrbitalAngularMomentumType(struct soap *soap, ns2__OrbitalAngularMomentumType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OrbitalAngularMomentumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AngularMomentumType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AngularMomentumType))
		soap_serialize_ns2__AngularMomentumType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AngularMomentumType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AngularMomentumType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AngularMomentumType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__AngularMomentumType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AngularMomentumType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AngularMomentumType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AngularMomentumType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AngularMomentumType);
	if (soap_out_PointerTons2__AngularMomentumType(soap, tag?tag:"ns2:AngularMomentumType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__AngularMomentumType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AngularMomentumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParameterType(struct soap *soap, ns2__ParameterType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParameterType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParameterType(struct soap *soap, const char *tag, int id, ns2__ParameterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParameterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParameterType ** SOAP_FMAC4 soap_in_PointerTons2__ParameterType(struct soap *soap, const char *tag, ns2__ParameterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParameterType **)soap_malloc(soap, sizeof(ns2__ParameterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParameterType *)soap_instantiate_ns2__ParameterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParameterType ** p = (ns2__ParameterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParameterType, sizeof(ns2__ParameterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParameterType(struct soap *soap, ns2__ParameterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParameterType);
	if (soap_out_PointerTons2__ParameterType(soap, tag?tag:"ns2:ParameterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParameterType ** SOAP_FMAC4 soap_get_PointerTons2__ParameterType(struct soap *soap, ns2__ParameterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArgumentType(struct soap *soap, ns2__ArgumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArgumentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArgumentType(struct soap *soap, const char *tag, int id, ns2__ArgumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArgumentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArgumentType ** SOAP_FMAC4 soap_in_PointerTons2__ArgumentType(struct soap *soap, const char *tag, ns2__ArgumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArgumentType **)soap_malloc(soap, sizeof(ns2__ArgumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArgumentType *)soap_instantiate_ns2__ArgumentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ArgumentType ** p = (ns2__ArgumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArgumentType, sizeof(ns2__ArgumentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArgumentType(struct soap *soap, ns2__ArgumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArgumentType);
	if (soap_out_PointerTons2__ArgumentType(soap, tag?tag:"ns2:ArgumentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ArgumentType ** SOAP_FMAC4 soap_get_PointerTons2__ArgumentType(struct soap *soap, ns2__ArgumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArgumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataTableType(struct soap *soap, ns2__DataTableType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataTableType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataTableType(struct soap *soap, const char *tag, int id, ns2__DataTableType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataTableType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DataTableType ** SOAP_FMAC4 soap_in_PointerTons2__DataTableType(struct soap *soap, const char *tag, ns2__DataTableType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DataTableType **)soap_malloc(soap, sizeof(ns2__DataTableType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DataTableType *)soap_instantiate_ns2__DataTableType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DataTableType ** p = (ns2__DataTableType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataTableType, sizeof(ns2__DataTableType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataTableType(struct soap *soap, ns2__DataTableType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataTableType);
	if (soap_out_PointerTons2__DataTableType(soap, tag?tag:"ns2:DataTableType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DataTableType ** SOAP_FMAC4 soap_get_PointerTons2__DataTableType(struct soap *soap, ns2__DataTableType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataTableType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataListType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataListType))
		soap_serialize_ns2__DataListType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataListType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataListType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DataListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__DataListType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DataListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataListType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataListType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataListType);
	if (soap_out_PointerTons2__DataListType(soap, tag?tag:"ns2:DataListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__DataListType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataSetType(struct soap *soap, ns2__DataSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataSetType(struct soap *soap, const char *tag, int id, ns2__DataSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DataSetType ** SOAP_FMAC4 soap_in_PointerTons2__DataSetType(struct soap *soap, const char *tag, ns2__DataSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DataSetType **)soap_malloc(soap, sizeof(ns2__DataSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DataSetType *)soap_instantiate_ns2__DataSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DataSetType ** p = (ns2__DataSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataSetType, sizeof(ns2__DataSetType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataSetType(struct soap *soap, ns2__DataSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataSetType);
	if (soap_out_PointerTons2__DataSetType(soap, tag?tag:"ns2:DataSetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DataSetType ** SOAP_FMAC4 soap_get_PointerTons2__DataSetType(struct soap *soap, ns2__DataSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ElementSymbolType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ElementSymbolType))
		soap_serialize_ns2__ElementSymbolType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ElementSymbolType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ElementSymbolType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ElementSymbolType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__ElementSymbolType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ElementSymbolType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ElementSymbolType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ElementSymbolType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ElementSymbolType);
	if (soap_out_PointerTons2__ElementSymbolType(soap, tag?tag:"ns2:ElementSymbolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__ElementSymbolType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ElementSymbolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__methodRef(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__methodRef))
		soap_serialize__ns2__methodRef(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__methodRef(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__methodRef);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__methodRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_ns2__methodRef(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__methodRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__methodRef, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__methodRef(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__methodRef);
	if (soap_out_PointerTo_ns2__methodRef(soap, tag?tag:"ns2:methodRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_ns2__methodRef(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__methodRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__sourceRef(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__sourceRef))
		soap_serialize__ns2__sourceRef(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__sourceRef(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__sourceRef);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__sourceRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_ns2__sourceRef(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__sourceRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__sourceRef, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__sourceRef(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__sourceRef);
	if (soap_out_PointerTo_ns2__sourceRef(soap, tag?tag:"ns2:sourceRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_ns2__sourceRef(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__sourceRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(struct soap *soap, std::vector<ns2__CollisionalTransitionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(struct soap *soap, const std::vector<ns2__CollisionalTransitionType * >*a)
{
	for (std::vector<ns2__CollisionalTransitionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__CollisionalTransitionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(struct soap *soap, const char *tag, int id, const std::vector<ns2__CollisionalTransitionType * >*a, const char *type)
{
	for (std::vector<ns2__CollisionalTransitionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__CollisionalTransitionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__CollisionalTransitionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(struct soap *soap, const char *tag, std::vector<ns2__CollisionalTransitionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(soap, -1)))
		return NULL;
	ns2__CollisionalTransitionType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__CollisionalTransitionType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__CollisionalTransitionType, sizeof(ns2__CollisionalTransitionType), 1))
				break;
			if (!soap_in_PointerTons2__CollisionalTransitionType(soap, tag, NULL, "ns2:CollisionalTransitionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__CollisionalTransitionType(soap, tag, &n, "ns2:CollisionalTransitionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__CollisionalTransitionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__CollisionalTransitionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__CollisionalTransitionType * >);
		if (size)
			*size = sizeof(std::vector<ns2__CollisionalTransitionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__CollisionalTransitionType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__CollisionalTransitionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__CollisionalTransitionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__CollisionalTransitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__CollisionalTransitionType * > %p -> %p\n", q, p));
	*(std::vector<ns2__CollisionalTransitionType * >*)p = *(std::vector<ns2__CollisionalTransitionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(struct soap *soap, std::vector<ns2__NonRadiativeTransitionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(struct soap *soap, const std::vector<ns2__NonRadiativeTransitionType * >*a)
{
	for (std::vector<ns2__NonRadiativeTransitionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__NonRadiativeTransitionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(struct soap *soap, const char *tag, int id, const std::vector<ns2__NonRadiativeTransitionType * >*a, const char *type)
{
	for (std::vector<ns2__NonRadiativeTransitionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__NonRadiativeTransitionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__NonRadiativeTransitionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(struct soap *soap, const char *tag, std::vector<ns2__NonRadiativeTransitionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(soap, -1)))
		return NULL;
	ns2__NonRadiativeTransitionType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__NonRadiativeTransitionType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType, sizeof(ns2__NonRadiativeTransitionType), 1))
				break;
			if (!soap_in_PointerTons2__NonRadiativeTransitionType(soap, tag, NULL, "ns2:NonRadiativeTransitionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__NonRadiativeTransitionType(soap, tag, &n, "ns2:NonRadiativeTransitionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__NonRadiativeTransitionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__NonRadiativeTransitionType * >);
		if (size)
			*size = sizeof(std::vector<ns2__NonRadiativeTransitionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__NonRadiativeTransitionType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__NonRadiativeTransitionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__NonRadiativeTransitionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__NonRadiativeTransitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__NonRadiativeTransitionType * > %p -> %p\n", q, p));
	*(std::vector<ns2__NonRadiativeTransitionType * >*)p = *(std::vector<ns2__NonRadiativeTransitionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, std::vector<ns2__RadiativeTransitionProbabilityType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, const std::vector<ns2__RadiativeTransitionProbabilityType * >*a)
{
	for (std::vector<ns2__RadiativeTransitionProbabilityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__RadiativeTransitionProbabilityType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, const char *tag, int id, const std::vector<ns2__RadiativeTransitionProbabilityType * >*a, const char *type)
{
	for (std::vector<ns2__RadiativeTransitionProbabilityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__RadiativeTransitionProbabilityType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__RadiativeTransitionProbabilityType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, const char *tag, std::vector<ns2__RadiativeTransitionProbabilityType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(soap, -1)))
		return NULL;
	ns2__RadiativeTransitionProbabilityType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RadiativeTransitionProbabilityType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType, sizeof(ns2__RadiativeTransitionProbabilityType), 1))
				break;
			if (!soap_in_PointerTons2__RadiativeTransitionProbabilityType(soap, tag, NULL, "ns2:RadiativeTransitionProbabilityType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__RadiativeTransitionProbabilityType(soap, tag, &n, "ns2:RadiativeTransitionProbabilityType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__RadiativeTransitionProbabilityType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RadiativeTransitionProbabilityType * >);
		if (size)
			*size = sizeof(std::vector<ns2__RadiativeTransitionProbabilityType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RadiativeTransitionProbabilityType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__RadiativeTransitionProbabilityType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__RadiativeTransitionProbabilityType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__RadiativeTransitionProbabilityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__RadiativeTransitionProbabilityType * > %p -> %p\n", q, p));
	*(std::vector<ns2__RadiativeTransitionProbabilityType * >*)p = *(std::vector<ns2__RadiativeTransitionProbabilityType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(struct soap *soap, std::vector<ns2__RadiativeTransitionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(struct soap *soap, const std::vector<ns2__RadiativeTransitionType * >*a)
{
	for (std::vector<ns2__RadiativeTransitionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__RadiativeTransitionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(struct soap *soap, const char *tag, int id, const std::vector<ns2__RadiativeTransitionType * >*a, const char *type)
{
	for (std::vector<ns2__RadiativeTransitionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__RadiativeTransitionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__RadiativeTransitionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(struct soap *soap, const char *tag, std::vector<ns2__RadiativeTransitionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(soap, -1)))
		return NULL;
	ns2__RadiativeTransitionType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RadiativeTransitionType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionType, sizeof(ns2__RadiativeTransitionType), 1))
				break;
			if (!soap_in_PointerTons2__RadiativeTransitionType(soap, tag, NULL, "ns2:RadiativeTransitionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__RadiativeTransitionType(soap, tag, &n, "ns2:RadiativeTransitionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__RadiativeTransitionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RadiativeTransitionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RadiativeTransitionType * >);
		if (size)
			*size = sizeof(std::vector<ns2__RadiativeTransitionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RadiativeTransitionType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__RadiativeTransitionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__RadiativeTransitionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__RadiativeTransitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__RadiativeTransitionType * > %p -> %p\n", q, p));
	*(std::vector<ns2__RadiativeTransitionType * >*)p = *(std::vector<ns2__RadiativeTransitionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MaterialComponentType(struct soap *soap, std::vector<ns2__MaterialComponentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MaterialComponentType(struct soap *soap, const std::vector<ns2__MaterialComponentType * >*a)
{
	for (std::vector<ns2__MaterialComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MaterialComponentType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MaterialComponentType(struct soap *soap, const char *tag, int id, const std::vector<ns2__MaterialComponentType * >*a, const char *type)
{
	for (std::vector<ns2__MaterialComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MaterialComponentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MaterialComponentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MaterialComponentType(struct soap *soap, const char *tag, std::vector<ns2__MaterialComponentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MaterialComponentType(soap, -1)))
		return NULL;
	ns2__MaterialComponentType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MaterialComponentType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialComponentType, sizeof(ns2__MaterialComponentType), 1))
				break;
			if (!soap_in_PointerTons2__MaterialComponentType(soap, tag, NULL, "ns2:MaterialComponentType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__MaterialComponentType(soap, tag, &n, "ns2:MaterialComponentType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MaterialComponentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MaterialComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MaterialComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MaterialComponentType * >);
		if (size)
			*size = sizeof(std::vector<ns2__MaterialComponentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MaterialComponentType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__MaterialComponentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__MaterialComponentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MaterialComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MaterialComponentType * > %p -> %p\n", q, p));
	*(std::vector<ns2__MaterialComponentType * >*)p = *(std::vector<ns2__MaterialComponentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__SolidType(struct soap *soap, std::vector<ns2__SolidType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__SolidType(struct soap *soap, const std::vector<ns2__SolidType * >*a)
{
	for (std::vector<ns2__SolidType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__SolidType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__SolidType(struct soap *soap, const char *tag, int id, const std::vector<ns2__SolidType * >*a, const char *type)
{
	for (std::vector<ns2__SolidType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__SolidType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__SolidType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__SolidType(struct soap *soap, const char *tag, std::vector<ns2__SolidType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__SolidType(soap, -1)))
		return NULL;
	ns2__SolidType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__SolidType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SolidType, sizeof(ns2__SolidType), 1))
				break;
			if (!soap_in_PointerTons2__SolidType(soap, tag, NULL, "ns2:SolidType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__SolidType(soap, tag, &n, "ns2:SolidType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__SolidType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__SolidType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__SolidType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SolidType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SolidType * >);
		if (size)
			*size = sizeof(std::vector<ns2__SolidType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SolidType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__SolidType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__SolidType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__SolidType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__SolidType * > %p -> %p\n", q, p));
	*(std::vector<ns2__SolidType * >*)p = *(std::vector<ns2__SolidType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MaterialType(struct soap *soap, std::vector<ns2__MaterialType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MaterialType(struct soap *soap, const std::vector<ns2__MaterialType * >*a)
{
	for (std::vector<ns2__MaterialType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MaterialType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MaterialType(struct soap *soap, const char *tag, int id, const std::vector<ns2__MaterialType * >*a, const char *type)
{
	for (std::vector<ns2__MaterialType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MaterialType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MaterialType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MaterialType(struct soap *soap, const char *tag, std::vector<ns2__MaterialType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MaterialType(soap, -1)))
		return NULL;
	ns2__MaterialType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MaterialType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialType, sizeof(ns2__MaterialType), 1))
				break;
			if (!soap_in_PointerTons2__MaterialType(soap, tag, NULL, "ns2:MaterialType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__MaterialType(soap, tag, &n, "ns2:MaterialType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MaterialType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MaterialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MaterialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MaterialType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MaterialType * >);
		if (size)
			*size = sizeof(std::vector<ns2__MaterialType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MaterialType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__MaterialType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__MaterialType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MaterialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MaterialType * > %p -> %p\n", q, p));
	*(std::vector<ns2__MaterialType * >*)p = *(std::vector<ns2__MaterialType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__SimpleSymbolType(struct soap *soap, std::vector<ns2__SimpleSymbolType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__SimpleSymbolType(struct soap *soap, const std::vector<ns2__SimpleSymbolType * >*a)
{
	for (std::vector<ns2__SimpleSymbolType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__SimpleSymbolType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__SimpleSymbolType(struct soap *soap, const char *tag, int id, const std::vector<ns2__SimpleSymbolType * >*a, const char *type)
{
	for (std::vector<ns2__SimpleSymbolType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__SimpleSymbolType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__SimpleSymbolType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__SimpleSymbolType(struct soap *soap, const char *tag, std::vector<ns2__SimpleSymbolType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__SimpleSymbolType(soap, -1)))
		return NULL;
	ns2__SimpleSymbolType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__SimpleSymbolType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SimpleSymbolType, sizeof(ns2__SimpleSymbolType), 1))
				break;
			if (!soap_in_PointerTons2__SimpleSymbolType(soap, tag, NULL, "ns2:SimpleSymbolType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__SimpleSymbolType(soap, tag, &n, "ns2:SimpleSymbolType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__SimpleSymbolType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__SimpleSymbolType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__SimpleSymbolType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SimpleSymbolType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SimpleSymbolType * >);
		if (size)
			*size = sizeof(std::vector<ns2__SimpleSymbolType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SimpleSymbolType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__SimpleSymbolType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__SimpleSymbolType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__SimpleSymbolType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__SimpleSymbolType * > %p -> %p\n", q, p));
	*(std::vector<ns2__SimpleSymbolType * >*)p = *(std::vector<ns2__SimpleSymbolType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(struct soap *soap, std::vector<__ns2__RoVibronicSplittingType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(struct soap *soap, const std::vector<__ns2__RoVibronicSplittingType_sequence >*a)
{
	for (std::vector<__ns2__RoVibronicSplittingType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__RoVibronicSplittingType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__RoVibronicSplittingType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__RoVibronicSplittingType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__RoVibronicSplittingType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(soap, -1)))
		return NULL;
	__ns2__RoVibronicSplittingType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__RoVibronicSplittingType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence, sizeof(__ns2__RoVibronicSplittingType_sequence), 0))
				break;
			if (!soap_in___ns2__RoVibronicSplittingType_sequence(soap, tag, NULL, "-ns2:RoVibronicSplittingType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__RoVibronicSplittingType_sequence(soap, tag, &n, "-ns2:RoVibronicSplittingType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__RoVibronicSplittingType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__RoVibronicSplittingType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__RoVibronicSplittingType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__RoVibronicSplittingType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__RoVibronicSplittingType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__RoVibronicSplittingType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__RoVibronicSplittingType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__RoVibronicSplittingType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__RoVibronicSplittingType_sequence >*)p = *(std::vector<__ns2__RoVibronicSplittingType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MoleculeType(struct soap *soap, std::vector<ns2__MoleculeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MoleculeType(struct soap *soap, const std::vector<ns2__MoleculeType * >*a)
{
	for (std::vector<ns2__MoleculeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MoleculeType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MoleculeType(struct soap *soap, const char *tag, int id, const std::vector<ns2__MoleculeType * >*a, const char *type)
{
	for (std::vector<ns2__MoleculeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MoleculeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MoleculeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MoleculeType(struct soap *soap, const char *tag, std::vector<ns2__MoleculeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MoleculeType(soap, -1)))
		return NULL;
	ns2__MoleculeType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MoleculeType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MoleculeType, sizeof(ns2__MoleculeType), 1))
				break;
			if (!soap_in_PointerTons2__MoleculeType(soap, tag, NULL, "ns2:MoleculeType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__MoleculeType(soap, tag, &n, "ns2:MoleculeType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MoleculeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MoleculeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MoleculeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MoleculeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MoleculeType * >);
		if (size)
			*size = sizeof(std::vector<ns2__MoleculeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MoleculeType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__MoleculeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__MoleculeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MoleculeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MoleculeType * > %p -> %p\n", q, p));
	*(std::vector<ns2__MoleculeType * >*)p = *(std::vector<ns2__MoleculeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MolecularStateType(struct soap *soap, std::vector<ns2__MolecularStateType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MolecularStateType(struct soap *soap, const std::vector<ns2__MolecularStateType * >*a)
{
	for (std::vector<ns2__MolecularStateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MolecularStateType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MolecularStateType(struct soap *soap, const char *tag, int id, const std::vector<ns2__MolecularStateType * >*a, const char *type)
{
	for (std::vector<ns2__MolecularStateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MolecularStateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MolecularStateType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MolecularStateType(struct soap *soap, const char *tag, std::vector<ns2__MolecularStateType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MolecularStateType(soap, -1)))
		return NULL;
	ns2__MolecularStateType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MolecularStateType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MolecularStateType, sizeof(ns2__MolecularStateType), 1))
				break;
			if (!soap_in_PointerTons2__MolecularStateType(soap, tag, NULL, "ns2:MolecularStateType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__MolecularStateType(soap, tag, &n, "ns2:MolecularStateType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MolecularStateType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MolecularStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MolecularStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MolecularStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MolecularStateType * >);
		if (size)
			*size = sizeof(std::vector<ns2__MolecularStateType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MolecularStateType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__MolecularStateType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__MolecularStateType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MolecularStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MolecularStateType * > %p -> %p\n", q, p));
	*(std::vector<ns2__MolecularStateType * >*)p = *(std::vector<ns2__MolecularStateType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__AtomicComponentType(struct soap *soap, std::vector<ns2__AtomicComponentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__AtomicComponentType(struct soap *soap, const std::vector<ns2__AtomicComponentType * >*a)
{
	for (std::vector<ns2__AtomicComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__AtomicComponentType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__AtomicComponentType(struct soap *soap, const char *tag, int id, const std::vector<ns2__AtomicComponentType * >*a, const char *type)
{
	for (std::vector<ns2__AtomicComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__AtomicComponentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__AtomicComponentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__AtomicComponentType(struct soap *soap, const char *tag, std::vector<ns2__AtomicComponentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__AtomicComponentType(soap, -1)))
		return NULL;
	ns2__AtomicComponentType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AtomicComponentType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicComponentType, sizeof(ns2__AtomicComponentType), 1))
				break;
			if (!soap_in_PointerTons2__AtomicComponentType(soap, tag, NULL, "ns2:AtomicComponentType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__AtomicComponentType(soap, tag, &n, "ns2:AtomicComponentType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__AtomicComponentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__AtomicComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__AtomicComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AtomicComponentType * >);
		if (size)
			*size = sizeof(std::vector<ns2__AtomicComponentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AtomicComponentType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__AtomicComponentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__AtomicComponentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__AtomicComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__AtomicComponentType * > %p -> %p\n", q, p));
	*(std::vector<ns2__AtomicComponentType * >*)p = *(std::vector<ns2__AtomicComponentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__AtomicStateType(struct soap *soap, std::vector<ns2__AtomicStateType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__AtomicStateType(struct soap *soap, const std::vector<ns2__AtomicStateType * >*a)
{
	for (std::vector<ns2__AtomicStateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__AtomicStateType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__AtomicStateType(struct soap *soap, const char *tag, int id, const std::vector<ns2__AtomicStateType * >*a, const char *type)
{
	for (std::vector<ns2__AtomicStateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__AtomicStateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__AtomicStateType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__AtomicStateType(struct soap *soap, const char *tag, std::vector<ns2__AtomicStateType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__AtomicStateType(soap, -1)))
		return NULL;
	ns2__AtomicStateType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AtomicStateType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicStateType, sizeof(ns2__AtomicStateType), 1))
				break;
			if (!soap_in_PointerTons2__AtomicStateType(soap, tag, NULL, "ns2:AtomicStateType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__AtomicStateType(soap, tag, &n, "ns2:AtomicStateType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__AtomicStateType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__AtomicStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__AtomicStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomicStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AtomicStateType * >);
		if (size)
			*size = sizeof(std::vector<ns2__AtomicStateType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AtomicStateType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__AtomicStateType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__AtomicStateType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__AtomicStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__AtomicStateType * > %p -> %p\n", q, p));
	*(std::vector<ns2__AtomicStateType * >*)p = *(std::vector<ns2__AtomicStateType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__IsotopeType(struct soap *soap, std::vector<ns2__IsotopeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__IsotopeType(struct soap *soap, const std::vector<ns2__IsotopeType * >*a)
{
	for (std::vector<ns2__IsotopeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__IsotopeType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__IsotopeType(struct soap *soap, const char *tag, int id, const std::vector<ns2__IsotopeType * >*a, const char *type)
{
	for (std::vector<ns2__IsotopeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__IsotopeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__IsotopeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__IsotopeType(struct soap *soap, const char *tag, std::vector<ns2__IsotopeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__IsotopeType(soap, -1)))
		return NULL;
	ns2__IsotopeType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__IsotopeType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__IsotopeType, sizeof(ns2__IsotopeType), 1))
				break;
			if (!soap_in_PointerTons2__IsotopeType(soap, tag, NULL, "ns2:IsotopeType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__IsotopeType(soap, tag, &n, "ns2:IsotopeType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__IsotopeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__IsotopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__IsotopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__IsotopeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__IsotopeType * >);
		if (size)
			*size = sizeof(std::vector<ns2__IsotopeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__IsotopeType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__IsotopeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__IsotopeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__IsotopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__IsotopeType * > %p -> %p\n", q, p));
	*(std::vector<ns2__IsotopeType * >*)p = *(std::vector<ns2__IsotopeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__AtomType(struct soap *soap, std::vector<ns2__AtomType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__AtomType(struct soap *soap, const std::vector<ns2__AtomType * >*a)
{
	for (std::vector<ns2__AtomType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__AtomType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__AtomType(struct soap *soap, const char *tag, int id, const std::vector<ns2__AtomType * >*a, const char *type)
{
	for (std::vector<ns2__AtomType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__AtomType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__AtomType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__AtomType(struct soap *soap, const char *tag, std::vector<ns2__AtomType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__AtomType(soap, -1)))
		return NULL;
	ns2__AtomType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AtomType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomType, sizeof(ns2__AtomType), 1))
				break;
			if (!soap_in_PointerTons2__AtomType(soap, tag, NULL, "ns2:AtomType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__AtomType(soap, tag, &n, "ns2:AtomType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__AtomType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__AtomType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__AtomType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AtomType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AtomType * >);
		if (size)
			*size = sizeof(std::vector<ns2__AtomType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AtomType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__AtomType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__AtomType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__AtomType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__AtomType * > %p -> %p\n", q, p));
	*(std::vector<ns2__AtomType * >*)p = *(std::vector<ns2__AtomType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(struct soap *soap, std::vector<ns2__FitValidityLimitsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(struct soap *soap, const std::vector<ns2__FitValidityLimitsType * >*a)
{
	for (std::vector<ns2__FitValidityLimitsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__FitValidityLimitsType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(struct soap *soap, const char *tag, int id, const std::vector<ns2__FitValidityLimitsType * >*a, const char *type)
{
	for (std::vector<ns2__FitValidityLimitsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__FitValidityLimitsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__FitValidityLimitsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(struct soap *soap, const char *tag, std::vector<ns2__FitValidityLimitsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(soap, -1)))
		return NULL;
	ns2__FitValidityLimitsType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__FitValidityLimitsType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitValidityLimitsType, sizeof(ns2__FitValidityLimitsType), 1))
				break;
			if (!soap_in_PointerTons2__FitValidityLimitsType(soap, tag, NULL, "ns2:FitValidityLimitsType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__FitValidityLimitsType(soap, tag, &n, "ns2:FitValidityLimitsType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__FitValidityLimitsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitValidityLimitsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FitValidityLimitsType * >);
		if (size)
			*size = sizeof(std::vector<ns2__FitValidityLimitsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FitValidityLimitsType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__FitValidityLimitsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__FitValidityLimitsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__FitValidityLimitsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__FitValidityLimitsType * > %p -> %p\n", q, p));
	*(std::vector<ns2__FitValidityLimitsType * >*)p = *(std::vector<ns2__FitValidityLimitsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__TabulatedDataType(struct soap *soap, std::vector<ns2__TabulatedDataType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__TabulatedDataType(struct soap *soap, const std::vector<ns2__TabulatedDataType * >*a)
{
	for (std::vector<ns2__TabulatedDataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__TabulatedDataType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__TabulatedDataType(struct soap *soap, const char *tag, int id, const std::vector<ns2__TabulatedDataType * >*a, const char *type)
{
	for (std::vector<ns2__TabulatedDataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__TabulatedDataType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__TabulatedDataType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__TabulatedDataType(struct soap *soap, const char *tag, std::vector<ns2__TabulatedDataType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__TabulatedDataType(soap, -1)))
		return NULL;
	ns2__TabulatedDataType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__TabulatedDataType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__TabulatedDataType, sizeof(ns2__TabulatedDataType), 1))
				break;
			if (!soap_in_PointerTons2__TabulatedDataType(soap, tag, NULL, "ns2:TabulatedDataType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__TabulatedDataType(soap, tag, &n, "ns2:TabulatedDataType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__TabulatedDataType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__TabulatedDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__TabulatedDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__TabulatedDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__TabulatedDataType * >);
		if (size)
			*size = sizeof(std::vector<ns2__TabulatedDataType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__TabulatedDataType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__TabulatedDataType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__TabulatedDataType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__TabulatedDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__TabulatedDataType * > %p -> %p\n", q, p));
	*(std::vector<ns2__TabulatedDataType * >*)p = *(std::vector<ns2__TabulatedDataType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__FitDataType(struct soap *soap, std::vector<ns2__FitDataType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__FitDataType(struct soap *soap, const std::vector<ns2__FitDataType * >*a)
{
	for (std::vector<ns2__FitDataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__FitDataType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__FitDataType(struct soap *soap, const char *tag, int id, const std::vector<ns2__FitDataType * >*a, const char *type)
{
	for (std::vector<ns2__FitDataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__FitDataType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__FitDataType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__FitDataType(struct soap *soap, const char *tag, std::vector<ns2__FitDataType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__FitDataType(soap, -1)))
		return NULL;
	ns2__FitDataType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__FitDataType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitDataType, sizeof(ns2__FitDataType), 1))
				break;
			if (!soap_in_PointerTons2__FitDataType(soap, tag, NULL, "ns2:FitDataType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__FitDataType(soap, tag, &n, "ns2:FitDataType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__FitDataType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__FitDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__FitDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FitDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FitDataType * >);
		if (size)
			*size = sizeof(std::vector<ns2__FitDataType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FitDataType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__FitDataType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__FitDataType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__FitDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__FitDataType * > %p -> %p\n", q, p));
	*(std::vector<ns2__FitDataType * >*)p = *(std::vector<ns2__FitDataType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__CodeType(struct soap *soap, std::vector<enum ns2__CodeType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__CodeType(struct soap *soap, const std::vector<enum ns2__CodeType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__CodeType(struct soap *soap, const char *tag, int id, const std::vector<enum ns2__CodeType >*a, const char *type)
{
	for (std::vector<enum ns2__CodeType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__CodeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns2__CodeType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__CodeType(struct soap *soap, const char *tag, std::vector<enum ns2__CodeType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__CodeType(soap, -1)))
		return NULL;
	enum ns2__CodeType n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_ns2__CodeType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__CodeType, SOAP_TYPE_std__vectorTemplateOfns2__CodeType, sizeof(enum ns2__CodeType), 0))
				break;
			if (!soap_in_ns2__CodeType(soap, tag, NULL, "ns2:CodeType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__CodeType(soap, tag, &n, "ns2:CodeType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns2__CodeType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__CodeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__CodeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__CodeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__CodeType >);
		if (size)
			*size = sizeof(std::vector<enum ns2__CodeType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__CodeType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns2__CodeType >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns2__CodeType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__CodeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns2__CodeType > %p -> %p\n", q, p));
	*(std::vector<enum ns2__CodeType >*)p = *(std::vector<enum ns2__CodeType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ParticleType(struct soap *soap, std::vector<ns2__ParticleType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ParticleType(struct soap *soap, const std::vector<ns2__ParticleType * >*a)
{
	for (std::vector<ns2__ParticleType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ParticleType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ParticleType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ParticleType * >*a, const char *type)
{
	for (std::vector<ns2__ParticleType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ParticleType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ParticleType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ParticleType(struct soap *soap, const char *tag, std::vector<ns2__ParticleType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ParticleType(soap, -1)))
		return NULL;
	ns2__ParticleType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ParticleType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParticleType, sizeof(ns2__ParticleType), 1))
				break;
			if (!soap_in_PointerTons2__ParticleType(soap, tag, NULL, "ns2:ParticleType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ParticleType(soap, tag, &n, "ns2:ParticleType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ParticleType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ParticleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ParticleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParticleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ParticleType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ParticleType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ParticleType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ParticleType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ParticleType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ParticleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ParticleType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ParticleType * >*)p = *(std::vector<ns2__ParticleType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, std::vector<ns2__ComplexMolecularQuantumNumberType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, const std::vector<ns2__ComplexMolecularQuantumNumberType * >*a)
{
	for (std::vector<ns2__ComplexMolecularQuantumNumberType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ComplexMolecularQuantumNumberType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ComplexMolecularQuantumNumberType * >*a, const char *type)
{
	for (std::vector<ns2__ComplexMolecularQuantumNumberType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ComplexMolecularQuantumNumberType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ComplexMolecularQuantumNumberType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, const char *tag, std::vector<ns2__ComplexMolecularQuantumNumberType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(soap, -1)))
		return NULL;
	ns2__ComplexMolecularQuantumNumberType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ComplexMolecularQuantumNumberType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType, sizeof(ns2__ComplexMolecularQuantumNumberType), 1))
				break;
			if (!soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, tag, NULL, "ns2:ComplexMolecularQuantumNumberType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ComplexMolecularQuantumNumberType(soap, tag, &n, "ns2:ComplexMolecularQuantumNumberType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ComplexMolecularQuantumNumberType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ComplexMolecularQuantumNumberType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ComplexMolecularQuantumNumberType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ComplexMolecularQuantumNumberType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ComplexMolecularQuantumNumberType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ComplexMolecularQuantumNumberType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ComplexMolecularQuantumNumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ComplexMolecularQuantumNumberType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ComplexMolecularQuantumNumberType * >*)p = *(std::vector<ns2__ComplexMolecularQuantumNumberType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__VibrationalComponentType(struct soap *soap, std::vector<ns2__VibrationalComponentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__VibrationalComponentType(struct soap *soap, const std::vector<ns2__VibrationalComponentType * >*a)
{
	for (std::vector<ns2__VibrationalComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__VibrationalComponentType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__VibrationalComponentType(struct soap *soap, const char *tag, int id, const std::vector<ns2__VibrationalComponentType * >*a, const char *type)
{
	for (std::vector<ns2__VibrationalComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__VibrationalComponentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__VibrationalComponentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__VibrationalComponentType(struct soap *soap, const char *tag, std::vector<ns2__VibrationalComponentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__VibrationalComponentType(soap, -1)))
		return NULL;
	ns2__VibrationalComponentType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__VibrationalComponentType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VibrationalComponentType, sizeof(ns2__VibrationalComponentType), 1))
				break;
			if (!soap_in_PointerTons2__VibrationalComponentType(soap, tag, NULL, "ns2:VibrationalComponentType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__VibrationalComponentType(soap, tag, &n, "ns2:VibrationalComponentType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__VibrationalComponentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__VibrationalComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__VibrationalComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VibrationalComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__VibrationalComponentType * >);
		if (size)
			*size = sizeof(std::vector<ns2__VibrationalComponentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__VibrationalComponentType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__VibrationalComponentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__VibrationalComponentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__VibrationalComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__VibrationalComponentType * > %p -> %p\n", q, p));
	*(std::vector<ns2__VibrationalComponentType * >*)p = *(std::vector<ns2__VibrationalComponentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__RotationalComponentType(struct soap *soap, std::vector<ns2__RotationalComponentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__RotationalComponentType(struct soap *soap, const std::vector<ns2__RotationalComponentType * >*a)
{
	for (std::vector<ns2__RotationalComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__RotationalComponentType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__RotationalComponentType(struct soap *soap, const char *tag, int id, const std::vector<ns2__RotationalComponentType * >*a, const char *type)
{
	for (std::vector<ns2__RotationalComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__RotationalComponentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__RotationalComponentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__RotationalComponentType(struct soap *soap, const char *tag, std::vector<ns2__RotationalComponentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__RotationalComponentType(soap, -1)))
		return NULL;
	ns2__RotationalComponentType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RotationalComponentType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RotationalComponentType, sizeof(ns2__RotationalComponentType), 1))
				break;
			if (!soap_in_PointerTons2__RotationalComponentType(soap, tag, NULL, "ns2:RotationalComponentType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__RotationalComponentType(soap, tag, &n, "ns2:RotationalComponentType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__RotationalComponentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__RotationalComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__RotationalComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RotationalComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RotationalComponentType * >);
		if (size)
			*size = sizeof(std::vector<ns2__RotationalComponentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RotationalComponentType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__RotationalComponentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__RotationalComponentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__RotationalComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__RotationalComponentType * > %p -> %p\n", q, p));
	*(std::vector<ns2__RotationalComponentType * >*)p = *(std::vector<ns2__RotationalComponentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__CharacterisationType(struct soap *soap, std::vector<ns2__CharacterisationType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__CharacterisationType(struct soap *soap, const std::vector<ns2__CharacterisationType * >*a)
{
	for (std::vector<ns2__CharacterisationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__CharacterisationType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__CharacterisationType(struct soap *soap, const char *tag, int id, const std::vector<ns2__CharacterisationType * >*a, const char *type)
{
	for (std::vector<ns2__CharacterisationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__CharacterisationType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__CharacterisationType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__CharacterisationType(struct soap *soap, const char *tag, std::vector<ns2__CharacterisationType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__CharacterisationType(soap, -1)))
		return NULL;
	ns2__CharacterisationType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__CharacterisationType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__CharacterisationType, sizeof(ns2__CharacterisationType), 1))
				break;
			if (!soap_in_PointerTons2__CharacterisationType(soap, tag, NULL, "ns2:CharacterisationType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__CharacterisationType(soap, tag, &n, "ns2:CharacterisationType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__CharacterisationType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__CharacterisationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__CharacterisationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__CharacterisationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__CharacterisationType * >);
		if (size)
			*size = sizeof(std::vector<ns2__CharacterisationType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__CharacterisationType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__CharacterisationType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__CharacterisationType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__CharacterisationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__CharacterisationType * > %p -> %p\n", q, p));
	*(std::vector<ns2__CharacterisationType * >*)p = *(std::vector<ns2__CharacterisationType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(struct soap *soap, std::vector<__ns2__MolecularPropertiesType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(struct soap *soap, const std::vector<__ns2__MolecularPropertiesType_sequence >*a)
{
	for (std::vector<__ns2__MolecularPropertiesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__MolecularPropertiesType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__MolecularPropertiesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__MolecularPropertiesType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__MolecularPropertiesType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(soap, -1)))
		return NULL;
	__ns2__MolecularPropertiesType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__MolecularPropertiesType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence, sizeof(__ns2__MolecularPropertiesType_sequence), 0))
				break;
			if (!soap_in___ns2__MolecularPropertiesType_sequence(soap, tag, NULL, "-ns2:MolecularPropertiesType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__MolecularPropertiesType_sequence(soap, tag, &n, "-ns2:MolecularPropertiesType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__MolecularPropertiesType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__MolecularPropertiesType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__MolecularPropertiesType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__MolecularPropertiesType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__MolecularPropertiesType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__MolecularPropertiesType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__MolecularPropertiesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__MolecularPropertiesType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__MolecularPropertiesType_sequence >*)p = *(std::vector<__ns2__MolecularPropertiesType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ElectronicComponentType(struct soap *soap, std::vector<ns2__ElectronicComponentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ElectronicComponentType(struct soap *soap, const std::vector<ns2__ElectronicComponentType * >*a)
{
	for (std::vector<ns2__ElectronicComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ElectronicComponentType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ElectronicComponentType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ElectronicComponentType * >*a, const char *type)
{
	for (std::vector<ns2__ElectronicComponentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ElectronicComponentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ElectronicComponentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ElectronicComponentType(struct soap *soap, const char *tag, std::vector<ns2__ElectronicComponentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ElectronicComponentType(soap, -1)))
		return NULL;
	ns2__ElectronicComponentType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ElectronicComponentType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ElectronicComponentType, sizeof(ns2__ElectronicComponentType), 1))
				break;
			if (!soap_in_PointerTons2__ElectronicComponentType(soap, tag, NULL, "ns2:ElectronicComponentType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ElectronicComponentType(soap, tag, &n, "ns2:ElectronicComponentType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ElectronicComponentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ElectronicComponentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ElectronicComponentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ElectronicComponentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ElectronicComponentType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ElectronicComponentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ElectronicComponentType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ElectronicComponentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ElectronicComponentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ElectronicComponentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ElectronicComponentType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ElectronicComponentType * >*)p = *(std::vector<ns2__ElectronicComponentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__BondArrayType_sequence(struct soap *soap, std::vector<__ns2__BondArrayType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__BondArrayType_sequence(struct soap *soap, const std::vector<__ns2__BondArrayType_sequence >*a)
{
	for (std::vector<__ns2__BondArrayType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__BondArrayType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__BondArrayType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__BondArrayType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__BondArrayType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__BondArrayType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__BondArrayType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__BondArrayType_sequence(soap, -1)))
		return NULL;
	__ns2__BondArrayType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__BondArrayType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__BondArrayType_sequence, sizeof(__ns2__BondArrayType_sequence), 0))
				break;
			if (!soap_in___ns2__BondArrayType_sequence(soap, tag, NULL, "-ns2:BondArrayType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__BondArrayType_sequence(soap, tag, &n, "-ns2:BondArrayType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__BondArrayType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__BondArrayType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__BondArrayType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__BondArrayType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__BondArrayType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__BondArrayType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__BondArrayType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__BondArrayType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__BondArrayType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__BondArrayType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__BondArrayType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__BondArrayType_sequence >*)p = *(std::vector<__ns2__BondArrayType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__AtomArrayType_sequence(struct soap *soap, std::vector<__ns2__AtomArrayType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__AtomArrayType_sequence(struct soap *soap, const std::vector<__ns2__AtomArrayType_sequence >*a)
{
	for (std::vector<__ns2__AtomArrayType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__AtomArrayType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__AtomArrayType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__AtomArrayType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__AtomArrayType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__AtomArrayType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__AtomArrayType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__AtomArrayType_sequence(soap, -1)))
		return NULL;
	__ns2__AtomArrayType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__AtomArrayType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__AtomArrayType_sequence, sizeof(__ns2__AtomArrayType_sequence), 0))
				break;
			if (!soap_in___ns2__AtomArrayType_sequence(soap, tag, NULL, "-ns2:AtomArrayType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__AtomArrayType_sequence(soap, tag, &n, "-ns2:AtomArrayType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__AtomArrayType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__AtomArrayType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__AtomArrayType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__AtomArrayType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__AtomArrayType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__AtomArrayType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__AtomArrayType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__AtomArrayType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__AtomArrayType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__AtomArrayType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__AtomArrayType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__AtomArrayType_sequence >*)p = *(std::vector<__ns2__AtomArrayType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__SuperShellType(struct soap *soap, std::vector<ns2__SuperShellType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__SuperShellType(struct soap *soap, const std::vector<ns2__SuperShellType * >*a)
{
	for (std::vector<ns2__SuperShellType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__SuperShellType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__SuperShellType(struct soap *soap, const char *tag, int id, const std::vector<ns2__SuperShellType * >*a, const char *type)
{
	for (std::vector<ns2__SuperShellType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__SuperShellType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__SuperShellType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__SuperShellType(struct soap *soap, const char *tag, std::vector<ns2__SuperShellType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__SuperShellType(soap, -1)))
		return NULL;
	ns2__SuperShellType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__SuperShellType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SuperShellType, sizeof(ns2__SuperShellType), 1))
				break;
			if (!soap_in_PointerTons2__SuperShellType(soap, tag, NULL, "ns2:SuperShellType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__SuperShellType(soap, tag, &n, "ns2:SuperShellType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__SuperShellType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__SuperShellType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__SuperShellType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SuperShellType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SuperShellType * >);
		if (size)
			*size = sizeof(std::vector<ns2__SuperShellType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SuperShellType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__SuperShellType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__SuperShellType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__SuperShellType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__SuperShellType * > %p -> %p\n", q, p));
	*(std::vector<ns2__SuperShellType * >*)p = *(std::vector<ns2__SuperShellType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__ShellsType_sequence(struct soap *soap, std::vector<__ns2__ShellsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__ShellsType_sequence(struct soap *soap, const std::vector<__ns2__ShellsType_sequence >*a)
{
	for (std::vector<__ns2__ShellsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__ShellsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__ShellsType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__ShellsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__ShellsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__ShellsType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__ShellsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__ShellsType_sequence(soap, -1)))
		return NULL;
	__ns2__ShellsType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__ShellsType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__ShellsType_sequence, sizeof(__ns2__ShellsType_sequence), 0))
				break;
			if (!soap_in___ns2__ShellsType_sequence(soap, tag, NULL, "-ns2:ShellsType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__ShellsType_sequence(soap, tag, &n, "-ns2:ShellsType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__ShellsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__ShellsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__ShellsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__ShellsType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__ShellsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__ShellsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__ShellsType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__ShellsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__ShellsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__ShellsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__ShellsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__ShellsType_sequence >*)p = *(std::vector<__ns2__ShellsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ShellPairType(struct soap *soap, std::vector<ns2__ShellPairType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ShellPairType(struct soap *soap, const std::vector<ns2__ShellPairType * >*a)
{
	for (std::vector<ns2__ShellPairType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ShellPairType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ShellPairType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ShellPairType * >*a, const char *type)
{
	for (std::vector<ns2__ShellPairType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ShellPairType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ShellPairType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ShellPairType(struct soap *soap, const char *tag, std::vector<ns2__ShellPairType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ShellPairType(soap, -1)))
		return NULL;
	ns2__ShellPairType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ShellPairType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellPairType, sizeof(ns2__ShellPairType), 1))
				break;
			if (!soap_in_PointerTons2__ShellPairType(soap, tag, NULL, "ns2:ShellPairType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ShellPairType(soap, tag, &n, "ns2:ShellPairType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ShellPairType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ShellPairType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ShellPairType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellPairType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ShellPairType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ShellPairType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ShellPairType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ShellPairType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ShellPairType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ShellPairType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ShellPairType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ShellPairType * >*)p = *(std::vector<ns2__ShellPairType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ShellType(struct soap *soap, std::vector<ns2__ShellType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ShellType(struct soap *soap, const std::vector<ns2__ShellType * >*a)
{
	for (std::vector<ns2__ShellType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ShellType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ShellType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ShellType * >*a, const char *type)
{
	for (std::vector<ns2__ShellType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ShellType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ShellType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ShellType(struct soap *soap, const char *tag, std::vector<ns2__ShellType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ShellType(soap, -1)))
		return NULL;
	ns2__ShellType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ShellType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellType, sizeof(ns2__ShellType), 1))
				break;
			if (!soap_in_PointerTons2__ShellType(soap, tag, NULL, "ns2:ShellType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ShellType(soap, tag, &n, "ns2:ShellType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ShellType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ShellType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ShellType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ShellType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ShellType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ShellType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ShellType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ShellType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ShellType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ShellType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ShellType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ShellType * >*)p = *(std::vector<ns2__ShellType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__IonStateType(struct soap *soap, std::vector<ns2__IonStateType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__IonStateType(struct soap *soap, const std::vector<ns2__IonStateType * >*a)
{
	for (std::vector<ns2__IonStateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__IonStateType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__IonStateType(struct soap *soap, const char *tag, int id, const std::vector<ns2__IonStateType * >*a, const char *type)
{
	for (std::vector<ns2__IonStateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__IonStateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__IonStateType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__IonStateType(struct soap *soap, const char *tag, std::vector<ns2__IonStateType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__IonStateType(soap, -1)))
		return NULL;
	ns2__IonStateType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__IonStateType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__IonStateType, sizeof(ns2__IonStateType), 1))
				break;
			if (!soap_in_PointerTons2__IonStateType(soap, tag, NULL, "ns2:IonStateType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__IonStateType(soap, tag, &n, "ns2:IonStateType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__IonStateType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__IonStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__IonStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__IonStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__IonStateType * >);
		if (size)
			*size = sizeof(std::vector<ns2__IonStateType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__IonStateType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__IonStateType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__IonStateType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__IonStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__IonStateType * > %p -> %p\n", q, p));
	*(std::vector<ns2__IonStateType * >*)p = *(std::vector<ns2__IonStateType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__FunctionType(struct soap *soap, std::vector<ns2__FunctionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__FunctionType(struct soap *soap, const std::vector<ns2__FunctionType * >*a)
{
	for (std::vector<ns2__FunctionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__FunctionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__FunctionType(struct soap *soap, const char *tag, int id, const std::vector<ns2__FunctionType * >*a, const char *type)
{
	for (std::vector<ns2__FunctionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__FunctionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__FunctionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__FunctionType(struct soap *soap, const char *tag, std::vector<ns2__FunctionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__FunctionType(soap, -1)))
		return NULL;
	ns2__FunctionType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__FunctionType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FunctionType, sizeof(ns2__FunctionType), 1))
				break;
			if (!soap_in_PointerTons2__FunctionType(soap, tag, NULL, "ns2:FunctionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__FunctionType(soap, tag, &n, "ns2:FunctionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__FunctionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__FunctionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__FunctionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FunctionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FunctionType * >);
		if (size)
			*size = sizeof(std::vector<ns2__FunctionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FunctionType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__FunctionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__FunctionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__FunctionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__FunctionType * > %p -> %p\n", q, p));
	*(std::vector<ns2__FunctionType * >*)p = *(std::vector<ns2__FunctionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MethodType(struct soap *soap, std::vector<ns2__MethodType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MethodType(struct soap *soap, const std::vector<ns2__MethodType * >*a)
{
	for (std::vector<ns2__MethodType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MethodType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MethodType(struct soap *soap, const char *tag, int id, const std::vector<ns2__MethodType * >*a, const char *type)
{
	for (std::vector<ns2__MethodType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MethodType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MethodType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MethodType(struct soap *soap, const char *tag, std::vector<ns2__MethodType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MethodType(soap, -1)))
		return NULL;
	ns2__MethodType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MethodType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MethodType, sizeof(ns2__MethodType), 1))
				break;
			if (!soap_in_PointerTons2__MethodType(soap, tag, NULL, "ns2:MethodType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__MethodType(soap, tag, &n, "ns2:MethodType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MethodType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MethodType * >);
		if (size)
			*size = sizeof(std::vector<ns2__MethodType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MethodType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__MethodType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__MethodType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MethodType * > %p -> %p\n", q, p));
	*(std::vector<ns2__MethodType * >*)p = *(std::vector<ns2__MethodType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__AuthorType(struct soap *soap, std::vector<ns2__AuthorType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__AuthorType(struct soap *soap, const std::vector<ns2__AuthorType * >*a)
{
	for (std::vector<ns2__AuthorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__AuthorType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__AuthorType(struct soap *soap, const char *tag, int id, const std::vector<ns2__AuthorType * >*a, const char *type)
{
	for (std::vector<ns2__AuthorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__AuthorType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__AuthorType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__AuthorType(struct soap *soap, const char *tag, std::vector<ns2__AuthorType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__AuthorType(soap, -1)))
		return NULL;
	ns2__AuthorType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AuthorType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AuthorType, sizeof(ns2__AuthorType), 1))
				break;
			if (!soap_in_PointerTons2__AuthorType(soap, tag, NULL, "ns2:AuthorType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__AuthorType(soap, tag, &n, "ns2:AuthorType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__AuthorType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__AuthorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__AuthorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AuthorType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AuthorType * >);
		if (size)
			*size = sizeof(std::vector<ns2__AuthorType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__AuthorType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__AuthorType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__AuthorType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__AuthorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__AuthorType * > %p -> %p\n", q, p));
	*(std::vector<ns2__AuthorType * >*)p = *(std::vector<ns2__AuthorType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__SourceType(struct soap *soap, std::vector<ns2__SourceType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__SourceType(struct soap *soap, const std::vector<ns2__SourceType * >*a)
{
	for (std::vector<ns2__SourceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__SourceType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__SourceType(struct soap *soap, const char *tag, int id, const std::vector<ns2__SourceType * >*a, const char *type)
{
	for (std::vector<ns2__SourceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__SourceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__SourceType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__SourceType(struct soap *soap, const char *tag, std::vector<ns2__SourceType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__SourceType(soap, -1)))
		return NULL;
	ns2__SourceType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__SourceType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceType, sizeof(ns2__SourceType), 1))
				break;
			if (!soap_in_PointerTons2__SourceType(soap, tag, NULL, "ns2:SourceType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__SourceType(soap, tag, &n, "ns2:SourceType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__SourceType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__SourceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__SourceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SourceType * >);
		if (size)
			*size = sizeof(std::vector<ns2__SourceType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__SourceType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__SourceType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__SourceType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__SourceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__SourceType * > %p -> %p\n", q, p));
	*(std::vector<ns2__SourceType * >*)p = *(std::vector<ns2__SourceType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__ProductsType_sequence(struct soap *soap, std::vector<__ns2__ProductsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__ProductsType_sequence(struct soap *soap, const std::vector<__ns2__ProductsType_sequence >*a)
{
	for (std::vector<__ns2__ProductsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__ProductsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__ProductsType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__ProductsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__ProductsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__ProductsType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__ProductsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__ProductsType_sequence(soap, -1)))
		return NULL;
	__ns2__ProductsType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__ProductsType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__ProductsType_sequence, sizeof(__ns2__ProductsType_sequence), 0))
				break;
			if (!soap_in___ns2__ProductsType_sequence(soap, tag, NULL, "-ns2:ProductsType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__ProductsType_sequence(soap, tag, &n, "-ns2:ProductsType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__ProductsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__ProductsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__ProductsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__ProductsType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__ProductsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__ProductsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__ProductsType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__ProductsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__ProductsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__ProductsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__ProductsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__ProductsType_sequence >*)p = *(std::vector<__ns2__ProductsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__ns2__ReactantsType_sequence(struct soap *soap, std::vector<__ns2__ReactantsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__ns2__ReactantsType_sequence(struct soap *soap, const std::vector<__ns2__ReactantsType_sequence >*a)
{
	for (std::vector<__ns2__ReactantsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__ns2__ReactantsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__ns2__ReactantsType_sequence >*a, const char *type)
{
	for (std::vector<__ns2__ReactantsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__ns2__ReactantsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__ns2__ReactantsType_sequence(struct soap *soap, const char *tag, std::vector<__ns2__ReactantsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf__ns2__ReactantsType_sequence(soap, -1)))
		return NULL;
	__ns2__ReactantsType_sequence n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___ns2__ReactantsType_sequence, SOAP_TYPE_std__vectorTemplateOf__ns2__ReactantsType_sequence, sizeof(__ns2__ReactantsType_sequence), 0))
				break;
			if (!soap_in___ns2__ReactantsType_sequence(soap, tag, NULL, "-ns2:ReactantsType-sequence"))
				break;
		}
		else
		{
			if (!soap_in___ns2__ReactantsType_sequence(soap, tag, &n, "-ns2:ReactantsType-sequence"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__ns2__ReactantsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__ns2__ReactantsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__ns2__ReactantsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__ns2__ReactantsType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__ReactantsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__ns2__ReactantsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__ns2__ReactantsType_sequence >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<__ns2__ReactantsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<__ns2__ReactantsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__ns2__ReactantsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__ns2__ReactantsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__ns2__ReactantsType_sequence >*)p = *(std::vector<__ns2__ReactantsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__AngularMomentumType(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__AngularMomentumType(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns2__AngularMomentumType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__AngularMomentumType(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__AngularMomentumType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__AngularMomentumType(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__AngularMomentumType(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_ns2__AngularMomentumType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AngularMomentumType, SOAP_TYPE_std__vectorTemplateOfns2__AngularMomentumType, sizeof(std::string), 0))
				break;
			if (!soap_in_ns2__AngularMomentumType(soap, tag, NULL, "ns2:AngularMomentumType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__AngularMomentumType(soap, tag, &n, "ns2:AngularMomentumType"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__AngularMomentumType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__AngularMomentumType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__AngularMomentumType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__AngularMomentumType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ParameterType(struct soap *soap, std::vector<ns2__ParameterType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ParameterType(struct soap *soap, const std::vector<ns2__ParameterType * >*a)
{
	for (std::vector<ns2__ParameterType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ParameterType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ParameterType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ParameterType * >*a, const char *type)
{
	for (std::vector<ns2__ParameterType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ParameterType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ParameterType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ParameterType(struct soap *soap, const char *tag, std::vector<ns2__ParameterType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ParameterType(soap, -1)))
		return NULL;
	ns2__ParameterType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ParameterType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParameterType, sizeof(ns2__ParameterType), 1))
				break;
			if (!soap_in_PointerTons2__ParameterType(soap, tag, NULL, "ns2:ParameterType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ParameterType(soap, tag, &n, "ns2:ParameterType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ParameterType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ParameterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ParameterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ParameterType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ParameterType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ParameterType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ParameterType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ParameterType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ParameterType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ParameterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ParameterType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ParameterType * >*)p = *(std::vector<ns2__ParameterType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ArgumentType(struct soap *soap, std::vector<ns2__ArgumentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ArgumentType(struct soap *soap, const std::vector<ns2__ArgumentType * >*a)
{
	for (std::vector<ns2__ArgumentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ArgumentType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ArgumentType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ArgumentType * >*a, const char *type)
{
	for (std::vector<ns2__ArgumentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ArgumentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ArgumentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ArgumentType(struct soap *soap, const char *tag, std::vector<ns2__ArgumentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ArgumentType(soap, -1)))
		return NULL;
	ns2__ArgumentType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ArgumentType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ArgumentType, sizeof(ns2__ArgumentType), 1))
				break;
			if (!soap_in_PointerTons2__ArgumentType(soap, tag, NULL, "ns2:ArgumentType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ArgumentType(soap, tag, &n, "ns2:ArgumentType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ArgumentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ArgumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ArgumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ArgumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ArgumentType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ArgumentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ArgumentType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ArgumentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ArgumentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ArgumentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ArgumentType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ArgumentType * >*)p = *(std::vector<ns2__ArgumentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdouble(struct soap *soap, const std::vector<double >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, int id, const std::vector<double >*a, const char *type)
{
	for (std::vector<double >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_double(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<double >* SOAP_FMAC4 soap_in_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, std::vector<double >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfdouble(soap, -1)))
		return NULL;
	double n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_double(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_double, SOAP_TYPE_std__vectorTemplateOfdouble, sizeof(double), 0))
				break;
			if (!soap_in_double(soap, tag, NULL, "xsd:double"))
				break;
		}
		else
		{
			if (!soap_in_double(soap, tag, &n, "xsd:double"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<double > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<double >);
		if (size)
			*size = sizeof(std::vector<double >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<double >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<double >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<double >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<double > %p -> %p\n", q, p));
	*(std::vector<double >*)p = *(std::vector<double >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__DataTableType(struct soap *soap, std::vector<ns2__DataTableType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__DataTableType(struct soap *soap, const std::vector<ns2__DataTableType * >*a)
{
	for (std::vector<ns2__DataTableType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__DataTableType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__DataTableType(struct soap *soap, const char *tag, int id, const std::vector<ns2__DataTableType * >*a, const char *type)
{
	for (std::vector<ns2__DataTableType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__DataTableType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__DataTableType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__DataTableType(struct soap *soap, const char *tag, std::vector<ns2__DataTableType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__DataTableType(soap, -1)))
		return NULL;
	ns2__DataTableType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DataTableType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataTableType, sizeof(ns2__DataTableType), 1))
				break;
			if (!soap_in_PointerTons2__DataTableType(soap, tag, NULL, "ns2:DataTableType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__DataTableType(soap, tag, &n, "ns2:DataTableType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__DataTableType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__DataTableType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__DataTableType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataTableType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DataTableType * >);
		if (size)
			*size = sizeof(std::vector<ns2__DataTableType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DataTableType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__DataTableType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__DataTableType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__DataTableType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__DataTableType * > %p -> %p\n", q, p));
	*(std::vector<ns2__DataTableType * >*)p = *(std::vector<ns2__DataTableType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__DataSetType(struct soap *soap, std::vector<ns2__DataSetType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__DataSetType(struct soap *soap, const std::vector<ns2__DataSetType * >*a)
{
	for (std::vector<ns2__DataSetType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__DataSetType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__DataSetType(struct soap *soap, const char *tag, int id, const std::vector<ns2__DataSetType * >*a, const char *type)
{
	for (std::vector<ns2__DataSetType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__DataSetType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__DataSetType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__DataSetType(struct soap *soap, const char *tag, std::vector<ns2__DataSetType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__DataSetType(soap, -1)))
		return NULL;
	ns2__DataSetType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DataSetType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataSetType, sizeof(ns2__DataSetType), 1))
				break;
			if (!soap_in_PointerTons2__DataSetType(soap, tag, NULL, "ns2:DataSetType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__DataSetType(soap, tag, &n, "ns2:DataSetType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__DataSetType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__DataSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__DataSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DataSetType * >);
		if (size)
			*size = sizeof(std::vector<ns2__DataSetType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DataSetType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__DataSetType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__DataSetType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__DataSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__DataSetType * > %p -> %p\n", q, p));
	*(std::vector<ns2__DataSetType * >*)p = *(std::vector<ns2__DataSetType * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
