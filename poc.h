/* poc.h
   Generated by wsdl2h 2.8.16 from poc.wsdl and typemap.dat
   2013-10-03 13:03:39 GMT

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

   gSOAP XML Web services tools.
   Copyright (C) 2000-2013 Robert van Engelen, Genivia Inc. All Rights Reserved.
   Part of this software is released under one of the following licenses:
   GPL or Genivia's license for commercial use.
*/

/** @page page_notes Usage Notes

NOTE:

 - Run soapcpp2 on poc.h to generate the SOAP/XML processing logic.
   Use soapcpp2 -I to specify paths for #import
   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
   Use soapcpp2 -j to generate improved proxy and server classes.
 - Use wsdl2h -c and -s to generate pure C code or C++ code without STL.
 - Use 'typemap.dat' to control namespace bindings and type mappings.
   It is strongly recommended to customize the names of the namespace prefixes
   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
 - Use Doxygen (www.doxygen.org) on this file to generate documentation.
 - Use wsdl2h -R to generate REST operations.
 - Use wsdl2h -nname to use name as the base namespace prefix instead of 'ns'.
 - Use wsdl2h -Nname for service prefix and produce multiple service bindings
 - Use wsdl2h -d to enable DOM support for xsd:anyType.
 - Use wsdl2h -g to auto-generate readers and writers for root elements.
 - Use wsdl2h -b to auto-generate bi-directional operations (duplex ops).
 - Struct/class members serialized as XML attributes are annotated with a '@'.
 - Struct/class members that have a special role are annotated with a '$'.

WARNING:

   DO NOT INCLUDE THIS ANNOTATED FILE DIRECTLY IN YOUR PROJECT SOURCE CODE.
   USE THE FILES GENERATED BY soapcpp2 FOR YOUR PROJECT'S SOURCE CODE:
   THE soapStub.h FILE CONTAINS THIS CONTENT WITHOUT ANNOTATIONS.

LICENSE:

@verbatim
--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.

This software is released under one of the following licenses:
GPL or Genivia's license for commercial use.
--------------------------------------------------------------------------------
GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org

This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial-use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
@endverbatim

*/


//gsoapopt w

/******************************************************************************\
 *                                                                            *
 * Definitions                                                                *
 *   http://physics.muni.cz/~adamobrusnik/ws/poc.wsdl                         *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/


// STL vector containers (use option -s to remove STL dependency)
#import "stlvector.h"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/


/* NOTE:

It is strongly recommended to customize the names of the namespace prefixes
generated by wsdl2h. To do so, modify the prefix bindings below and add the
modified lines to typemap.dat to rerun wsdl2h:

ns1 = "http://physics.muni.cz/~adamobrusnik/ws/poc.wsdl"
ns2 = "urn:poc"
ns2 = "urn:poc"

*/

#define SOAP_NAMESPACE_OF_ns2	"urn:poc"
//gsoap ns2   schema namespace:	urn:poc
//gsoap ns2   schema form:	unqualified

/// @brief Functions used in fits etc.
#define SOAP_NAMESPACE_OF_ns2	"urn:poc"
//gsoap ns2   schema namespace:	urn:poc
//gsoap ns2   schema elementForm:	qualified
//gsoap ns2   schema attributeForm:	unqualified

/******************************************************************************\
 *                                                                            *
 * Built-in Schema Types and Top-Level Elements and Attributes                *
 *                                                                            *
\******************************************************************************/


/// Primitive built-in type "xs:ID"
typedef std::string xsd__ID;

/// Primitive built-in type "xs:IDREF"
typedef std::string xsd__IDREF;

/// Primitive built-in type "xs:IDREFS"
typedef std::string xsd__IDREFS;

/// Primitive built-in type "xs:anyURI"
typedef std::string xsd__anyURI;

/// Primitive built-in type "xs:date"
typedef std::string xsd__date;

/// Primitive built-in type "xs:decimal"
typedef std::string xsd__decimal;

/// Primitive built-in type "xs:gYear"
typedef std::string xsd__gYear;

/// Primitive built-in type "xs:integer"
typedef std::string xsd__integer;

/// Primitive built-in type "xs:nonNegativeInteger"
typedef std::string xsd__nonNegativeInteger;

/// Primitive built-in type "xs:positiveInteger"
typedef std::string xsd__positiveInteger;

/// Primitive built-in type "xs:token"
typedef std::string xsd__token;

/******************************************************************************\
 *                                                                            *
 * Forward Declarations                                                       *
 *                                                                            *
\******************************************************************************/



//  Forward declaration of class ns2__PrimaryType.
class ns2__PrimaryType;

//  Forward declaration of class ns2__ChemicalElementType.
class ns2__ChemicalElementType;

//  Forward declaration of class ns2__DataType.
class ns2__DataType;

//  Forward declaration of class ns2__DataSetType.
class ns2__DataSetType;

//  Forward declaration of class ns2__DataSetsType.
class ns2__DataSetsType;

//  Forward declaration of class ns2__DataTableType.
class ns2__DataTableType;

//  Forward declaration of class ns2__DataXYType.
class ns2__DataXYType;

//  Forward declaration of class ns2__TabulatedDataType.
class ns2__TabulatedDataType;

//  Forward declaration of class ns2__FitDataType.
class ns2__FitDataType;

//  Forward declaration of class ns2__FitParametersType.
class ns2__FitParametersType;

//  Forward declaration of class ns2__FitValidityLimitsType.
class ns2__FitValidityLimitsType;

//  Forward declaration of class ns2__ExpressionType.
class ns2__ExpressionType;

//  Forward declaration of class ns2__ArgumentsType.
class ns2__ArgumentsType;

//  Forward declaration of class ns2__ArgumentType.
class ns2__ArgumentType;

//  Forward declaration of class ns2__ParametersType.
class ns2__ParametersType;

//  Forward declaration of class ns2__ParameterType.
class ns2__ParameterType;

//  Forward declaration of class ns2__ValueType.
class ns2__ValueType;

//  Forward declaration of class ns2__jjCouplingType.
class ns2__jjCouplingType;

//  Forward declaration of class ns2__jKCouplingType.
class ns2__jKCouplingType;

//  Forward declaration of class ns2__LKCouplingType.
class ns2__LKCouplingType;

//  Forward declaration of class ns2__LSCouplingType.
class ns2__LSCouplingType;

//  Forward declaration of class ns2__MixingCoefficientType.
class ns2__MixingCoefficientType;

//  Forward declaration of class ns2__OrbitalAngularMomentumType.
class ns2__OrbitalAngularMomentumType;

//  Forward declaration of class ns2__TermType.
class ns2__TermType;

//  Forward declaration of class ns2__ReactantsType.
class ns2__ReactantsType;

//  Forward declaration of class ns2__ProductsType.
class ns2__ProductsType;

//  Forward declaration of class ns2__AuthorType.
class ns2__AuthorType;

//  Forward declaration of class ns2__SourcesType.
class ns2__SourcesType;

//  Forward declaration of class ns2__SourceType.
class ns2__SourceType;

//  Forward declaration of class ns2__AuthorsType.
class ns2__AuthorsType;

//  Forward declaration of class ns2__EditorsType.
class ns2__EditorsType;

//  Forward declaration of class ns2__MethodsType.
class ns2__MethodsType;

//  Forward declaration of class ns2__MethodType.
class ns2__MethodType;

//  Forward declaration of class ns2__FunctionsType.
class ns2__FunctionsType;

//  Forward declaration of class ns2__FunctionType.
class ns2__FunctionType;

//  Forward declaration of class ns2__AtomsType.
class ns2__AtomsType;

//  Forward declaration of class ns2__AtomType.
class ns2__AtomType;

//  Forward declaration of class ns2__IsotopeType.
class ns2__IsotopeType;

//  Forward declaration of class ns2__IsotopeParametersType.
class ns2__IsotopeParametersType;

//  Forward declaration of class ns2__IonStateType.
class ns2__IonStateType;

//  Forward declaration of class ns2__AtomicStateType.
class ns2__AtomicStateType;

//  Forward declaration of class ns2__AtomicNumericalDataType.
class ns2__AtomicNumericalDataType;

//  Forward declaration of class ns2__AtomicCompositionType.
class ns2__AtomicCompositionType;

//  Forward declaration of class ns2__AtomicCoreType.
class ns2__AtomicCoreType;

//  Forward declaration of class ns2__AtomicComponentType.
class ns2__AtomicComponentType;

//  Forward declaration of class ns2__AtomicQuantumNumbersType.
class ns2__AtomicQuantumNumbersType;

//  Forward declaration of class ns2__ConfigurationType.
class ns2__ConfigurationType;

//  Forward declaration of class ns2__ShellsType.
class ns2__ShellsType;

//  Forward declaration of class ns2__ShellPairType.
class ns2__ShellPairType;

//  Forward declaration of class ns2__ShellType.
class ns2__ShellType;

//  Forward declaration of class ns2__SuperConfigurationType.
class ns2__SuperConfigurationType;

//  Forward declaration of class ns2__SuperShellType.
class ns2__SuperShellType;

//  Forward declaration of class ns2__AsymmetricProjectionType.
class ns2__AsymmetricProjectionType;

//  Forward declaration of class ns2__HinderedMotionType.
class ns2__HinderedMotionType;

//  Forward declaration of class ns2__AtomArrayType.
class ns2__AtomArrayType;

//  Forward declaration of class ns2__AtomNType.
class ns2__AtomNType;

//  Forward declaration of class ns2__BondType.
class ns2__BondType;

//  Forward declaration of class ns2__BondArrayType.
class ns2__BondArrayType;

//  Forward declaration of class ns2__C2SymmetriesType.
class ns2__C2SymmetriesType;

//  Forward declaration of class ns2__CentralSymbolType.
class ns2__CentralSymbolType;

//  Forward declaration of class ns2__ComplexMolecularQuantumNumberType.
class ns2__ComplexMolecularQuantumNumberType;

//  Forward declaration of class ns2__DiatomAndLinearPolyatomicType.
class ns2__DiatomAndLinearPolyatomicType;

//  Forward declaration of class ns2__ElectronicCharacterisationType.
class ns2__ElectronicCharacterisationType;

//  Forward declaration of class ns2__ElectronicComponentType.
class ns2__ElectronicComponentType;

//  Forward declaration of class ns2__ElectronicHomeType.
class ns2__ElectronicHomeType;

//  Forward declaration of class ns2__MolecularChemicalSpeciesType.
class ns2__MolecularChemicalSpeciesType;

//  Forward declaration of class ns2__MolecularProjectionType.
class ns2__MolecularProjectionType;

//  Forward declaration of class ns2__MolecularPropertiesType.
class ns2__MolecularPropertiesType;

//  Forward declaration of class ns2__MolecularStateType.
class ns2__MolecularStateType;

//  Forward declaration of class ns2__MolecularStateCharacterisationType.
class ns2__MolecularStateCharacterisationType;

//  Forward declaration of class ns2__MolecularStateCharacterisation_oldType.
class ns2__MolecularStateCharacterisation_oldType;

//  Forward declaration of class ns2__MoleculeType.
class ns2__MoleculeType;

//  Forward declaration of class ns2__MoleculeNuclearSpinsType.
class ns2__MoleculeNuclearSpinsType;

//  Forward declaration of class ns2__MoleculesType.
class ns2__MoleculesType;

//  Forward declaration of class ns2__NonLinearPolyatomicType.
class ns2__NonLinearPolyatomicType;

//  Forward declaration of class ns2__RotationalCharacterisationType.
class ns2__RotationalCharacterisationType;

//  Forward declaration of class ns2__RotationalComponentType.
class ns2__RotationalComponentType;

//  Forward declaration of class ns2__RotationalHomeType.
class ns2__RotationalHomeType;

//  Forward declaration of class ns2__PseudoStatisticalWeightType.
class ns2__PseudoStatisticalWeightType;

//  Forward declaration of class ns2__RoVibronicSplittingType.
class ns2__RoVibronicSplittingType;

//  Forward declaration of class ns2__MolecularQuantumNumberType.
class ns2__MolecularQuantumNumberType;

//  Forward declaration of class ns2__MagneticQuantumNumberType.
class ns2__MagneticQuantumNumberType;

//  Forward declaration of class ns2__SimpleSymbolType.
class ns2__SimpleSymbolType;

//  Forward declaration of class ns2__StateEnergyType.
class ns2__StateEnergyType;

//  Forward declaration of class ns2__SymbolType.
class ns2__SymbolType;

//  Forward declaration of class ns2__TotalSpinMomentumSType.
class ns2__TotalSpinMomentumSType;

//  Forward declaration of class ns2__VibrationalComponentType.
class ns2__VibrationalComponentType;

//  Forward declaration of class ns2__VibrationalCharacterisationType.
class ns2__VibrationalCharacterisationType;

//  Forward declaration of class ns2__VibrationalHomeType.
class ns2__VibrationalHomeType;

//  Forward declaration of class ns2__VibrationalQuantumNumbersType.
class ns2__VibrationalQuantumNumbersType;

//  Forward declaration of class ns2__LinearNoElecNoHyperFType.
class ns2__LinearNoElecNoHyperFType;

//  Forward declaration of class ns2__LinearNoElecHyperFType.
class ns2__LinearNoElecHyperFType;

//  Forward declaration of class ns2__LinearElecCouplingType.
class ns2__LinearElecCouplingType;

//  Forward declaration of class ns2__HundCaseAType.
class ns2__HundCaseAType;

//  Forward declaration of class ns2__HundCaseBType.
class ns2__HundCaseBType;

//  Forward declaration of class ns2__HyperfineCaseAAlphaType.
class ns2__HyperfineCaseAAlphaType;

//  Forward declaration of class ns2__HyperfineCaseABetaType.
class ns2__HyperfineCaseABetaType;

//  Forward declaration of class ns2__HyperfineCouplingBType.
class ns2__HyperfineCouplingBType;

//  Forward declaration of class ns2__NonLinearElecCouplingType.
class ns2__NonLinearElecCouplingType;

//  Forward declaration of class ns2__NonLinearElecHyperFType.
class ns2__NonLinearElecHyperFType;

//  Forward declaration of class ns2__NonLinearElecNoHyperFType.
class ns2__NonLinearElecNoHyperFType;

//  Forward declaration of class ns2__NonLinearNoElecType.
class ns2__NonLinearNoElecType;

//  Forward declaration of class ns2__NonLinearNoElecNoHyperFType.
class ns2__NonLinearNoElecNoHyperFType;

//  Forward declaration of class ns2__NonLinearNoElecHyperFType.
class ns2__NonLinearNoElecHyperFType;

//  Forward declaration of class ns2__HyperfineQuantumNumbersType.
class ns2__HyperfineQuantumNumbersType;

//  Forward declaration of class ns2__ReferencedTextType.
class ns2__ReferencedTextType;

//  Forward declaration of class ns2__CharacterisationType.
class ns2__CharacterisationType;

//  Forward declaration of class ns2__ParticlesType.
class ns2__ParticlesType;

//  Forward declaration of class ns2__ParticleType.
class ns2__ParticleType;

//  Forward declaration of class ns2__ParticlePropertiesType.
class ns2__ParticlePropertiesType;

//  Forward declaration of class ns2__SolidType.
class ns2__SolidType;

//  Forward declaration of class ns2__SolidsType.
class ns2__SolidsType;

//  Forward declaration of class ns2__MaterialComponentType.
class ns2__MaterialComponentType;

//  Forward declaration of class ns2__MaterialType.
class ns2__MaterialType;

//  Forward declaration of class ns2__MaterialCompositionType.
class ns2__MaterialCompositionType;

//  Forward declaration of class ns2__RadiativeType.
class ns2__RadiativeType;

//  Forward declaration of class ns2__RadiativeTransitionType.
class ns2__RadiativeTransitionType;

//  Forward declaration of class ns2__RadiativeTransitionProbabilityType.
class ns2__RadiativeTransitionProbabilityType;

//  Forward declaration of class ns2__WavelengthWavenumberType.
class ns2__WavelengthWavenumberType;

//  Forward declaration of class ns2__EnergyWavelengthType.
class ns2__EnergyWavelengthType;

//  Forward declaration of class ns2__NonRadiativeType.
class ns2__NonRadiativeType;

//  Forward declaration of class ns2__NonRadiativeTransitionType.
class ns2__NonRadiativeTransitionType;

//  Forward declaration of class ns2__CollisionsType.
class ns2__CollisionsType;

//  Forward declaration of class ns2__CollisionalTransitionType.
class ns2__CollisionalTransitionType;

//  Forward declaration of class ns2__CollisionalProcessClassType.
class ns2__CollisionalProcessClassType;

//  Forward declaration of class ns2__XSAMSDataType.
class ns2__XSAMSDataType;

//  Forward declaration of class ns2__ProcessesType.
class ns2__ProcessesType;

//  Forward declaration of class ns2__StatesType.
class ns2__StatesType;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/// "urn:poc":DataListType is a simpleType containing a whitespace separated list of xs:double.
/// @brief List of numerical data
typedef std::string ns2__DataListType;

/// "urn:poc":DataDescriptionType is a simpleType restriction of xs:token.
/// @brief Descriptor for the type of collisonal parameter
/// Note: enum values are prefixed with 'ns2__DataDescriptionType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__DataDescriptionType
{
	ns2__DataDescriptionType__crossSection,	///< xs:token value="crossSection"
	ns2__DataDescriptionType__collisionStrength,	///< xs:token value="collisionStrength"
	ns2__DataDescriptionType__rateCoefficient,	///< xs:token value="rateCoefficient"
	ns2__DataDescriptionType__probability,	///< xs:token value="probability"
	ns2__DataDescriptionType__effectiveCollisionStrength,	///< xs:token value="effectiveCollisionStrength"
	ns2__DataDescriptionType__sputteringYield,	///< xs:token value="sputteringYield"
	ns2__DataDescriptionType__sputteredEnergyCoefficient,	///< xs:token value="sputteredEnergyCoefficient"
	ns2__DataDescriptionType__particleReflectionCoefficient,	///< xs:token value="particleReflectionCoefficient"
	ns2__DataDescriptionType__energyReflectionCoefficient,	///< xs:token value="energyReflectionCoefficient"
	ns2__DataDescriptionType__meanPenetrationDepth,	///< xs:token value="meanPenetrationDepth"
};

/// "urn:poc":ReferenceFrameType is a simpleType restriction of xs:string.
/// Note: enum values are prefixed with 'ns2__ReferenceFrameType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__ReferenceFrameType
{
	ns2__ReferenceFrameType__CenterOfMass,	///< xs:string value="CenterOfMass"
	ns2__ReferenceFrameType__LaboratoryFrame,	///< xs:string value="LaboratoryFrame"
	ns2__ReferenceFrameType__TargetFrame,	///< xs:string value="TargetFrame"
};

/// "urn:poc":AngularMomentumProjectionType is a simpleType restriction of xs:decimal.
/// Content pattern is "(\\+|-)?\\d+(\\.(0|5)?)?" (note: not automatically enforced)
typedef xsd__decimal ns2__AngularMomentumProjectionType "(\\+|-)?\\d+(\\.(0|5)?)?";

/// "urn:poc":AngularMomentumType is a simpleType restriction of xs:decimal.
/// @brief non-negative integer or half-integer number (e.g., 2.5).
/// Content pattern is "\\d+(\\.(0|5)?)?" (note: not automatically enforced)
typedef xsd__decimal ns2__AngularMomentumType "\\d+(\\.(0|5)?)?";

/// "urn:poc":ElementSymbolType is a simpleType restriction of xs:token.
/// @brief Symbol for a chemical element
/// Content pattern is "\\p{Lu}\\p{Ll}?" (note: not automatically enforced)
typedef xsd__token ns2__ElementSymbolType "\\p{Lu}\\p{Ll}?";

/// "urn:poc":PrincipalQuantumNumberType is a simpleType restriction of xs:positiveInteger.
/// @brief Principal quantum number (positive integer)
typedef xsd__positiveInteger ns2__PrincipalQuantumNumberType;

/// "urn:poc":ParityType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__ParityType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__ParityType
{
	ns2__ParityType__even,	///< xs:token value="even"
	ns2__ParityType__odd,	///< xs:token value="odd"
	ns2__ParityType__undefined,	///< xs:token value="undefined"
};

/// "urn:poc":MixingClassType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__MixingClassType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__MixingClassType
{
	ns2__MixingClassType__squared,	///< xs:token value="squared"
	ns2__MixingClassType__signed_,	///< xs:token value="signed"
};

/// "urn:poc":OrbitalAngularMomentumSymbolType is a simpleType restriction of xs:string.
/// Length of this string is exactly 1 characters
/// Content pattern is "\\w" (note: not automatically enforced)
typedef std::string ns2__OrbitalAngularMomentumSymbolType "\\w";

/// "urn:poc":StateRef is a simpleType restriction of xs:IDREF.
/// Content pattern is "S.+" (note: not automatically enforced)
typedef xsd__IDREF ns2__StateRef "S.+";

/// "urn:poc":CategoryType is a simpleType restriction of xs:string.
/// Note: enum values are prefixed with 'ns2__CategoryType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__CategoryType
{
	ns2__CategoryType__book,	///< xs:string value="book"
	ns2__CategoryType__database,	///< xs:string value="database"
	ns2__CategoryType__journal,	///< xs:string value="journal"
	ns2__CategoryType__preprint,	///< xs:string value="preprint"
	ns2__CategoryType__private_x0020communication,	///< xs:string value="private communication"
	ns2__CategoryType__proceedings,	///< xs:string value="proceedings"
	ns2__CategoryType__report,	///< xs:string value="report"
	ns2__CategoryType__theses,	///< xs:string value="theses"
};

/// "urn:poc":MethodCategoryType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__MethodCategoryType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__MethodCategoryType
{
	ns2__MethodCategoryType__experiment,	///< xs:token value="experiment"
	ns2__MethodCategoryType__theory,	///< xs:token value="theory"
	ns2__MethodCategoryType__recommended,	///< xs:token value="recommended"
	ns2__MethodCategoryType__evaluated,	///< xs:token value="evaluated"
	ns2__MethodCategoryType__empirical,	///< xs:token value="empirical"
	ns2__MethodCategoryType__scalingLaw,	///< xs:token value="scalingLaw"
	ns2__MethodCategoryType__semiempirical,	///< xs:token value="semiempirical"
	ns2__MethodCategoryType__compilation,	///< xs:token value="compilation"
	ns2__MethodCategoryType__derived,	///< xs:token value="derived"
	ns2__MethodCategoryType__observed,	///< xs:token value="observed"
};

/// "urn:poc":C2SymmetryType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__C2SymmetryType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__C2SymmetryType
{
	ns2__C2SymmetryType___x002b,	///< xs:token value="+"
	ns2__C2SymmetryType___x002d,	///< xs:token value="-"
};

/// "urn:poc":CouplingListType is a simpleType restriction of xs:string.
/// Note: enum values are prefixed with 'ns2__CouplingListType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__CouplingListType
{
	ns2__CouplingListType__bBetaOther,	///< xs:string value="bBetaOther"
	ns2__CouplingListType__bBetaJ,	///< xs:string value="bBetaJ"
	ns2__CouplingListType__bBetaS,	///< xs:string value="bBetaS"
	ns2__CouplingListType__bBetaN,	///< xs:string value="bBetaN"
};

/// "urn:poc":EfSymmetryType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__EfSymmetryType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__EfSymmetryType
{
	ns2__EfSymmetryType__e,	///< xs:token value="e"
	ns2__EfSymmetryType__f,	///< xs:token value="f"
};

/// "urn:poc":ModesListType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__ModesListType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__ModesListType
{
	ns2__ModesListType__normalMode,	///< xs:token value="normalMode"
	ns2__ModesListType__stretchingMode,	///< xs:token value="stretchingMode"
	ns2__ModesListType__bendingMode,	///< xs:token value="bendingMode"
	ns2__ModesListType__torsionalMode,	///< xs:token value="torsionalMode"
	ns2__ModesListType__localMode,	///< xs:token value="localMode"
	ns2__ModesListType__inversionMode,	///< xs:token value="inversionMode"
};

/// "urn:poc":PermutationSymmetryType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__PermutationSymmetryType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__PermutationSymmetryType
{
	ns2__PermutationSymmetryType__a,	///< xs:token value="a"
	ns2__PermutationSymmetryType__s,	///< xs:token value="s"
};

/// "urn:poc":ParticleNameType is a simpleType restriction of xs:string.
/// Note: enum values are prefixed with 'ns2__ParticleNameType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__ParticleNameType
{
	ns2__ParticleNameType__photon,	///< xs:string value="photon"
	ns2__ParticleNameType__electron,	///< xs:string value="electron"
	ns2__ParticleNameType__muon,	///< xs:string value="muon"
	ns2__ParticleNameType__positron,	///< xs:string value="positron"
};

/// "urn:poc":MultipoleType is a simpleType restriction of xs:string.
/// @brief Radiative transition multipole
/// Content pattern is "(E|M)[1-9]\\d*" (note: not automatically enforced)
typedef std::string ns2__MultipoleType "(E|M)[1-9]\\d*";

/// "urn:poc":IAEACodeType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__IAEACodeType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__IAEACodeType
{
	ns2__IAEACodeType__EGN,	///< xs:token value="EGN"
	ns2__IAEACodeType__EAS,	///< xs:token value="EAS"
	ns2__IAEACodeType__EBS,	///< xs:token value="EBS"
	ns2__IAEACodeType__EDX,	///< xs:token value="EDX"
	ns2__IAEACodeType__EEL,	///< xs:token value="EEL"
	ns2__IAEACodeType__ELB,	///< xs:token value="ELB"
	ns2__IAEACodeType__ETS,	///< xs:token value="ETS"
	ns2__IAEACodeType__EDT,	///< xs:token value="EDT"
	ns2__IAEACodeType__EFL,	///< xs:token value="EFL"
	ns2__IAEACodeType__EEX,	///< xs:token value="EEX"
	ns2__IAEACodeType__EIN,	///< xs:token value="EIN"
	ns2__IAEACodeType__EMI,	///< xs:token value="EMI"
	ns2__IAEACodeType__ENI,	///< xs:token value="ENI"
	ns2__IAEACodeType__EMT,	///< xs:token value="EMT"
	ns2__IAEACodeType__EUP,	///< xs:token value="EUP"
	ns2__IAEACodeType__EDP,	///< xs:token value="EDP"
	ns2__IAEACodeType__EIP,	///< xs:token value="EIP"
	ns2__IAEACodeType__ERC,	///< xs:token value="ERC"
	ns2__IAEACodeType__ERR,	///< xs:token value="ERR"
	ns2__IAEACodeType__ERD,	///< xs:token value="ERD"
	ns2__IAEACodeType__ERT,	///< xs:token value="ERT"
	ns2__IAEACodeType__ERO,	///< xs:token value="ERO"
	ns2__IAEACodeType__EDC,	///< xs:token value="EDC"
	ns2__IAEACodeType__EDS,	///< xs:token value="EDS"
	ns2__IAEACodeType__EDR,	///< xs:token value="EDR"
	ns2__IAEACodeType__EDA,	///< xs:token value="EDA"
	ns2__IAEACodeType__EDE,	///< xs:token value="EDE"
	ns2__IAEACodeType__EDI,	///< xs:token value="EDI"
	ns2__IAEACodeType__PGN,	///< xs:token value="PGN"
	ns2__IAEACodeType__PTS,	///< xs:token value="PTS"
	ns2__IAEACodeType__PDS,	///< xs:token value="PDS"
	ns2__IAEACodeType__PES,	///< xs:token value="PES"
	ns2__IAEACodeType__PMA,	///< xs:token value="PMA"
	ns2__IAEACodeType__PDT,	///< xs:token value="PDT"
	ns2__IAEACodeType__PFL,	///< xs:token value="PFL"
	ns2__IAEACodeType__PEX,	///< xs:token value="PEX"
	ns2__IAEACodeType__PIN,	///< xs:token value="PIN"
	ns2__IAEACodeType__PFF,	///< xs:token value="PFF"
	ns2__IAEACodeType__PEA,	///< xs:token value="PEA"
	ns2__IAEACodeType__PTA,	///< xs:token value="PTA"
	ns2__IAEACodeType__PAD,	///< xs:token value="PAD"
	ns2__IAEACodeType__PED,	///< xs:token value="PED"
	ns2__IAEACodeType__PNL,	///< xs:token value="PNL"
	ns2__IAEACodeType__PZE,	///< xs:token value="PZE"
	ns2__IAEACodeType__PSE,	///< xs:token value="PSE"
	ns2__IAEACodeType__PGF,	///< xs:token value="PGF"
	ns2__IAEACodeType__PTF,	///< xs:token value="PTF"
	ns2__IAEACodeType__HGN,	///< xs:token value="HGN"
	ns2__IAEACodeType__HAS,	///< xs:token value="HAS"
	ns2__IAEACodeType__HLB,	///< xs:token value="HLB"
	ns2__IAEACodeType__HDS,	///< xs:token value="HDS"
	ns2__IAEACodeType__HDX,	///< xs:token value="HDX"
	ns2__IAEACodeType__HES,	///< xs:token value="HES"
	ns2__IAEACodeType__HCX,	///< xs:token value="HCX"
	ns2__IAEACodeType__HUP,	///< xs:token value="HUP"
	ns2__IAEACodeType__HIR,	///< xs:token value="HIR"
	ns2__IAEACodeType__HEL,	///< xs:token value="HEL"
	ns2__IAEACodeType__HET,	///< xs:token value="HET"
	ns2__IAEACodeType__HIP,	///< xs:token value="HIP"
	ns2__IAEACodeType__HRC,	///< xs:token value="HRC"
	ns2__IAEACodeType__HTS,	///< xs:token value="HTS"
	ns2__IAEACodeType__HDT,	///< xs:token value="HDT"
	ns2__IAEACodeType__HFL,	///< xs:token value="HFL"
	ns2__IAEACodeType__HEX,	///< xs:token value="HEX"
	ns2__IAEACodeType__HIN,	///< xs:token value="HIN"
	ns2__IAEACodeType__HPN,	///< xs:token value="HPN"
	ns2__IAEACodeType__HST,	///< xs:token value="HST"
	ns2__IAEACodeType__HAT,	///< xs:token value="HAT"
	ns2__IAEACodeType__HAI,	///< xs:token value="HAI"
	ns2__IAEACodeType__HDI,	///< xs:token value="HDI"
	ns2__IAEACodeType__HDC,	///< xs:token value="HDC"
	ns2__IAEACodeType__HMN,	///< xs:token value="HMN"
};

/// "urn:poc":CodeType is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with 'ns2__CodeType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__CodeType
{
	ns2__CodeType__phem,	///< xs:token value="phem"
	ns2__CodeType__phab,	///< xs:token value="phab"
	ns2__CodeType__phsc,	///< xs:token value="phsc"
	ns2__CodeType__elas,	///< xs:token value="elas"
	ns2__CodeType__inel,	///< xs:token value="inel"
	ns2__CodeType__exci,	///< xs:token value="exci"
	ns2__CodeType__dexc,	///< xs:token value="dexc"
	ns2__CodeType__ioni,	///< xs:token value="ioni"
	ns2__CodeType__tran,	///< xs:token value="tran"
	ns2__CodeType__exch,	///< xs:token value="exch"
	ns2__CodeType__reco,	///< xs:token value="reco"
	ns2__CodeType__elat,	///< xs:token value="elat"
	ns2__CodeType__eldt,	///< xs:token value="eldt"
	ns2__CodeType__asso,	///< xs:token value="asso"
	ns2__CodeType__diss,	///< xs:token value="diss"
	ns2__CodeType__intr,	///< xs:token value="intr"
	ns2__CodeType__chem,	///< xs:token value="chem"
	ns2__CodeType__sure,	///< xs:token value="sure"
	ns2__CodeType__suem,	///< xs:token value="suem"
	ns2__CodeType__sudp,	///< xs:token value="sudp"
	ns2__CodeType__such,	///< xs:token value="such"
	ns2__CodeType__sope,	///< xs:token value="sope"
	ns2__CodeType___x0000,	///< xs:token value=""
};
/// @brief Reference to specific bibliographic items.

/// "urn:poc":sourceRef is a simpleType restriction of xs:IDREFS.
/// Content pattern is "B.+" (note: not automatically enforced)
typedef xsd__IDREFS _ns2__sourceRef "B.+";
/// @brief Reference to a specific method.

/// "urn:poc":methodRef is a simpleType restriction of xs:IDREF.
/// Content pattern is "M.+" (note: not automatically enforced)
typedef xsd__IDREF _ns2__methodRef "M.+";
/// @brief Reference to a specific fit function

/// "urn:poc":functionRef is a simpleType restriction of xs:IDREF.
/// Content pattern is "F.+" (note: not automatically enforced)
typedef xsd__IDREF _ns2__functionRef "F.+";
/// @brief Description of physical units. Use "unitless" for dimensionless quantities.

/// "urn:poc":units is a simpleType restriction of xs:token.
/// Note: enum values are prefixed with '_ns2__units' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum _ns2__units
{
	_ns2__units__undef,	///< xs:token value="undef"
	_ns2__units__eV_x002famu,	///< xs:token value="eV/amu"
	_ns2__units__keV_x002famu,	///< xs:token value="keV/amu"
	_ns2__units__MeV_x002famu,	///< xs:token value="MeV/amu"
	_ns2__units__eV,	///< xs:token value="eV"
	_ns2__units__keV,	///< xs:token value="keV"
	_ns2__units__MeV,	///< xs:token value="MeV"
	_ns2__units__au,	///< xs:token value="au"
	_ns2__units__1_x002fcm,	///< xs:token value="1/cm"
	_ns2__units__J,	///< xs:token value="J"
	_ns2__units__Ry,	///< xs:token value="Ry"
	_ns2__units__unitless,	///< xs:token value="unitless"
	_ns2__units__kJ_x002fmol,	///< xs:token value="kJ/mol"
	_ns2__units__kcal_x002fmol,	///< xs:token value="kcal/mol"
	_ns2__units__K,	///< xs:token value="K"
	_ns2__units__Hz,	///< xs:token value="Hz"
	_ns2__units__kHz,	///< xs:token value="kHz"
	_ns2__units__MHz,	///< xs:token value="MHz"
	_ns2__units__m,	///< xs:token value="m"
	_ns2__units__cm,	///< xs:token value="cm"
	_ns2__units__A,	///< xs:token value="A"
	_ns2__units__nm,	///< xs:token value="nm"
	_ns2__units__deg,	///< xs:token value="deg"
	_ns2__units__rad,	///< xs:token value="rad"
	_ns2__units__srad,	///< xs:token value="srad"
	_ns2__units__s,	///< xs:token value="s"
	_ns2__units__m3_x002fs,	///< xs:token value="m3/s"
	_ns2__units__cm3_x002fs,	///< xs:token value="cm3/s"
	_ns2__units__cm6_x002fs,	///< xs:token value="cm6/s"
	_ns2__units__m2,	///< xs:token value="m2"
	_ns2__units__cm2,	///< xs:token value="cm2"
	_ns2__units__b,	///< xs:token value="b"
	_ns2__units__Mb,	///< xs:token value="Mb"
	_ns2__units__1_x002fs,	///< xs:token value="1/s"
	_ns2__units__C_x002em,	///< xs:token value="C.m"
	_ns2__units__J_x002fT,	///< xs:token value="J/T"
	_ns2__units__C_x002em2,	///< xs:token value="C.m2"
	_ns2__units__m_x002fs,	///< xs:token value="m/s"
	_ns2__units__cm_x002fs,	///< xs:token value="cm/s"
	_ns2__units__C,	///< xs:token value="C"
	_ns2__units__electron,	///< xs:token value="electron"
	_ns2__units__g,	///< xs:token value="g"
	_ns2__units__amu,	///< xs:token value="amu"
	_ns2__units__kg,	///< xs:token value="kg"
	_ns2__units__1_x002fm2_x002fs,	///< xs:token value="1/m2/s"
	_ns2__units__1_x002fcm2_x002fs,	///< xs:token value="1/cm2/s"
	_ns2__units__J_x002fm2_x002fs,	///< xs:token value="J/m2/s"
	_ns2__units__J_x002fcm2_x002fs,	///< xs:token value="J/cm2/s"
	_ns2__units__1_x002fm2,	///< xs:token value="1/m2"
	_ns2__units__1_x002fcm2,	///< xs:token value="1/cm2"
	_ns2__units__J_x002fm2,	///< xs:token value="J/m2"
	_ns2__units__J_x002fcm2,	///< xs:token value="J/cm2"
	_ns2__units__W_x002fm2,	///< xs:token value="W/m2"
	_ns2__units__W_x002fcm2,	///< xs:token value="W/cm2"
	_ns2__units__W,	///< xs:token value="W"
};
/// @brief ID for a specific state/particle.

/// "urn:poc":stateID is a simpleType restriction of xs:ID.
/// Content pattern is "S.+" (note: not automatically enforced)
typedef xsd__ID _ns2__stateID "S.+";

/// "urn:poc":sourceID is a simpleType restriction of xs:ID.
/// Content pattern is "B.+" (note: not automatically enforced)
typedef xsd__ID _ns2__sourceID "B.+";
/// @brief ID for a specific method

/// "urn:poc":methodID is a simpleType restriction of xs:ID.
/// Content pattern is "M.+" (note: not automatically enforced)
typedef xsd__ID _ns2__methodID "M.+";
/// @brief ID for a specific function

/// "urn:poc":functionID is a simpleType restriction of xs:ID.
/// Content pattern is "F.+" (note: not automatically enforced)
typedef xsd__ID _ns2__functionID "F.+";

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/// "urn:poc":PrimaryType is a complexType.
/// class ns2__PrimaryType operations:
/// - soap_new_ns2__PrimaryType(soap*) allocate
/// - soap_new_ns2__PrimaryType(soap*, int num) allocate array
/// - soap_new_req_ns2__PrimaryType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__PrimaryType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__PrimaryType(soap*, ns2__PrimaryType*) deserialize from a stream
/// - int soap_write_ns2__PrimaryType(soap, ns2__PrimaryType*) serialize to a stream
class ns2__PrimaryType
{ public:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ChemicalElementType is a complexType.
/// @brief Description of a chemical element
/// class ns2__ChemicalElementType operations:
/// - soap_new_ns2__ChemicalElementType(soap*) allocate
/// - soap_new_ns2__ChemicalElementType(soap*, int num) allocate array
/// - soap_new_req_ns2__ChemicalElementType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ChemicalElementType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ChemicalElementType(soap*, ns2__ChemicalElementType*) deserialize from a stream
/// - int soap_write_ns2__ChemicalElementType(soap, ns2__ChemicalElementType*) serialize to a stream
class ns2__ChemicalElementType
{ public:
/// @brief Nuclear charge in units of electron charge
/// Element NuclearCharge of type xs:positiveInteger.
    xsd__positiveInteger                 NuclearCharge                  1;	///< Required element.
/// @brief Standard symbol of a chemical element (e.g., H or Ta)
/// Element ElementSymbol of type "":ElementSymbolType.
    ns2__ElementSymbolType*              ElementSymbol                  0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":DataSetsType is a complexType.
/// class ns2__DataSetsType operations:
/// - soap_new_ns2__DataSetsType(soap*) allocate
/// - soap_new_ns2__DataSetsType(soap*, int num) allocate array
/// - soap_new_req_ns2__DataSetsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__DataSetsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__DataSetsType(soap*, ns2__DataSetsType*) deserialize from a stream
/// - int soap_write_ns2__DataSetsType(soap, ns2__DataSetsType*) serialize to a stream
class ns2__DataSetsType
{ public:
/// @brief List of datasets of different nature (cross sections, rate coefficients, etc.)
/// Vector of ns2__DataSetType* with length 1..unbounded
    std::vector<ns2__DataSetType*      > DataSet                        1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":DataTableType is a complexType.
/// @brief Similar to DataType but for tabular type of data
/// class ns2__DataTableType operations:
/// - soap_new_ns2__DataTableType(soap*) allocate
/// - soap_new_ns2__DataTableType(soap*, int num) allocate array
/// - soap_new_req_ns2__DataTableType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__DataTableType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__DataTableType(soap*, ns2__DataTableType*) deserialize from a stream
/// - int soap_write_ns2__DataTableType(soap, ns2__DataTableType*) serialize to a stream
class ns2__DataTableType
{ public:
/// @brief List of data values. Example: 3 15 33.3 1e3
/// Element DataList of type "":DataListType.
    ns2__DataListType                    DataList                       1;	///< Required element.
/// @brief Error for each data point of the list
/// Element Error of type "":DataListType.
    ns2__DataListType*                   Error                          0;	///< Optional element.
/// @brief Negative error for each data point of
/// Element NegativeError of type "":DataListType.
    ns2__DataListType*                   NegativeError                  0;	///< Optional element.
/// @brief Positive error for each data point of the list
/// Element PositiveError of type "":DataListType.
    ns2__DataListType*                   PositiveError                  0;	///< Optional element.
/// @brief Additional description of the data list
/// Element 'DataDescription' has no type or ref (empty or with XML content).
    _XML                                 DataDescription                0;	///< Optional element.
/// Attribute reference "":units.
/// @brief Description of physical units. Use "unitless" for dimensionless quantities.
   @enum _ns2__units                     units                          1;	///< Required attribute.
/// Attribute parameter of type xs:string.
   @std::string*                         parameter                      0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":DataXYType is a complexType.
/// @brief Gives the structure of X Y data tables (several X are allowed)
/// class ns2__DataXYType operations:
/// - soap_new_ns2__DataXYType(soap*) allocate
/// - soap_new_ns2__DataXYType(soap*, int num) allocate array
/// - soap_new_req_ns2__DataXYType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__DataXYType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__DataXYType(soap*, ns2__DataXYType*) deserialize from a stream
/// - int soap_write_ns2__DataXYType(soap, ns2__DataXYType*) serialize to a stream
class ns2__DataXYType
{ public:
/// Vector of ns2__DataTableType* with length 1..unbounded
    std::vector<ns2__DataTableType*    > X                              1;
/// @brief Data value
/// Element Y of type "":DataTableType.
    ns2__DataTableType*                  Y                              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":FitParametersType is a complexType.
/// class ns2__FitParametersType operations:
/// - soap_new_ns2__FitParametersType(soap*) allocate
/// - soap_new_ns2__FitParametersType(soap*, int num) allocate array
/// - soap_new_req_ns2__FitParametersType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__FitParametersType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__FitParametersType(soap*, ns2__FitParametersType*) deserialize from a stream
/// - int soap_write_ns2__FitParametersType(soap, ns2__FitParametersType*) serialize to a stream
class ns2__FitParametersType
{ public:
/// Vector of double with length 0..unbounded
    std::vector<double                 > Parameter                      0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":FitValidityLimitsType is a complexType.
/// class ns2__FitValidityLimitsType operations:
/// - soap_new_ns2__FitValidityLimitsType(soap*) allocate
/// - soap_new_ns2__FitValidityLimitsType(soap*, int num) allocate array
/// - soap_new_req_ns2__FitValidityLimitsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__FitValidityLimitsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__FitValidityLimitsType(soap*, ns2__FitValidityLimitsType*) deserialize from a stream
/// - int soap_write_ns2__FitValidityLimitsType(soap, ns2__FitValidityLimitsType*) serialize to a stream
class ns2__FitValidityLimitsType
{ public:
/// @brief Lower limit of fit validity
/// Element LowerLimit of type xs:double.
    double*                              LowerLimit                     0;	///< Optional element.
/// @brief Upper limit of fit validity
/// Element UpperLimit of type xs:double.
    double*                              UpperLimit                     0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ArgumentsType is a complexType.
/// class ns2__ArgumentsType operations:
/// - soap_new_ns2__ArgumentsType(soap*) allocate
/// - soap_new_ns2__ArgumentsType(soap*, int num) allocate array
/// - soap_new_req_ns2__ArgumentsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ArgumentsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ArgumentsType(soap*, ns2__ArgumentsType*) deserialize from a stream
/// - int soap_write_ns2__ArgumentsType(soap, ns2__ArgumentsType*) serialize to a stream
class ns2__ArgumentsType
{ public:
/// Vector of ns2__ArgumentType* with length 1..unbounded
    std::vector<ns2__ArgumentType*     > Argument                       1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ArgumentType is a complexType.
/// class ns2__ArgumentType operations:
/// - soap_new_ns2__ArgumentType(soap*) allocate
/// - soap_new_ns2__ArgumentType(soap*, int num) allocate array
/// - soap_new_req_ns2__ArgumentType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ArgumentType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ArgumentType(soap*, ns2__ArgumentType*) deserialize from a stream
/// - int soap_write_ns2__ArgumentType(soap, ns2__ArgumentType*) serialize to a stream
class ns2__ArgumentType
{ public:
/// @brief Name of the argument. Example: a
/// Element 'Name' has no type or ref (empty or with XML content).
    _XML                                 Name                           1;	///< Required element.
/// @brief Further description of the argument if definition in `parameter` is not sufficient
/// Element 'Description' has no type or ref (empty or with XML content).
    _XML                                 Description                    0;	///< Optional element.
/// Attribute reference "":units.
/// @brief Description of physical units. Use "unitless" for dimensionless quantities.
   @enum _ns2__units                     units                          1;	///< Required attribute.
/// @brief type of units (surface, energy, time...)
/// Attribute 'parameter' has no type or ref: assuming string content.
   @std::string                          parameter                      0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ParametersType is a complexType.
/// class ns2__ParametersType operations:
/// - soap_new_ns2__ParametersType(soap*) allocate
/// - soap_new_ns2__ParametersType(soap*, int num) allocate array
/// - soap_new_req_ns2__ParametersType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ParametersType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ParametersType(soap*, ns2__ParametersType*) deserialize from a stream
/// - int soap_write_ns2__ParametersType(soap, ns2__ParametersType*) serialize to a stream
class ns2__ParametersType
{ public:
/// Vector of ns2__ParameterType* with length 1..unbounded
    std::vector<ns2__ParameterType*    > Parameter                      1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ParameterType is a complexType.
/// class ns2__ParameterType operations:
/// - soap_new_ns2__ParameterType(soap*) allocate
/// - soap_new_ns2__ParameterType(soap*, int num) allocate array
/// - soap_new_req_ns2__ParameterType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ParameterType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ParameterType(soap*, ns2__ParameterType*) deserialize from a stream
/// - int soap_write_ns2__ParameterType(soap, ns2__ParameterType*) serialize to a stream
class ns2__ParameterType
{ public:
/// @brief Name of a parameter. Example: a
/// Element Name of type xs:token.
    xsd__token                           Name                           1;	///< Required element.
/// @brief Description of a parameter
/// Element Description of type xs:string.
    std::string*                         Description                    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":jjCouplingType is a complexType.
/// class ns2__jjCouplingType operations:
/// - soap_new_ns2__jjCouplingType(soap*) allocate
/// - soap_new_ns2__jjCouplingType(soap*, int num) allocate array
/// - soap_new_req_ns2__jjCouplingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__jjCouplingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__jjCouplingType(soap*, ns2__jjCouplingType*) deserialize from a stream
/// - int soap_write_ns2__jjCouplingType(soap, ns2__jjCouplingType*) serialize to a stream
class ns2__jjCouplingType
{ public:
/// @brief Value of the total angular momentum
/// Vector of ns2__AngularMomentumType with length 2..unbounded
    std::vector<ns2__AngularMomentumType> j                              2;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":jKCouplingType is a complexType.
/// class ns2__jKCouplingType operations:
/// - soap_new_ns2__jKCouplingType(soap*) allocate
/// - soap_new_ns2__jKCouplingType(soap*, int num) allocate array
/// - soap_new_req_ns2__jKCouplingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__jKCouplingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__jKCouplingType(soap*, ns2__jKCouplingType*) deserialize from a stream
/// - int soap_write_ns2__jKCouplingType(soap, ns2__jKCouplingType*) serialize to a stream
class ns2__jKCouplingType
{ public:
/// @brief Value of the total angular momentum of the core
/// Element j of type "":AngularMomentumType.
    ns2__AngularMomentumType*            j                              0;	///< Optional element.
/// @brief Spin of the external electron(s)
/// Element S2 of type "":AngularMomentumType.
    ns2__AngularMomentumType*            S2                             0;	///< Optional element.
/// @brief Value of the K-number (j + orbital angular momentum of the external electron(s))
/// Element K of type "":AngularMomentumType.
    ns2__AngularMomentumType             K                              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":LKCouplingType is a complexType.
/// class ns2__LKCouplingType operations:
/// - soap_new_ns2__LKCouplingType(soap*) allocate
/// - soap_new_ns2__LKCouplingType(soap*, int num) allocate array
/// - soap_new_req_ns2__LKCouplingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__LKCouplingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__LKCouplingType(soap*, ns2__LKCouplingType*) deserialize from a stream
/// - int soap_write_ns2__LKCouplingType(soap, ns2__LKCouplingType*) serialize to a stream
class ns2__LKCouplingType
{ public:
/// @brief Value of the sum of orbital angular momenta of the core and external electron
/// Element L of type "":OrbitalAngularMomentumType.
    ns2__OrbitalAngularMomentumType*     L                              1;	///< Required element.
/// @brief Value of the K-number (L + spin of the core)
/// Element K of type "":AngularMomentumType.
    ns2__AngularMomentumType             K                              1;	///< Required element.
/// @brief Spin of the external electron(s)
/// Element S2 of type "":AngularMomentumType.
    ns2__AngularMomentumType*            S2                             0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":LSCouplingType is a complexType.
/// class ns2__LSCouplingType operations:
/// - soap_new_ns2__LSCouplingType(soap*) allocate
/// - soap_new_ns2__LSCouplingType(soap*, int num) allocate array
/// - soap_new_req_ns2__LSCouplingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__LSCouplingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__LSCouplingType(soap*, ns2__LSCouplingType*) deserialize from a stream
/// - int soap_write_ns2__LSCouplingType(soap, ns2__LSCouplingType*) serialize to a stream
class ns2__LSCouplingType
{ public:
/// @brief Orbital angular momentum of the term in LS-coupling
/// Element L of type "":OrbitalAngularMomentumType.
    ns2__OrbitalAngularMomentumType*     L                              1;	///< Required element.
/// @brief Spin angular momentum of the term in LS-coupling
/// Element S of type "":AngularMomentumType.
    ns2__AngularMomentumType             S                              1;	///< Required element.
/// @brief 2S+1
/// Element Multiplicity of type xs:positiveInteger.
    xsd__positiveInteger*                Multiplicity                   0;	///< Optional element.
/// @brief Seniority number
/// class _ns2__LSCouplingType_Seniority operations:
/// - soap_new__ns2__LSCouplingType_Seniority(soap*) allocate
/// - soap_new__ns2__LSCouplingType_Seniority(soap*, int num) allocate array
/// - soap_new_req__ns2__LSCouplingType_Seniority(soap*, ...) allocate, set required members
/// - soap_new_set__ns2__LSCouplingType_Seniority(soap*, ...) allocate, set all public members
/// - int soap_read__ns2__LSCouplingType_Seniority(soap*, _ns2__LSCouplingType_Seniority*) deserialize from a stream
/// - int soap_write__ns2__LSCouplingType_Seniority(soap, _ns2__LSCouplingType_Seniority*) serialize to a stream
    class _ns2__LSCouplingType_Seniority
    {
/// __item wraps 'xs:nonNegativeInteger' simpleContent.
    xsd__nonNegativeInteger              __item                        ;
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
    }                                   *Seniority                      0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":OrbitalAngularMomentumType is a complexType.
/// @brief non-negative integer (and a symbol)
/// class ns2__OrbitalAngularMomentumType operations:
/// - soap_new_ns2__OrbitalAngularMomentumType(soap*) allocate
/// - soap_new_ns2__OrbitalAngularMomentumType(soap*, int num) allocate array
/// - soap_new_req_ns2__OrbitalAngularMomentumType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__OrbitalAngularMomentumType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__OrbitalAngularMomentumType(soap*, ns2__OrbitalAngularMomentumType*) deserialize from a stream
/// - int soap_write_ns2__OrbitalAngularMomentumType(soap, ns2__OrbitalAngularMomentumType*) serialize to a stream
class ns2__OrbitalAngularMomentumType
{ public:
/// @brief Value of the orbital angular momentum
/// Element Value of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger              Value                          1;	///< Required element.
/// @brief Symbol of the orbital angular momentum
/// Element Symbol of type "":OrbitalAngularMomentumSymbolType.
    ns2__OrbitalAngularMomentumSymbolType*  Symbol                         0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":TermType is a complexType.
/// @brief Complex term for atomic term in different couplings (e.g., LS or jj).
/// class ns2__TermType operations:
/// - soap_new_ns2__TermType(soap*) allocate
/// - soap_new_ns2__TermType(soap*, int num) allocate array
/// - soap_new_req_ns2__TermType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__TermType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__TermType(soap*, ns2__TermType*) deserialize from a stream
/// - int soap_write_ns2__TermType(soap, ns2__TermType*) serialize to a stream
class ns2__TermType
{ public:
/// @brief Term in LS-coupling
/// Element LS of type "":LSCouplingType.
    ns2__LSCouplingType*                 LS                             0;	///< Optional element.
/// @brief Term in jj-coupling
/// Element jj of type "":jjCouplingType.
    ns2__jjCouplingType*                 jj                             0;	///< Optional element.
/// @brief Term in J1J2-coupling
/// Element J1J2 of type "":jjCouplingType.
    ns2__jjCouplingType*                 J1J2                           0;	///< Optional element.
/// @brief Term in jK-coupling
/// Element jK of type "":jKCouplingType.
    ns2__jKCouplingType*                 jK                             0;	///< Optional element.
/// @brief Term in LK-coupling
/// Element LK of type "":LKCouplingType.
    ns2__LKCouplingType*                 LK                             0;	///< Optional element.
/// @brief Arbitrary term label
/// Element TermLabel of type xs:string.
    std::string*                         TermLabel                      0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ReactantsType is a complexType.
/// class ns2__ReactantsType operations:
/// - soap_new_ns2__ReactantsType(soap*) allocate
/// - soap_new_ns2__ReactantsType(soap*, int num) allocate array
/// - soap_new_req_ns2__ReactantsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ReactantsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ReactantsType(soap*, ns2__ReactantsType*) deserialize from a stream
/// - int soap_write_ns2__ReactantsType(soap, ns2__ReactantsType*) serialize to a stream
class ns2__ReactantsType
{ public:
/// SEQUENCE <xs:sequence minOccurs="2" maxOccurs="unbounded">
    std::vector<                                                       
    class __ns2__ReactantsType_sequence
    {
/// @brief Reference to a specific state
/// Element StateRef of type "":StateRef.
    ns2__StateRef                        StateRef                       1;	///< Required element.
    }>                                   __ReactantsType_sequence       2;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ProductsType is a complexType.
/// class ns2__ProductsType operations:
/// - soap_new_ns2__ProductsType(soap*) allocate
/// - soap_new_ns2__ProductsType(soap*, int num) allocate array
/// - soap_new_req_ns2__ProductsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ProductsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ProductsType(soap*, ns2__ProductsType*) deserialize from a stream
/// - int soap_write_ns2__ProductsType(soap, ns2__ProductsType*) serialize to a stream
class ns2__ProductsType
{ public:
/// SEQUENCE <xs:sequence maxOccurs="unbounded">
    std::vector<                                                       
    class __ns2__ProductsType_sequence
    {
/// @brief Reference to a specific state
/// Element StateRef of type "":StateRef.
    ns2__StateRef                        StateRef                       1;	///< Required element.
    }>                                   __ProductsType_sequence       ;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AuthorType is a complexType.
/// class ns2__AuthorType operations:
/// - soap_new_ns2__AuthorType(soap*) allocate
/// - soap_new_ns2__AuthorType(soap*, int num) allocate array
/// - soap_new_req_ns2__AuthorType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AuthorType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AuthorType(soap*, ns2__AuthorType*) deserialize from a stream
/// - int soap_write_ns2__AuthorType(soap, ns2__AuthorType*) serialize to a stream
class ns2__AuthorType
{ public:
/// @brief Author's name. Example: A. Einstein
/// Element Name of type xs:string.
    std::string                          Name                           1;	///< Required element.
/// @brief Author's address. Example: AMD Unit, IAEA, Vienna, Austria
/// Element Address of type xs:string.
    std::string*                         Address                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":SourcesType is a complexType.
/// class ns2__SourcesType operations:
/// - soap_new_ns2__SourcesType(soap*) allocate
/// - soap_new_ns2__SourcesType(soap*, int num) allocate array
/// - soap_new_req_ns2__SourcesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SourcesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SourcesType(soap*, ns2__SourcesType*) deserialize from a stream
/// - int soap_write_ns2__SourcesType(soap, ns2__SourcesType*) serialize to a stream
class ns2__SourcesType
{ public:
/// @brief A bibliography (bibreference) entry
/// Vector of ns2__SourceType* with length 1..unbounded
    std::vector<ns2__SourceType*       > Source                         1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":SourceType is a complexType.
/// @brief Description of bibliography (references). Word "reference" is avoided
/// class ns2__SourceType operations:
/// - soap_new_ns2__SourceType(soap*) allocate
/// - soap_new_ns2__SourceType(soap*, int num) allocate array
/// - soap_new_req_ns2__SourceType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SourceType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SourceType(soap*, ns2__SourceType*) deserialize from a stream
/// - int soap_write_ns2__SourceType(soap, ns2__SourceType*) serialize to a stream
class ns2__SourceType
{ public:
/// @brief Bibliographic reference type. Example: journal
/// Element Category of type "":CategoryType.
    enum ns2__CategoryType               Category                       1;	///< Required element.
/// @brief Bibliographic reference name. Example: Physical Review
/// Element SourceName of type xs:string.
    std::string                          SourceName                     1;	///< Required element.
/// @brief Year of the bibliographic reference. Example: 2008
/// Element Year of type xs:gYear.
    xsd__gYear                           Year                           1;	///< Required element.
/// Element Authors of type "":AuthorsType.
    ns2__AuthorsType*                    Authors                        1;	///< Required element.
/// @brief Title
/// Element Title of type xs:string.
    std::string*                         Title                          0;	///< Optional element.
/// @brief Volume of the bibliographic reference. Example: 72A
/// Element Volume of type xs:string.
    std::string*                         Volume                         0;	///< Optional element.
/// @brief Digital Object Identifier. Example: doi:10.1016/j.adt.2007.11.003
/// Element DigitalObjectIdentifier of type xs:token.
    xsd__token*                          DigitalObjectIdentifier        0;	///< Optional element.
/// @brief Initial page of a bibliographic reference. Example: 22
/// Element PageBegin of type xs:string.
    std::string*                         PageBegin                      0;	///< Optional element.
/// @brief Final page of a bibliographic reference. Example: 23
/// Element PageEnd of type xs:string.
    std::string*                         PageEnd                        0;	///< Optional element.
/// @brief A Uniform Resource Identifier of a bibliographic reference. Example: http://www.iop.org/EJ/abstract/0953-4075/41/10/105002
/// Element UniformResourceIdentifier of type xs:anyURI.
    xsd__anyURI*                         UniformResourceIdentifier      0;	///< Optional element.
/// @brief Publisher of a bibliographic reference. Example: IOP Publishing Ltd
/// Element Publisher of type xs:string.
    std::string*                         Publisher                      0;	///< Optional element.
/// @brief City of publication. Example: Bristol.
/// Element City of type xs:string.
    std::string*                         City                           0;	///< Optional element.
/// Element Editors of type "":EditorsType.
    ns2__EditorsType*                    Editors                        0;	///< Optional element.
/// @brief Date of the reference
/// Element ProductionDate of type xs:date.
    xsd__date*                           ProductionDate                 0;	///< Optional element.
/// @brief Version of a database, code, etc.
/// Element Version of type xs:string.
    std::string*                         Version                        0;	///< Optional element.
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceID.
   @_ns2__sourceID                       sourceID                       1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AuthorsType is a complexType.
/// class ns2__AuthorsType operations:
/// - soap_new_ns2__AuthorsType(soap*) allocate
/// - soap_new_ns2__AuthorsType(soap*, int num) allocate array
/// - soap_new_req_ns2__AuthorsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AuthorsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AuthorsType(soap*, ns2__AuthorsType*) deserialize from a stream
/// - int soap_write_ns2__AuthorsType(soap, ns2__AuthorsType*) serialize to a stream
class ns2__AuthorsType
{ public:
/// @brief Author of bibliographic reference.
/// Vector of ns2__AuthorType* with length 1..unbounded
    std::vector<ns2__AuthorType*       > Author                         1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":EditorsType is a complexType.
/// class ns2__EditorsType operations:
/// - soap_new_ns2__EditorsType(soap*) allocate
/// - soap_new_ns2__EditorsType(soap*, int num) allocate array
/// - soap_new_req_ns2__EditorsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__EditorsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__EditorsType(soap*, ns2__EditorsType*) deserialize from a stream
/// - int soap_write_ns2__EditorsType(soap, ns2__EditorsType*) serialize to a stream
class ns2__EditorsType
{ public:
/// @brief Name of an editor
/// Vector of std::string with length 1..unbounded
    std::vector<std::string            > Name                           1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MethodsType is a complexType.
/// class ns2__MethodsType operations:
/// - soap_new_ns2__MethodsType(soap*) allocate
/// - soap_new_ns2__MethodsType(soap*, int num) allocate array
/// - soap_new_req_ns2__MethodsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MethodsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MethodsType(soap*, ns2__MethodsType*) deserialize from a stream
/// - int soap_write_ns2__MethodsType(soap, ns2__MethodsType*) serialize to a stream
class ns2__MethodsType
{ public:
/// Vector of ns2__MethodType* with length 1..unbounded
    std::vector<ns2__MethodType*       > Method                         1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MethodType is a complexType.
/// class ns2__MethodType operations:
/// - soap_new_ns2__MethodType(soap*) allocate
/// - soap_new_ns2__MethodType(soap*, int num) allocate array
/// - soap_new_req_ns2__MethodType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MethodType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MethodType(soap*, ns2__MethodType*) deserialize from a stream
/// - int soap_write_ns2__MethodType(soap, ns2__MethodType*) serialize to a stream
class ns2__MethodType
{ public:
/// @brief Enumerated list of method classifications. Example: theory.
/// Element Category of type "":MethodCategoryType.
    enum ns2__MethodCategoryType         Category                       1;	///< Required element.
/// @brief Method description. Example: Convergent Close Coupling.
/// Element Description of type xs:string.
    std::string                          Description                    1;	///< Required element.
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":methodID.
/// @brief ID for a specific method
   @_ns2__methodID                       methodID                       1;	///< Required attribute.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":functionRef.
/// @brief Reference to a specific fit function
   @_ns2__functionRef*                   functionRef                    0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":FunctionsType is a complexType.
/// class ns2__FunctionsType operations:
/// - soap_new_ns2__FunctionsType(soap*) allocate
/// - soap_new_ns2__FunctionsType(soap*, int num) allocate array
/// - soap_new_req_ns2__FunctionsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__FunctionsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__FunctionsType(soap*, ns2__FunctionsType*) deserialize from a stream
/// - int soap_write_ns2__FunctionsType(soap, ns2__FunctionsType*) serialize to a stream
class ns2__FunctionsType
{ public:
/// Vector of ns2__FunctionType* with length 1..unbounded
    std::vector<ns2__FunctionType*     > Function                       1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":IsotopeType is a complexType.
/// class ns2__IsotopeType operations:
/// - soap_new_ns2__IsotopeType(soap*) allocate
/// - soap_new_ns2__IsotopeType(soap*, int num) allocate array
/// - soap_new_req_ns2__IsotopeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__IsotopeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__IsotopeType(soap*, ns2__IsotopeType*) deserialize from a stream
/// - int soap_write_ns2__IsotopeType(soap, ns2__IsotopeType*) serialize to a stream
class ns2__IsotopeType
{ public:
/// @brief Parameters of a specific isotope
/// Element IsotopeParameters of type "":IsotopeParametersType.
    ns2__IsotopeParametersType*          IsotopeParameters              0;	///< Optional element.
/// @brief List of ionization states
/// Vector of ns2__IonStateType* with length 1..unbounded
    std::vector<ns2__IonStateType*     > IonState                       1;
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AtomicCoreType is a complexType.
/// class ns2__AtomicCoreType operations:
/// - soap_new_ns2__AtomicCoreType(soap*) allocate
/// - soap_new_ns2__AtomicCoreType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomicCoreType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomicCoreType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomicCoreType(soap*, ns2__AtomicCoreType*) deserialize from a stream
/// - int soap_write_ns2__AtomicCoreType(soap, ns2__AtomicCoreType*) serialize to a stream
class ns2__AtomicCoreType
{ public:
/// @brief Isoelectronic atom of the core. Example: Xe
/// Element ElementCore of type "":ElementSymbolType.
    ns2__ElementSymbolType*              ElementCore                    0;	///< Optional element.
/// @brief Configuration of the core
/// Element Configuration of type "":ConfigurationType.
    ns2__ConfigurationType*              Configuration                  0;	///< Optional element.
/// @brief Term of the core
/// Element Term of type "":TermType.
    ns2__TermType*                       Term                           0;	///< Optional element.
/// @brief Total angular momentum of the core
/// Element TotalAngularMomentum of type "":AngularMomentumType.
    ns2__AngularMomentumType*            TotalAngularMomentum           0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AtomicComponentType is a complexType.
/// @brief Description of a component of the atomic state wave function
/// class ns2__AtomicComponentType operations:
/// - soap_new_ns2__AtomicComponentType(soap*) allocate
/// - soap_new_ns2__AtomicComponentType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomicComponentType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomicComponentType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomicComponentType(soap*, ns2__AtomicComponentType*) deserialize from a stream
/// - int soap_write_ns2__AtomicComponentType(soap, ns2__AtomicComponentType*) serialize to a stream
class ns2__AtomicComponentType
{ public:
/// @brief Superconfiguration
/// Element SuperConfiguration of type "":SuperConfigurationType.
    ns2__SuperConfigurationType*         SuperConfiguration             0;	///< Optional element.
/// @brief Atomic configuration
/// Element Configuration of type "":ConfigurationType.
    ns2__ConfigurationType*              Configuration                  0;	///< Optional element.
/// @brief Atomic term
/// Element Term of type "":TermType.
    ns2__TermType*                       Term                           0;	///< Optional element.
/// @brief Expansion coefficient in the sum over the basis functions (signed or squared)
/// Element MixingCoefficient of type "":MixingCoefficientType.
    ns2__MixingCoefficientType*          MixingCoefficient              0;	///< Optional element.
/// @brief Comments on a specific component
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AtomicQuantumNumbersType is a complexType.
/// class ns2__AtomicQuantumNumbersType operations:
/// - soap_new_ns2__AtomicQuantumNumbersType(soap*) allocate
/// - soap_new_ns2__AtomicQuantumNumbersType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomicQuantumNumbersType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomicQuantumNumbersType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomicQuantumNumbersType(soap*, ns2__AtomicQuantumNumbersType*) deserialize from a stream
/// - int soap_write_ns2__AtomicQuantumNumbersType(soap, ns2__AtomicQuantumNumbersType*) serialize to a stream
class ns2__AtomicQuantumNumbersType
{ public:
/// @brief State parity. Example: odd
/// Element Parity of type "":ParityType.
    enum ns2__ParityType*                Parity                         0;	///< Optional element.
/// @brief Total angular momentum. Example: 2.5
/// Element TotalAngularMomentum of type "":AngularMomentumType.
    ns2__AngularMomentumType*            TotalAngularMomentum           0;	///< Optional element.
/// @brief Relativistic parameter kappa
/// Element Kappa of type "":AngularMomentumType.
    ns2__AngularMomentumType*            Kappa                          0;	///< Optional element.
/// @brief Hyperfine momentum. Example: 2
/// Element HyperfineMomentum of type "":AngularMomentumType.
    ns2__AngularMomentumType*            HyperfineMomentum              0;	///< Optional element.
/// @brief Magnetic quantum number. Example: -1
/// Element MagneticQuantumNumber of type "":AngularMomentumProjectionType.
    ns2__AngularMomentumProjectionType*  MagneticQuantumNumber          0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ConfigurationType is a complexType.
/// @brief Description of atomic configuration
/// class ns2__ConfigurationType operations:
/// - soap_new_ns2__ConfigurationType(soap*) allocate
/// - soap_new_ns2__ConfigurationType(soap*, int num) allocate array
/// - soap_new_req_ns2__ConfigurationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ConfigurationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ConfigurationType(soap*, ns2__ConfigurationType*) deserialize from a stream
/// - int soap_write_ns2__ConfigurationType(soap, ns2__ConfigurationType*) serialize to a stream
class ns2__ConfigurationType
{ public:
/// @brief Description of the configuration core
/// Element AtomicCore of type "":AtomicCoreType.
    ns2__AtomicCoreType*                 AtomicCore                     0;	///< Optional element.
/// @brief List of electron shells
/// Element Shells of type "":ShellsType.
    ns2__ShellsType*                     Shells                         0;	///< Optional element.
/// @brief Arbitrary configuration label
/// Element ConfigurationLabel of type xs:string.
    std::string*                         ConfigurationLabel             0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ShellsType is a complexType.
/// class ns2__ShellsType operations:
/// - soap_new_ns2__ShellsType(soap*) allocate
/// - soap_new_ns2__ShellsType(soap*, int num) allocate array
/// - soap_new_req_ns2__ShellsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ShellsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ShellsType(soap*, ns2__ShellsType*) deserialize from a stream
/// - int soap_write_ns2__ShellsType(soap, ns2__ShellsType*) serialize to a stream
class ns2__ShellsType
{ public:
/// @brief Atomic shell
/// Vector of ns2__ShellType* with length 1..unbounded
    std::vector<ns2__ShellType*        > Shell                          1;
/// SEQUENCE <xs:sequence minOccurs="0">
    std::vector<                                                       
    class __ns2__ShellsType_sequence
    {
/// Vector of ns2__ShellPairType* with length 1..unbounded
    std::vector<ns2__ShellPairType*    > ShellPair                      1;
    }>                                   __ShellsType_sequence          0;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ShellPairType is a complexType.
/// class ns2__ShellPairType operations:
/// - soap_new_ns2__ShellPairType(soap*) allocate
/// - soap_new_ns2__ShellPairType(soap*, int num) allocate array
/// - soap_new_req_ns2__ShellPairType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ShellPairType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ShellPairType(soap*, ns2__ShellPairType*) deserialize from a stream
/// - int soap_write_ns2__ShellPairType(soap, ns2__ShellPairType*) serialize to a stream
class ns2__ShellPairType
{ public:
/// Element Shell1 of type "":ShellType.
    ns2__ShellType*                      Shell1                         1;	///< Required element.
/// Element Shell2 of type "":ShellType.
    ns2__ShellType*                      Shell2                         1;	///< Required element.
/// Element ShellPairTerm of type "":TermType.
    ns2__TermType*                       ShellPairTerm                  1;	///< Required element.
/// @brief Identifier of the shell pair
/// Attribute shellPairID of type xs:ID.
   @xsd__ID                              shellPairID                    1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ShellType is a complexType.
/// @brief Complex type for atomic shell description.
/// class ns2__ShellType operations:
/// - soap_new_ns2__ShellType(soap*) allocate
/// - soap_new_ns2__ShellType(soap*, int num) allocate array
/// - soap_new_req_ns2__ShellType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ShellType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ShellType(soap*, ns2__ShellType*) deserialize from a stream
/// - int soap_write_ns2__ShellType(soap, ns2__ShellType*) serialize to a stream
class ns2__ShellType
{ public:
/// @brief Principal quantum number
/// Element PrincipalQuantumNumber of type "":PrincipalQuantumNumberType.
    ns2__PrincipalQuantumNumberType      PrincipalQuantumNumber         1;	///< Required element.
/// Element OrbitalAngularMomentum of type "":OrbitalAngularMomentumType.
    ns2__OrbitalAngularMomentumType*     OrbitalAngularMomentum         1;	///< Required element.
/// @brief Number of electrons in the shell
/// Element NumberOfElectrons of type xs:double.
    double                               NumberOfElectrons              1;	///< Required element.
/// @brief Parity of a shell
/// Element Parity of type "":ParityType.
    enum ns2__ParityType*                Parity                         0;	///< Optional element.
/// @brief Relativistic parameter
/// Element Kappa of type "":AngularMomentumType.
    ns2__AngularMomentumType*            Kappa                          0;	///< Optional element.
/// @brief Total angular momentum of the shell
/// Element TotalAngularMomentum of type "":AngularMomentumType.
    ns2__AngularMomentumType*            TotalAngularMomentum           0;	///< Optional element.
/// @brief Term of the shell
/// Element ShellTerm of type "":TermType.
    ns2__TermType*                       ShellTerm                      0;	///< Optional element.
/// @brief Shell identifier
/// Attribute shellID of type xs:ID.
   @xsd__ID*                             shellID                        0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":SuperConfigurationType is a complexType.
/// class ns2__SuperConfigurationType operations:
/// - soap_new_ns2__SuperConfigurationType(soap*) allocate
/// - soap_new_ns2__SuperConfigurationType(soap*, int num) allocate array
/// - soap_new_req_ns2__SuperConfigurationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SuperConfigurationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SuperConfigurationType(soap*, ns2__SuperConfigurationType*) deserialize from a stream
/// - int soap_write_ns2__SuperConfigurationType(soap, ns2__SuperConfigurationType*) serialize to a stream
class ns2__SuperConfigurationType
{ public:
/// @brief List of supershells
/// Vector of ns2__SuperShellType* with length 1..unbounded
    std::vector<ns2__SuperShellType*   > SuperShell                     1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":SuperShellType is a complexType.
/// class ns2__SuperShellType operations:
/// - soap_new_ns2__SuperShellType(soap*) allocate
/// - soap_new_ns2__SuperShellType(soap*, int num) allocate array
/// - soap_new_req_ns2__SuperShellType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SuperShellType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SuperShellType(soap*, ns2__SuperShellType*) deserialize from a stream
/// - int soap_write_ns2__SuperShellType(soap, ns2__SuperShellType*) serialize to a stream
class ns2__SuperShellType
{ public:
/// @brief Principal quantum number. Example: 4
/// Element PrincipalQuantumNumber of type xs:positiveInteger.
    xsd__positiveInteger                 PrincipalQuantumNumber         1;	///< Required element.
/// @brief Number of electrons. May be noninteger to account for plasma effects. Example: 3
/// Element NumberOfElectrons of type xs:double.
    double                               NumberOfElectrons              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AsymmetricProjectionType is a complexType.
/// class ns2__AsymmetricProjectionType operations:
/// - soap_new_ns2__AsymmetricProjectionType(soap*) allocate
/// - soap_new_ns2__AsymmetricProjectionType(soap*, int num) allocate array
/// - soap_new_req_ns2__AsymmetricProjectionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AsymmetricProjectionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AsymmetricProjectionType(soap*, ns2__AsymmetricProjectionType*) deserialize from a stream
/// - int soap_write_ns2__AsymmetricProjectionType(soap, ns2__AsymmetricProjectionType*) serialize to a stream
class ns2__AsymmetricProjectionType
{ public:
/// Element AsymmetricTau of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      AsymmetricTau                  0;	///< Optional element.
/// Element AsymmetricKa of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     AsymmetricKa                   1;	///< Required element.
/// Element AsymmetricKc of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     AsymmetricKc                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HinderedMotionType is a complexType.
/// class ns2__HinderedMotionType operations:
/// - soap_new_ns2__HinderedMotionType(soap*) allocate
/// - soap_new_ns2__HinderedMotionType(soap*, int num) allocate array
/// - soap_new_req_ns2__HinderedMotionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HinderedMotionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HinderedMotionType(soap*, ns2__HinderedMotionType*) deserialize from a stream
/// - int soap_write_ns2__HinderedMotionType(soap, ns2__HinderedMotionType*) serialize to a stream
class ns2__HinderedMotionType
{ public:
/// Element HinderedK1 of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     HinderedK1                     1;	///< Required element.
/// Element HinderedK2 of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     HinderedK2                     1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":AtomArrayType is a complexType.
/// class ns2__AtomArrayType operations:
/// - soap_new_ns2__AtomArrayType(soap*) allocate
/// - soap_new_ns2__AtomArrayType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomArrayType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomArrayType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomArrayType(soap*, ns2__AtomArrayType*) deserialize from a stream
/// - int soap_write_ns2__AtomArrayType(soap, ns2__AtomArrayType*) serialize to a stream
class ns2__AtomArrayType
{ public:
/// SEQUENCE <xs:sequence maxOccurs="unbounded">
    std::vector<                                                       
    class __ns2__AtomArrayType_sequence
    {
/// Element AtomN of type "":AtomNType.
    ns2__AtomNType*                      AtomN                          1;	///< Required element.
    }>                                   __AtomArrayType_sequence      ;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":BondType is a complexType.
/// class ns2__BondType operations:
/// - soap_new_ns2__BondType(soap*) allocate
/// - soap_new_ns2__BondType(soap*, int num) allocate array
/// - soap_new_req_ns2__BondType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__BondType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__BondType(soap*, ns2__BondType*) deserialize from a stream
/// - int soap_write_ns2__BondType(soap, ns2__BondType*) serialize to a stream
class ns2__BondType
{ public:
/// Attribute atomRefs2 of type xs:IDREFS.
   @xsd__IDREFS*                         atomRefs2                      0;	///< Optional attribute.
/// Attribute order of type xs:string.
   @std::string*                         order                          0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":BondArrayType is a complexType.
/// class ns2__BondArrayType operations:
/// - soap_new_ns2__BondArrayType(soap*) allocate
/// - soap_new_ns2__BondArrayType(soap*, int num) allocate array
/// - soap_new_req_ns2__BondArrayType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__BondArrayType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__BondArrayType(soap*, ns2__BondArrayType*) deserialize from a stream
/// - int soap_write_ns2__BondArrayType(soap, ns2__BondArrayType*) serialize to a stream
class ns2__BondArrayType
{ public:
/// SEQUENCE <xs:sequence maxOccurs="unbounded">
    std::vector<                                                       
    class __ns2__BondArrayType_sequence
    {
/// Element Bond of type "":BondType.
    ns2__BondType*                       Bond                           1;	///< Required element.
    }>                                   __BondArrayType_sequence      ;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":C2SymmetriesType is a complexType.
/// class ns2__C2SymmetriesType operations:
/// - soap_new_ns2__C2SymmetriesType(soap*) allocate
/// - soap_new_ns2__C2SymmetriesType(soap*, int num) allocate array
/// - soap_new_req_ns2__C2SymmetriesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__C2SymmetriesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__C2SymmetriesType(soap*, ns2__C2SymmetriesType*) deserialize from a stream
/// - int soap_write_ns2__C2SymmetriesType(soap, ns2__C2SymmetriesType*) serialize to a stream
class ns2__C2SymmetriesType
{ public:
/// Element C2bSymmetry of type "":C2SymmetryType.
    enum ns2__C2SymmetryType             C2bSymmetry                    1;	///< Required element.
/// @brief Vol II, p 51
/// Element C2cSymmetry of type "":C2SymmetryType.
    enum ns2__C2SymmetryType             C2cSymmetry                    1;	///< Required element.
/// Element C2aSymmetry of type "":C2SymmetryType.
    enum ns2__C2SymmetryType             C2aSymmetry                    1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":DiatomAndLinearPolyatomicType is a complexType.
/// class ns2__DiatomAndLinearPolyatomicType operations:
/// - soap_new_ns2__DiatomAndLinearPolyatomicType(soap*) allocate
/// - soap_new_ns2__DiatomAndLinearPolyatomicType(soap*, int num) allocate array
/// - soap_new_req_ns2__DiatomAndLinearPolyatomicType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__DiatomAndLinearPolyatomicType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__DiatomAndLinearPolyatomicType(soap*, ns2__DiatomAndLinearPolyatomicType*) deserialize from a stream
/// - int soap_write_ns2__DiatomAndLinearPolyatomicType(soap, ns2__DiatomAndLinearPolyatomicType*) serialize to a stream
class ns2__DiatomAndLinearPolyatomicType
{ public:
/// CHOICE <xs:choice>
   $int                                  __union_DiatomAndLinearPolyatomicType;	///< Union _ns2__union_DiatomAndLinearPolyatomicType selector: set to SOAP_UNION__ns2__union_DiatomAndLinearPolyatomicType_<fieldname>
/// Union for choice in type ns2__DiatomAndLinearPolyatomicType
    union _ns2__union_DiatomAndLinearPolyatomicType
    {
/// Element LinearNoElecNoHyperF of type "":LinearNoElecNoHyperFType.
    ns2__LinearNoElecNoHyperFType*       LinearNoElecNoHyperF           1;	///< Required element.
/// Element LinearNoElecHyperF of type "":LinearNoElecHyperFType.
    ns2__LinearNoElecHyperFType*         LinearNoElecHyperF             1;	///< Required element.
/// Element LinearElecCoupling of type "":LinearElecCouplingType.
    ns2__LinearElecCouplingType*         LinearElecCoupling             1;	///< Required element.
    }                                    union_DiatomAndLinearPolyatomicType;
//  END OF CHOICE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ElectronicCharacterisationType is a complexType.
/// class ns2__ElectronicCharacterisationType operations:
/// - soap_new_ns2__ElectronicCharacterisationType(soap*) allocate
/// - soap_new_ns2__ElectronicCharacterisationType(soap*, int num) allocate array
/// - soap_new_req_ns2__ElectronicCharacterisationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ElectronicCharacterisationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ElectronicCharacterisationType(soap*, ns2__ElectronicCharacterisationType*) deserialize from a stream
/// - int soap_write_ns2__ElectronicCharacterisationType(soap, ns2__ElectronicCharacterisationType*) serialize to a stream
class ns2__ElectronicCharacterisationType
{ public:
/// Element TermSymbol of type "":SymbolType.
    ns2__SymbolType*                     TermSymbol                     0;	///< Optional element.
/// Element Configuration of type "":ReferencedTextType.
    ns2__ReferencedTextType*             Configuration                  0;	///< Optional element.
/// Element Conformation of type xs:string.
    std::string*                         Conformation                   0;	///< Optional element.
/// Element SymmetryGroup of type "":SymbolType.
    ns2__SymbolType*                     SymmetryGroup                  0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ElectronicComponentType is a complexType.
/// class ns2__ElectronicComponentType operations:
/// - soap_new_ns2__ElectronicComponentType(soap*) allocate
/// - soap_new_ns2__ElectronicComponentType(soap*, int num) allocate array
/// - soap_new_req_ns2__ElectronicComponentType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ElectronicComponentType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ElectronicComponentType(soap*, ns2__ElectronicComponentType*) deserialize from a stream
/// - int soap_write_ns2__ElectronicComponentType(soap, ns2__ElectronicComponentType*) serialize to a stream
class ns2__ElectronicComponentType
{ public:
/// Element Description of type xs:token.
    xsd__token*                          Description                    0;	///< Optional element.
/// Element SerialQuantumNumber of type xs:string.
    std::string*                         SerialQuantumNumber            0;	///< Optional element.
/// Element MixingCoefficient of type "":MixingCoefficientType.
    ns2__MixingCoefficientType*          MixingCoefficient              0;	///< Optional element.
/// Element ElectronicCharacterisation of type "":ElectronicCharacterisationType.
    ns2__ElectronicCharacterisationType*  ElectronicCharacterisation     0;	///< Optional element.
/// Element TotalMolecularProjectionL of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalMolecularProjectionL      0;	///< Optional element.
/// Element VibrationalHome of type "":VibrationalHomeType.
    ns2__VibrationalHomeType*            VibrationalHome                0;	///< Optional element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ElectronicHomeType is a complexType.
/// class ns2__ElectronicHomeType operations:
/// - soap_new_ns2__ElectronicHomeType(soap*) allocate
/// - soap_new_ns2__ElectronicHomeType(soap*, int num) allocate array
/// - soap_new_req_ns2__ElectronicHomeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ElectronicHomeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ElectronicHomeType(soap*, ns2__ElectronicHomeType*) deserialize from a stream
/// - int soap_write_ns2__ElectronicHomeType(soap, ns2__ElectronicHomeType*) serialize to a stream
class ns2__ElectronicHomeType
{ public:
/// Vector of ns2__ElectronicComponentType* with length 1..unbounded
    std::vector<ns2__ElectronicComponentType*> ElectronicComponent            1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MolecularChemicalSpeciesType is a complexType.
/// class ns2__MolecularChemicalSpeciesType operations:
/// - soap_new_ns2__MolecularChemicalSpeciesType(soap*) allocate
/// - soap_new_ns2__MolecularChemicalSpeciesType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularChemicalSpeciesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularChemicalSpeciesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularChemicalSpeciesType(soap*, ns2__MolecularChemicalSpeciesType*) deserialize from a stream
/// - int soap_write_ns2__MolecularChemicalSpeciesType(soap, ns2__MolecularChemicalSpeciesType*) serialize to a stream
class ns2__MolecularChemicalSpeciesType
{ public:
/// Element OrdinaryStructuralFormula of type "":ReferencedTextType.
    ns2__ReferencedTextType*             OrdinaryStructuralFormula      1;	///< Required element.
/// Element StoichiometricFormula of type xs:string.
    std::string                          StoichiometricFormula          1;	///< Required element.
/// Element IonCharge of type xs:integer.
    xsd__integer*                        IonCharge                      0;	///< Optional element.
/// Element ChemicalName of type "":ReferencedTextType.
    ns2__ReferencedTextType*             ChemicalName                   0;	///< Optional element.
/// Element IUPACName of type "":ReferencedTextType.
    ns2__ReferencedTextType*             IUPACName                      0;	///< Optional element.
/// Element URLFigure of type xs:anyURI.
    xsd__anyURI*                         URLFigure                      0;	///< Optional element.
/// Element InChI of type "":ReferencedTextType.
    ns2__ReferencedTextType*             InChI                          0;	///< Optional element.
/// Element InChIKey of type "":ReferencedTextType.
    ns2__ReferencedTextType*             InChIKey                       0;	///< Optional element.
/// Element CASRegistryNumber of type "":ReferencedTextType.
    ns2__ReferencedTextType*             CASRegistryNumber              0;	///< Optional element.
/// Element CNPIGroup of type "":SymbolType.
    ns2__SymbolType*                     CNPIGroup                      0;	///< Optional element.
/// Element MoleculeNuclearSpins of type "":MoleculeNuclearSpinsType.
    ns2__MoleculeNuclearSpinsType*       MoleculeNuclearSpins           0;	///< Optional element.
/// Element StableMolecularProperties of type "":MolecularPropertiesType.
    ns2__MolecularPropertiesType*        StableMolecularProperties      0;	///< Optional element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MolecularProjectionType is a complexType.
/// class ns2__MolecularProjectionType operations:
/// - soap_new_ns2__MolecularProjectionType(soap*) allocate
/// - soap_new_ns2__MolecularProjectionType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularProjectionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularProjectionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularProjectionType(soap*, ns2__MolecularProjectionType*) deserialize from a stream
/// - int soap_write_ns2__MolecularProjectionType(soap, ns2__MolecularProjectionType*) serialize to a stream
class ns2__MolecularProjectionType
{ public:
/// Element TotalMolecularProjectionN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalMolecularProjectionN      0;	///< Optional element.
/// Element AsymmetricProjection of type "":AsymmetricProjectionType.
    ns2__AsymmetricProjectionType*       AsymmetricProjection           0;	///< Optional element.
/// Element HinderedMotion of type "":HinderedMotionType.
    ns2__HinderedMotionType*             HinderedMotion                 0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MolecularPropertiesType is a complexType.
/// class ns2__MolecularPropertiesType operations:
/// - soap_new_ns2__MolecularPropertiesType(soap*) allocate
/// - soap_new_ns2__MolecularPropertiesType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularPropertiesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularPropertiesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularPropertiesType(soap*, ns2__MolecularPropertiesType*) deserialize from a stream
/// - int soap_write_ns2__MolecularPropertiesType(soap, ns2__MolecularPropertiesType*) serialize to a stream
class ns2__MolecularPropertiesType
{ public:
/// Element MolecularWeight of type "":DataType.
    ns2__DataType*                       MolecularWeight                0;	///< Optional element.
/// SEQUENCE <xs:sequence maxOccurs="unbounded">
    std::vector<                                                       
    class __ns2__MolecularPropertiesType_sequence
    {
/// Element OtherProperties of type "":CharacterisationType.
    ns2__CharacterisationType*           OtherProperties                0;	///< Optional element.
    }>                                   __MolecularPropertiesType_sequence;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MolecularStateCharacterisationType is a complexType.
/// class ns2__MolecularStateCharacterisationType operations:
/// - soap_new_ns2__MolecularStateCharacterisationType(soap*) allocate
/// - soap_new_ns2__MolecularStateCharacterisationType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularStateCharacterisationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularStateCharacterisationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularStateCharacterisationType(soap*, ns2__MolecularStateCharacterisationType*) deserialize from a stream
/// - int soap_write_ns2__MolecularStateCharacterisationType(soap, ns2__MolecularStateCharacterisationType*) serialize to a stream
class ns2__MolecularStateCharacterisationType
{ public:
/// Element StateEnergy of type "":StateEnergyType.
    ns2__StateEnergyType*                StateEnergy                    0;	///< Optional element.
/// Element TotalStatisticalWeight of type xs:positiveInteger.
    xsd__positiveInteger*                TotalStatisticalWeight         0;	///< Optional element.
/// Element NuclearStatisticalWeight of type xs:positiveInteger.
    xsd__positiveInteger*                NuclearStatisticalWeight       0;	///< Optional element.
/// Element NuclearSpinSymmetry of type xs:string.
    std::string*                         NuclearSpinSymmetry            0;	///< Optional element.
/// Element LifeTime of type "":DataType.
    ns2__DataType*                       LifeTime                       0;	///< Optional element.
/// Vector of ns2__CharacterisationType* with length 0..unbounded
    std::vector<ns2__CharacterisationType*> Parameters                     0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MolecularStateCharacterisation-oldType is a complexType.
/// class ns2__MolecularStateCharacterisation_oldType operations:
/// - soap_new_ns2__MolecularStateCharacterisation_oldType(soap*) allocate
/// - soap_new_ns2__MolecularStateCharacterisation_oldType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularStateCharacterisation_oldType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularStateCharacterisation_oldType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularStateCharacterisation_oldType(soap*, ns2__MolecularStateCharacterisation_oldType*) deserialize from a stream
/// - int soap_write_ns2__MolecularStateCharacterisation_oldType(soap, ns2__MolecularStateCharacterisation_oldType*) serialize to a stream
class ns2__MolecularStateCharacterisation_oldType
{ public:
/// Element StateEnergy of type "":StateEnergyType.
    ns2__StateEnergyType*                StateEnergy                    0;	///< Optional element.
/// Element TotalStatisticalWeight of type xs:positiveInteger.
    xsd__positiveInteger*                TotalStatisticalWeight         0;	///< Optional element.
/// Element NuclearStatisticalWeight of type xs:positiveInteger.
    xsd__positiveInteger*                NuclearStatisticalWeight       0;	///< Optional element.
/// Element PseudoStatisticalWeight of type "":PseudoStatisticalWeightType.
    ns2__PseudoStatisticalWeightType*    PseudoStatisticalWeight        0;	///< Optional element.
/// Element PseudoNuclearStatisticalWeight of type "":PseudoStatisticalWeightType.
    ns2__PseudoStatisticalWeightType*    PseudoNuclearStatisticalWeight 0;	///< Optional element.
/// Element NuclearSpinSymmetry of type xs:string.
    std::string*                         NuclearSpinSymmetry            0;	///< Optional element.
/// Element LifeTime of type "":DataType.
    ns2__DataType*                       LifeTime                       0;	///< Optional element.
/// Vector of ns2__CharacterisationType* with length 0..unbounded
    std::vector<ns2__CharacterisationType*> Parameters                     0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MoleculeNuclearSpinsType is a complexType.
/// class ns2__MoleculeNuclearSpinsType operations:
/// - soap_new_ns2__MoleculeNuclearSpinsType(soap*) allocate
/// - soap_new_ns2__MoleculeNuclearSpinsType(soap*, int num) allocate array
/// - soap_new_req_ns2__MoleculeNuclearSpinsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MoleculeNuclearSpinsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MoleculeNuclearSpinsType(soap*, ns2__MoleculeNuclearSpinsType*) deserialize from a stream
/// - int soap_write_ns2__MoleculeNuclearSpinsType(soap, ns2__MoleculeNuclearSpinsType*) serialize to a stream
class ns2__MoleculeNuclearSpinsType
{ public:
/// Element AtomArray of type "":AtomArrayType.
    ns2__AtomArrayType*                  AtomArray                      1;	///< Required element.
/// Element BondArray of type "":BondArrayType.
    ns2__BondArrayType*                  BondArray                      0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":NonLinearPolyatomicType is a complexType.
/// class ns2__NonLinearPolyatomicType operations:
/// - soap_new_ns2__NonLinearPolyatomicType(soap*) allocate
/// - soap_new_ns2__NonLinearPolyatomicType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearPolyatomicType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearPolyatomicType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearPolyatomicType(soap*, ns2__NonLinearPolyatomicType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearPolyatomicType(soap, ns2__NonLinearPolyatomicType*) serialize to a stream
class ns2__NonLinearPolyatomicType
{ public:
/// CHOICE <xs:choice>
   $int                                  __union_NonLinearPolyatomicType;	///< Union _ns2__union_NonLinearPolyatomicType selector: set to SOAP_UNION__ns2__union_NonLinearPolyatomicType_<fieldname>
/// Union for choice in type ns2__NonLinearPolyatomicType
    union _ns2__union_NonLinearPolyatomicType
    {
/// Element NonLinearNoElecNoHyperF of type "":NonLinearNoElecNoHyperFType.
    ns2__NonLinearNoElecNoHyperFType*    NonLinearNoElecNoHyperF        1;	///< Required element.
/// Element NonLinearNoElecHyperF of type "":NonLinearNoElecHyperFType.
    ns2__NonLinearNoElecHyperFType*      NonLinearNoElecHyperF          1;	///< Required element.
/// Element NonLinearElecNoHyperF of type "":NonLinearElecNoHyperFType.
    ns2__NonLinearElecNoHyperFType*      NonLinearElecNoHyperF          1;	///< Required element.
/// Element NonLinearElecHyperF of type "":NonLinearElecHyperFType.
    ns2__NonLinearElecHyperFType*        NonLinearElecHyperF            1;	///< Required element.
    }                                    union_NonLinearPolyatomicType ;
//  END OF CHOICE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":RotationalCharacterisationType is a complexType.
/// class ns2__RotationalCharacterisationType operations:
/// - soap_new_ns2__RotationalCharacterisationType(soap*) allocate
/// - soap_new_ns2__RotationalCharacterisationType(soap*, int num) allocate array
/// - soap_new_req_ns2__RotationalCharacterisationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RotationalCharacterisationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RotationalCharacterisationType(soap*, ns2__RotationalCharacterisationType*) deserialize from a stream
/// - int soap_write_ns2__RotationalCharacterisationType(soap, ns2__RotationalCharacterisationType*) serialize to a stream
class ns2__RotationalCharacterisationType
{ public:
/// Element RovibrationalSpeciesNotation of type "":SymbolType.
    ns2__SymbolType*                     RovibrationalSpeciesNotation   0;	///< Optional element.
/// Element RovibronicSpeciesNotation of type "":SymbolType.
    ns2__SymbolType*                     RovibronicSpeciesNotation      0;	///< Optional element.
/// Element RovibronicAngularMomentumP of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      RovibronicAngularMomentumP     0;	///< Optional element.
/// @brief corresponds to (a) or (s)
/// Element PermutationSymmetry of type "":PermutationSymmetryType.
    enum ns2__PermutationSymmetryType*   PermutationSymmetry            0;	///< Optional element.
/// @brief corresponds to (a) or (s)
/// Element InversionSymmetry of type "":PermutationSymmetryType.
    enum ns2__PermutationSymmetryType*   InversionSymmetry              0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":RotationalComponentType is a complexType.
/// class ns2__RotationalComponentType operations:
/// - soap_new_ns2__RotationalComponentType(soap*) allocate
/// - soap_new_ns2__RotationalComponentType(soap*, int num) allocate array
/// - soap_new_req_ns2__RotationalComponentType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RotationalComponentType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RotationalComponentType(soap*, ns2__RotationalComponentType*) deserialize from a stream
/// - int soap_write_ns2__RotationalComponentType(soap, ns2__RotationalComponentType*) serialize to a stream
class ns2__RotationalComponentType
{ public:
/// CHOICE <xs:choice>
   $int                                  __union_RotationalComponentType;	///< Union _ns2__union_RotationalComponentType selector: set to SOAP_UNION__ns2__union_RotationalComponentType_<fieldname>
    union _ns2__union_RotationalComponentType
    {
/// Element DiatomAndLinearPolyatomic of type "":DiatomAndLinearPolyatomicType.
    ns2__DiatomAndLinearPolyatomicType*  DiatomAndLinearPolyatomic      1;	///< Required element.
/// Element NonLinearPolyatomic of type "":NonLinearPolyatomicType.
    ns2__NonLinearPolyatomicType*        NonLinearPolyatomic            1;	///< Required element.
    }                                    union_RotationalComponentType ;
//  END OF CHOICE
/// Element MixingCoefficient of type "":MixingCoefficientType.
    ns2__MixingCoefficientType*          MixingCoefficient              0;	///< Optional element.
/// Element SerialQuantumNumber of type xs:string.
    std::string*                         SerialQuantumNumber            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":RotationalHomeType is a complexType.
/// class ns2__RotationalHomeType operations:
/// - soap_new_ns2__RotationalHomeType(soap*) allocate
/// - soap_new_ns2__RotationalHomeType(soap*, int num) allocate array
/// - soap_new_req_ns2__RotationalHomeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RotationalHomeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RotationalHomeType(soap*, ns2__RotationalHomeType*) deserialize from a stream
/// - int soap_write_ns2__RotationalHomeType(soap, ns2__RotationalHomeType*) serialize to a stream
class ns2__RotationalHomeType
{ public:
/// Element Description of type xs:string.
    std::string*                         Description                    0;	///< Optional element.
/// Element RotationalCharacterisation of type "":RotationalCharacterisationType.
    ns2__RotationalCharacterisationType*  RotationalCharacterisation     0;	///< Optional element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// Vector of ns2__RotationalComponentType* with length 1..unbounded
    std::vector<ns2__RotationalComponentType*> RotationalComponent            1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MolecularQuantumNumberType is a complexType.
/// class ns2__MolecularQuantumNumberType operations:
/// - soap_new_ns2__MolecularQuantumNumberType(soap*) allocate
/// - soap_new_ns2__MolecularQuantumNumberType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularQuantumNumberType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularQuantumNumberType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularQuantumNumberType(soap*, ns2__MolecularQuantumNumberType*) deserialize from a stream
/// - int soap_write_ns2__MolecularQuantumNumberType(soap, ns2__MolecularQuantumNumberType*) serialize to a stream
class ns2__MolecularQuantumNumberType
{ public:
/// Element Label of type xs:string.
    std::string                          Label                          1;	///< Required element.
/// Element Value of type "":AngularMomentumType.
    ns2__AngularMomentumType             Value                          1;	///< Required element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// Attribute quantumNumberID of type xs:ID.
   @xsd__ID*                             quantumNumberID                0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MagneticQuantumNumberType is a complexType.
/// class ns2__MagneticQuantumNumberType operations:
/// - soap_new_ns2__MagneticQuantumNumberType(soap*) allocate
/// - soap_new_ns2__MagneticQuantumNumberType(soap*, int num) allocate array
/// - soap_new_req_ns2__MagneticQuantumNumberType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MagneticQuantumNumberType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MagneticQuantumNumberType(soap*, ns2__MagneticQuantumNumberType*) deserialize from a stream
/// - int soap_write_ns2__MagneticQuantumNumberType(soap, ns2__MagneticQuantumNumberType*) serialize to a stream
class ns2__MagneticQuantumNumberType
{ public:
/// Element Label of type xs:string.
    std::string                          Label                          1;	///< Required element.
/// Element Value of type "":AngularMomentumProjectionType.
    ns2__AngularMomentumProjectionType   Value                          1;	///< Required element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// Attribute quantumNumberID of type xs:ID.
   @xsd__ID*                             quantumNumberID                0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":SimpleSymbolType is a complexType.
/// class ns2__SimpleSymbolType operations:
/// - soap_new_ns2__SimpleSymbolType(soap*) allocate
/// - soap_new_ns2__SimpleSymbolType(soap*, int num) allocate array
/// - soap_new_req_ns2__SimpleSymbolType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SimpleSymbolType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SimpleSymbolType(soap*, ns2__SimpleSymbolType*) deserialize from a stream
/// - int soap_write_ns2__SimpleSymbolType(soap, ns2__SimpleSymbolType*) serialize to a stream
class ns2__SimpleSymbolType
{ public:
/// Element CentralSymbol of type "":CentralSymbolType.
    ns2__CentralSymbolType*              CentralSymbol                  1;	///< Required element.
/// Element RightCoefficient of type xs:string.
    std::string                          RightCoefficient               1;	///< Required element.
/// Element LeftCoefficient of type xs:string.
    std::string                          LeftCoefficient                1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":VibrationalComponentType is a complexType.
/// class ns2__VibrationalComponentType operations:
/// - soap_new_ns2__VibrationalComponentType(soap*) allocate
/// - soap_new_ns2__VibrationalComponentType(soap*, int num) allocate array
/// - soap_new_req_ns2__VibrationalComponentType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__VibrationalComponentType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__VibrationalComponentType(soap*, ns2__VibrationalComponentType*) deserialize from a stream
/// - int soap_write_ns2__VibrationalComponentType(soap, ns2__VibrationalComponentType*) serialize to a stream
class ns2__VibrationalComponentType
{ public:
/// Element Description of type xs:string.
    std::string*                         Description                    0;	///< Optional element.
/// Element SerialQuantumNumber of type xs:string.
    std::string*                         SerialQuantumNumber            0;	///< Optional element.
/// Element MixingCoefficient of type "":MixingCoefficientType.
    ns2__MixingCoefficientType*          MixingCoefficient              0;	///< Optional element.
/// Element VibrationalCharacterisation of type "":VibrationalCharacterisationType.
    ns2__VibrationalCharacterisationType*  VibrationalCharacterisation    0;	///< Optional element.
/// Element VibrationalQuantumNumbers of type "":VibrationalQuantumNumbersType.
    ns2__VibrationalQuantumNumbersType*  VibrationalQuantumNumbers      0;	///< Optional element.
/// Element RotationalHome of type "":RotationalHomeType.
    ns2__RotationalHomeType*             RotationalHome                 0;	///< Optional element.
/// Element Comment of type xs:token.
    xsd__token*                          Comment                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":VibrationalCharacterisationType is a complexType.
/// class ns2__VibrationalCharacterisationType operations:
/// - soap_new_ns2__VibrationalCharacterisationType(soap*) allocate
/// - soap_new_ns2__VibrationalCharacterisationType(soap*, int num) allocate array
/// - soap_new_req_ns2__VibrationalCharacterisationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__VibrationalCharacterisationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__VibrationalCharacterisationType(soap*, ns2__VibrationalCharacterisationType*) deserialize from a stream
/// - int soap_write_ns2__VibrationalCharacterisationType(soap, ns2__VibrationalCharacterisationType*) serialize to a stream
class ns2__VibrationalCharacterisationType
{ public:
/// Element VibrationalSpeciesNotation of type "":SymbolType.
    ns2__SymbolType*                     VibrationalSpeciesNotation     0;	///< Optional element.
/// Element VibronicSpeciesNotation of type "":SymbolType.
    ns2__SymbolType*                     VibronicSpeciesNotation        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":VibrationalHomeType is a complexType.
/// class ns2__VibrationalHomeType operations:
/// - soap_new_ns2__VibrationalHomeType(soap*) allocate
/// - soap_new_ns2__VibrationalHomeType(soap*, int num) allocate array
/// - soap_new_req_ns2__VibrationalHomeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__VibrationalHomeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__VibrationalHomeType(soap*, ns2__VibrationalHomeType*) deserialize from a stream
/// - int soap_write_ns2__VibrationalHomeType(soap, ns2__VibrationalHomeType*) serialize to a stream
class ns2__VibrationalHomeType
{ public:
/// Element Polyad of type "":CharacterisationType.
    ns2__CharacterisationType*           Polyad                         0;	///< Optional element.
/// Vector of ns2__VibrationalComponentType* with length 1..unbounded
    std::vector<ns2__VibrationalComponentType*> VibrationalComponent           1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":VibrationalQuantumNumbersType is a complexType.
/// class ns2__VibrationalQuantumNumbersType operations:
/// - soap_new_ns2__VibrationalQuantumNumbersType(soap*) allocate
/// - soap_new_ns2__VibrationalQuantumNumbersType(soap*, int num) allocate array
/// - soap_new_req_ns2__VibrationalQuantumNumbersType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__VibrationalQuantumNumbersType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__VibrationalQuantumNumbersType(soap*, ns2__VibrationalQuantumNumbersType*) deserialize from a stream
/// - int soap_write_ns2__VibrationalQuantumNumbersType(soap, ns2__VibrationalQuantumNumbersType*) serialize to a stream
class ns2__VibrationalQuantumNumbersType
{ public:
/// Vector of ns2__ComplexMolecularQuantumNumberType* with length 0..unbounded
    std::vector<ns2__ComplexMolecularQuantumNumberType*> VibrationalNu                  0;
/// Element TotalVibrationL of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalVibrationL                0;	///< Optional element.
/// Element VibronicAngularMomentumK of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      VibronicAngularMomentumK       0;	///< Optional element.
/// Element VibronicAngularMomentumP of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      VibronicAngularMomentumP       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":LinearNoElecNoHyperFType is a complexType.
/// class ns2__LinearNoElecNoHyperFType operations:
/// - soap_new_ns2__LinearNoElecNoHyperFType(soap*) allocate
/// - soap_new_ns2__LinearNoElecNoHyperFType(soap*, int num) allocate array
/// - soap_new_req_ns2__LinearNoElecNoHyperFType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__LinearNoElecNoHyperFType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__LinearNoElecNoHyperFType(soap*, ns2__LinearNoElecNoHyperFType*) deserialize from a stream
/// - int soap_write_ns2__LinearNoElecNoHyperFType(soap, ns2__LinearNoElecNoHyperFType*) serialize to a stream
class ns2__LinearNoElecNoHyperFType
{ public:
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element TotalMagneticQuantumNumberN of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberN    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":LinearNoElecHyperFType is a complexType.
/// class ns2__LinearNoElecHyperFType operations:
/// - soap_new_ns2__LinearNoElecHyperFType(soap*) allocate
/// - soap_new_ns2__LinearNoElecHyperFType(soap*, int num) allocate array
/// - soap_new_req_ns2__LinearNoElecHyperFType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__LinearNoElecHyperFType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__LinearNoElecHyperFType(soap*, ns2__LinearNoElecHyperFType*) deserialize from a stream
/// - int soap_write_ns2__LinearNoElecHyperFType(soap, ns2__LinearNoElecHyperFType*) serialize to a stream
class ns2__LinearNoElecHyperFType
{ public:
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element HyperfineQuantumNumbers of type "":HyperfineQuantumNumbersType.
    ns2__HyperfineQuantumNumbersType*    HyperfineQuantumNumbers        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":LinearElecCouplingType is a complexType.
/// class ns2__LinearElecCouplingType operations:
/// - soap_new_ns2__LinearElecCouplingType(soap*) allocate
/// - soap_new_ns2__LinearElecCouplingType(soap*, int num) allocate array
/// - soap_new_req_ns2__LinearElecCouplingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__LinearElecCouplingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__LinearElecCouplingType(soap*, ns2__LinearElecCouplingType*) deserialize from a stream
/// - int soap_write_ns2__LinearElecCouplingType(soap, ns2__LinearElecCouplingType*) serialize to a stream
class ns2__LinearElecCouplingType
{ public:
/// Element Description of type xs:string.
    std::string                          Description                    1;	///< Required element.
/// Element EfSymmetry of type "":EfSymmetryType.
    enum ns2__EfSymmetryType*            EfSymmetry                     0;	///< Optional element.
/// Element HundCaseA of type "":HundCaseAType.
    ns2__HundCaseAType*                  HundCaseA                      0;	///< Optional element.
/// Element HyperfineCaseAAlpha of type "":HyperfineCaseAAlphaType.
    ns2__HyperfineCaseAAlphaType*        HyperfineCaseAAlpha            0;	///< Optional element.
/// Element HyperfineCaseABeta of type "":HyperfineCaseABetaType.
    ns2__HyperfineCaseABetaType*         HyperfineCaseABeta             0;	///< Optional element.
/// Element HundCaseB of type "":HundCaseBType.
    ns2__HundCaseBType*                  HundCaseB                      0;	///< Optional element.
/// Element HyperfineCouplingHundCaseB of type "":HyperfineCouplingBType.
    ns2__HyperfineCouplingBType*         HyperfineCouplingHundCaseB     0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HundCaseAType is a complexType.
/// class ns2__HundCaseAType operations:
/// - soap_new_ns2__HundCaseAType(soap*) allocate
/// - soap_new_ns2__HundCaseAType(soap*, int num) allocate array
/// - soap_new_req_ns2__HundCaseAType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HundCaseAType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HundCaseAType(soap*, ns2__HundCaseAType*) deserialize from a stream
/// - int soap_write_ns2__HundCaseAType(soap, ns2__HundCaseAType*) serialize to a stream
class ns2__HundCaseAType
{ public:
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          1;	///< Required element.
/// Element TotalMolecularProjectionJ of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalMolecularProjectionJ      1;	///< Required element.
/// Element TotalMagneticQuantumNumberJ of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberJ    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HundCaseBType is a complexType.
/// class ns2__HundCaseBType operations:
/// - soap_new_ns2__HundCaseBType(soap*) allocate
/// - soap_new_ns2__HundCaseBType(soap*, int num) allocate array
/// - soap_new_req_ns2__HundCaseBType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HundCaseBType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HundCaseBType(soap*, ns2__HundCaseBType*) deserialize from a stream
/// - int soap_write_ns2__HundCaseBType(soap, ns2__HundCaseBType*) serialize to a stream
class ns2__HundCaseBType
{ public:
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          1;	///< Required element.
/// Element TotalMagneticQuantumNumberJ of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberJ    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HyperfineCaseAAlphaType is a complexType.
/// class ns2__HyperfineCaseAAlphaType operations:
/// - soap_new_ns2__HyperfineCaseAAlphaType(soap*) allocate
/// - soap_new_ns2__HyperfineCaseAAlphaType(soap*, int num) allocate array
/// - soap_new_req_ns2__HyperfineCaseAAlphaType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HyperfineCaseAAlphaType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HyperfineCaseAAlphaType(soap*, ns2__HyperfineCaseAAlphaType*) deserialize from a stream
/// - int soap_write_ns2__HyperfineCaseAAlphaType(soap, ns2__HyperfineCaseAAlphaType*) serialize to a stream
class ns2__HyperfineCaseAAlphaType
{ public:
/// Element TotalAngularMomentumF of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumF          1;	///< Required element.
/// Element TotalMolecularProjectionF of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalMolecularProjectionF      1;	///< Required element.
/// Element TotalMagneticQuantumNumberF of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberF    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HyperfineCaseABetaType is a complexType.
/// class ns2__HyperfineCaseABetaType operations:
/// - soap_new_ns2__HyperfineCaseABetaType(soap*) allocate
/// - soap_new_ns2__HyperfineCaseABetaType(soap*, int num) allocate array
/// - soap_new_req_ns2__HyperfineCaseABetaType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HyperfineCaseABetaType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HyperfineCaseABetaType(soap*, ns2__HyperfineCaseABetaType*) deserialize from a stream
/// - int soap_write_ns2__HyperfineCaseABetaType(soap, ns2__HyperfineCaseABetaType*) serialize to a stream
class ns2__HyperfineCaseABetaType
{ public:
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          1;	///< Required element.
/// Element TotalMolecularProjectionJ of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalMolecularProjectionJ      1;	///< Required element.
/// Element HyperfineQuantumNumbers of type "":HyperfineQuantumNumbersType.
    ns2__HyperfineQuantumNumbersType*    HyperfineQuantumNumbers        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HyperfineCouplingBType is a complexType.
/// class ns2__HyperfineCouplingBType operations:
/// - soap_new_ns2__HyperfineCouplingBType(soap*) allocate
/// - soap_new_ns2__HyperfineCouplingBType(soap*, int num) allocate array
/// - soap_new_req_ns2__HyperfineCouplingBType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HyperfineCouplingBType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HyperfineCouplingBType(soap*, ns2__HyperfineCouplingBType*) deserialize from a stream
/// - int soap_write_ns2__HyperfineCouplingBType(soap, ns2__HyperfineCouplingBType*) serialize to a stream
class ns2__HyperfineCouplingBType
{ public:
/// Element CouplingType of type "":CouplingListType.
    enum ns2__CouplingListType           CouplingType                   1;	///< Required element.
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          0;	///< Optional element.
/// Element HyperfineQuantumNumbers of type "":HyperfineQuantumNumbersType.
    ns2__HyperfineQuantumNumbersType*    HyperfineQuantumNumbers        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":NonLinearElecCouplingType is a complexType.
/// class ns2__NonLinearElecCouplingType operations:
/// - soap_new_ns2__NonLinearElecCouplingType(soap*) allocate
/// - soap_new_ns2__NonLinearElecCouplingType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearElecCouplingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearElecCouplingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearElecCouplingType(soap*, ns2__NonLinearElecCouplingType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearElecCouplingType(soap, ns2__NonLinearElecCouplingType*) serialize to a stream
class ns2__NonLinearElecCouplingType
{ public:
/// Element Label of type xs:string.
    std::string*                         Label                          0;	///< Optional element.
/// Element EfSymmetry of type "":EfSymmetryType.
    enum ns2__EfSymmetryType*            EfSymmetry                     0;	///< Optional element.
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          1;	///< Required element.
/// Element MolecularProjection of type "":MolecularProjectionType.
    ns2__MolecularProjectionType*        MolecularProjection            1;	///< Required element.
/// Element RoVibronicSplitting of type "":RoVibronicSplittingType.
    ns2__RoVibronicSplittingType*        RoVibronicSplitting            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":NonLinearNoElecType is a complexType.
/// class ns2__NonLinearNoElecType operations:
/// - soap_new_ns2__NonLinearNoElecType(soap*) allocate
/// - soap_new_ns2__NonLinearNoElecType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearNoElecType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearNoElecType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearNoElecType(soap*, ns2__NonLinearNoElecType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearNoElecType(soap, ns2__NonLinearNoElecType*) serialize to a stream
class ns2__NonLinearNoElecType
{ public:
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element MolecularProjection of type "":MolecularProjectionType.
    ns2__MolecularProjectionType*        MolecularProjection            1;	///< Required element.
/// Element C2Symmetries of type "":C2SymmetriesType.
    ns2__C2SymmetriesType*               C2Symmetries                   0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":HyperfineQuantumNumbersType is a complexType.
/// class ns2__HyperfineQuantumNumbersType operations:
/// - soap_new_ns2__HyperfineQuantumNumbersType(soap*) allocate
/// - soap_new_ns2__HyperfineQuantumNumbersType(soap*, int num) allocate array
/// - soap_new_req_ns2__HyperfineQuantumNumbersType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HyperfineQuantumNumbersType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HyperfineQuantumNumbersType(soap*, ns2__HyperfineQuantumNumbersType*) deserialize from a stream
/// - int soap_write_ns2__HyperfineQuantumNumbersType(soap, ns2__HyperfineQuantumNumbersType*) serialize to a stream
class ns2__HyperfineQuantumNumbersType
{ public:
/// GROUP <xs:group name="HyperfineCouplingISum" minOccurs="0">
/// SEQUENCE <xs:sequence minOccurs="0">
    std::vector<                                                       
    class __ns2__HyperfineQuantumNumbersType_sequence
    {
/// CHOICE <xs:choice maxOccurs="unbounded">
   $int                                  __size_HyperfineQuantumNumbersType 0;
    class __ns2__union_HyperfineQuantumNumbersType
    {
   $int                                  __union_HyperfineQuantumNumbersType;	///< Union _ns2__union_HyperfineQuantumNumbersType selector: set to SOAP_UNION__ns2__union_HyperfineQuantumNumbersType_<fieldname>
    union _ns2__union_HyperfineQuantumNumbersType
    {
/// Element ISum of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  ISum                           1;	///< Required element.
/// Element IntermediateHyperfineQuantumNumber of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  IntermediateHyperfineQuantumNumber 1;	///< Required element.
    }                                    union_HyperfineQuantumNumbersType;
    }                                   *__union_HyperfineQuantumNumbersType;
//  END OF CHOICE
    }>                                   __HyperfineQuantumNumbersType_sequence 0;
//  END OF SEQUENCE
//  END OF GROUP
/// Element TotalAngularMomentumF of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumF          1;	///< Required element.
/// Element TotalMagneticQuantumNumberF of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberF    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ParticlesType is a complexType.
/// class ns2__ParticlesType operations:
/// - soap_new_ns2__ParticlesType(soap*) allocate
/// - soap_new_ns2__ParticlesType(soap*, int num) allocate array
/// - soap_new_req_ns2__ParticlesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ParticlesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ParticlesType(soap*, ns2__ParticlesType*) deserialize from a stream
/// - int soap_write_ns2__ParticlesType(soap, ns2__ParticlesType*) serialize to a stream
class ns2__ParticlesType
{ public:
/// Vector of ns2__ParticleType* with length 1..unbounded
    std::vector<ns2__ParticleType*     > Particle                       1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ParticleType is a complexType.
/// class ns2__ParticleType operations:
/// - soap_new_ns2__ParticleType(soap*) allocate
/// - soap_new_ns2__ParticleType(soap*, int num) allocate array
/// - soap_new_req_ns2__ParticleType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ParticleType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ParticleType(soap*, ns2__ParticleType*) deserialize from a stream
/// - int soap_write_ns2__ParticleType(soap, ns2__ParticleType*) serialize to a stream
class ns2__ParticleType
{ public:
/// @brief Description of particle properties
/// Element ParticleProperties of type "":ParticlePropertiesType.
    ns2__ParticlePropertiesType*         ParticleProperties             0;	///< Optional element.
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":stateID.
/// @brief ID for a specific state/particle.
   @_ns2__stateID                        stateID                        1;	///< Required attribute.
/// Attribute name of type "":ParticleNameType.
   @enum ns2__ParticleNameType*          name                           0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ParticlePropertiesType is a complexType.
/// class ns2__ParticlePropertiesType operations:
/// - soap_new_ns2__ParticlePropertiesType(soap*) allocate
/// - soap_new_ns2__ParticlePropertiesType(soap*, int num) allocate array
/// - soap_new_req_ns2__ParticlePropertiesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ParticlePropertiesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ParticlePropertiesType(soap*, ns2__ParticlePropertiesType*) deserialize from a stream
/// - int soap_write_ns2__ParticlePropertiesType(soap, ns2__ParticlePropertiesType*) serialize to a stream
class ns2__ParticlePropertiesType
{ public:
/// @brief Particle charge
/// Element ParticleCharge of type xs:integer.
    xsd__integer*                        ParticleCharge                 0;	///< Optional element.
/// @brief Mass of the particle
/// Element ParticleMass of type "":DataType.
    ns2__DataType*                       ParticleMass                   0;	///< Optional element.
/// @brief Spin of the particle
/// Element ParticleSpin of type "":AngularMomentumType.
    ns2__AngularMomentumType*            ParticleSpin                   0;	///< Optional element.
/// @brief Polarization of the particle
/// Element ParticlePolarization of type "":AngularMomentumProjectionType.
    ns2__AngularMomentumProjectionType*  ParticlePolarization           0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MaterialComponentType is a complexType.
/// class ns2__MaterialComponentType operations:
/// - soap_new_ns2__MaterialComponentType(soap*) allocate
/// - soap_new_ns2__MaterialComponentType(soap*, int num) allocate array
/// - soap_new_req_ns2__MaterialComponentType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MaterialComponentType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MaterialComponentType(soap*, ns2__MaterialComponentType*) deserialize from a stream
/// - int soap_write_ns2__MaterialComponentType(soap, ns2__MaterialComponentType*) serialize to a stream
class ns2__MaterialComponentType
{ public:
/// Element ChemicalElement of type "":ChemicalElementType.
    ns2__ChemicalElementType*            ChemicalElement                1;	///< Required element.
/// CHOICE <xs:choice>
   $int                                  __union_MaterialComponentType ;	///< Union _ns2__union_MaterialComponentType selector: set to SOAP_UNION__ns2__union_MaterialComponentType_<fieldname>
    union _ns2__union_MaterialComponentType
    {
/// Element StoichiometricValue of type xs:decimal.
    xsd__decimal*                        StoichiometricValue            1;	///< Required element.
/// Element Percentage of type xs:decimal.
    xsd__decimal*                        Percentage                     1;	///< Required element.
    }                                    union_MaterialComponentType   ;
//  END OF CHOICE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MaterialType is a complexType.
/// @brief Description of an elementary material
/// class ns2__MaterialType operations:
/// - soap_new_ns2__MaterialType(soap*) allocate
/// - soap_new_ns2__MaterialType(soap*, int num) allocate array
/// - soap_new_req_ns2__MaterialType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MaterialType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MaterialType(soap*, ns2__MaterialType*) deserialize from a stream
/// - int soap_write_ns2__MaterialType(soap, ns2__MaterialType*) serialize to a stream
class ns2__MaterialType
{ public:
/// @brief Name of a material. Example: bronze
/// Element MaterialName of type xs:string.
    std::string                          MaterialName                   1;	///< Required element.
/// @brief Composition of a material
/// Element MaterialComposition of type "":MaterialCompositionType.
    ns2__MaterialCompositionType*        MaterialComposition            1;	///< Required element.
/// @brief Thickness of a material
/// Element MaterialThickness of type "":DataType.
    ns2__DataType*                       MaterialThickness              0;	///< Optional element.
/// @brief Description of the material topology
/// Element MaterialTopology of type xs:string.
    std::string*                         MaterialTopology               0;	///< Optional element.
/// @brief Temperature of the material
/// Element MaterialTemperature of type "":DataType.
    ns2__DataType*                       MaterialTemperature            0;	///< Optional element.
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":CollisionalProcessClassType is a complexType.
/// class ns2__CollisionalProcessClassType operations:
/// - soap_new_ns2__CollisionalProcessClassType(soap*) allocate
/// - soap_new_ns2__CollisionalProcessClassType(soap*, int num) allocate array
/// - soap_new_req_ns2__CollisionalProcessClassType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__CollisionalProcessClassType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__CollisionalProcessClassType(soap*, ns2__CollisionalProcessClassType*) deserialize from a stream
/// - int soap_write_ns2__CollisionalProcessClassType(soap, ns2__CollisionalProcessClassType*) serialize to a stream
class ns2__CollisionalProcessClassType
{ public:
/// @brief Description of the process
/// Element 'UserDefinition' has no type or ref (empty or with XML content).
    _XML                                 UserDefinition                 0;	///< Optional element.
/// @brief A 4-letter code describing various processes
/// Vector of enum ns2__CodeType with length 0..unbounded
    std::vector<enum ns2__CodeType     > Code                           0;
/// @brief From the "IAEA Classification of Processes", October 2003
/// Element IAEACode of type "":IAEACodeType.
    enum ns2__IAEACodeType*              IAEACode                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":XSAMSDataType is a complexType.
/// class ns2__XSAMSDataType operations:
/// - soap_new_ns2__XSAMSDataType(soap*) allocate
/// - soap_new_ns2__XSAMSDataType(soap*, int num) allocate array
/// - soap_new_req_ns2__XSAMSDataType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__XSAMSDataType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__XSAMSDataType(soap*, ns2__XSAMSDataType*) deserialize from a stream
/// - int soap_write_ns2__XSAMSDataType(soap, ns2__XSAMSDataType*) serialize to a stream
class ns2__XSAMSDataType
{ public:
/// @brief List of atomic states, molecular states, particles, surfaces, and solids
/// Element States of type "":StatesType.
    ns2__StatesType*                     States                         1;	///< Required element.
/// @brief Physical processes connecting states (e.g., radiative, collisional, autoionization, etc.)
/// Element Processes of type "":ProcessesType.
    ns2__ProcessesType*                  Processes                      0;	///< Optional element.
/// @brief All relevant references to data sources
/// Element reference "":Sources.
    ns2__SourcesType*                    Sources                        1;	///< Required element.
/// @brief List of methods used to produce the data
/// Element reference "":Methods.
    ns2__MethodsType*                    Methods                        0;	///< Optional element.
/// @brief List of functions used for data description and/or presentation (e.g., fitting)
/// Element reference "":Functions.
    ns2__FunctionsType*                  Functions                      0;	///< Optional element.
/// @brief Any relevant comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ProcessesType is a complexType.
/// class ns2__ProcessesType operations:
/// - soap_new_ns2__ProcessesType(soap*) allocate
/// - soap_new_ns2__ProcessesType(soap*, int num) allocate array
/// - soap_new_req_ns2__ProcessesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ProcessesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ProcessesType(soap*, ns2__ProcessesType*) deserialize from a stream
/// - int soap_write_ns2__ProcessesType(soap, ns2__ProcessesType*) serialize to a stream
class ns2__ProcessesType
{ public:
/// @brief List of radiative transitions
/// Element Radiative of type "":RadiativeType.
    ns2__RadiativeType*                  Radiative                      0;	///< Optional element.
/// @brief List of autoionization and predissociation transitions
/// Element reference "":NonRadiative.
    ns2__NonRadiativeType*               NonRadiative                   0;	///< Optional element.
/// @brief List of transitions due to collisions
/// Element Collisions of type "":CollisionsType.
    ns2__CollisionsType*                 Collisions                     0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":StatesType is a complexType.
/// class ns2__StatesType operations:
/// - soap_new_ns2__StatesType(soap*) allocate
/// - soap_new_ns2__StatesType(soap*, int num) allocate array
/// - soap_new_req_ns2__StatesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__StatesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__StatesType(soap*, ns2__StatesType*) deserialize from a stream
/// - int soap_write_ns2__StatesType(soap, ns2__StatesType*) serialize to a stream
class ns2__StatesType
{ public:
/// @brief List of atoms
/// Element Atoms of type "":AtomsType.
    ns2__AtomsType*                      Atoms                          0;	///< Optional element.
/// @brief List of molecules
/// Element Molecules of type "":MoleculesType.
    ns2__MoleculesType*                  Molecules                      0;	///< Optional element.
/// @brief List of solids and surfaces
/// Element Solids of type "":SolidsType.
    ns2__SolidsType*                     Solids                         0;	///< Optional element.
/// @brief List of elementary particles (electron, photon, etc.)
/// Element Particles of type "":ParticlesType.
    ns2__ParticlesType*                  Particles                      0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":DataType is a complexType with complexContent extension of "":PrimaryType.
/// @brief Description of physical data
/// class ns2__DataType operations:
/// - soap_new_ns2__DataType(soap*) allocate
/// - soap_new_ns2__DataType(soap*, int num) allocate array
/// - soap_new_req_ns2__DataType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__DataType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__DataType(soap*, ns2__DataType*) deserialize from a stream
/// - int soap_write_ns2__DataType(soap, ns2__DataType*) serialize to a stream
class ns2__DataType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Value of a particular quantity
/// Element Value of type "":ValueType.
    ns2__ValueType*                      Value                          1;	///< Required element.
/// @brief Description of the accuracy
/// Element Accuracy of type xs:string.
    std::string*                         Accuracy                       0;	///< Optional element.
};

/// "urn:poc":DataSetType is a complexType with complexContent extension of "":PrimaryType.
/// @brief Gives the actual data either (or both) with numerical tabulated data or (and) fitted data
/// class ns2__DataSetType operations:
/// - soap_new_ns2__DataSetType(soap*) allocate
/// - soap_new_ns2__DataSetType(soap*, int num) allocate array
/// - soap_new_req_ns2__DataSetType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__DataSetType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__DataSetType(soap*, ns2__DataSetType*) deserialize from a stream
/// - int soap_write_ns2__DataSetType(soap, ns2__DataSetType*) serialize to a stream
class ns2__DataSetType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Fits of data
/// Vector of ns2__FitDataType* with length 0..unbounded
    std::vector<ns2__FitDataType*      > FitData                        0;
/// @brief Tables of data
/// Vector of ns2__TabulatedDataType* with length 0..unbounded
    std::vector<ns2__TabulatedDataType*> TabulatedData                  0;
/// Attribute dataDescription of type "":DataDescriptionType.
   @enum ns2__DataDescriptionType        dataDescription                1;	///< Required attribute.
};

/// "urn:poc":TabulatedDataType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__TabulatedDataType operations:
/// - soap_new_ns2__TabulatedDataType(soap*) allocate
/// - soap_new_ns2__TabulatedDataType(soap*, int num) allocate array
/// - soap_new_req_ns2__TabulatedDataType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__TabulatedDataType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__TabulatedDataType(soap*, ns2__TabulatedDataType*) deserialize from a stream
/// - int soap_write_ns2__TabulatedDataType(soap, ns2__TabulatedDataType*) serialize to a stream
class ns2__TabulatedDataType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Element DataXY of type "":DataXYType.
    ns2__DataXYType*                     DataXY                         1;	///< Required element.
/// @brief Reference frame in which is given the energy, velocity...
/// Element ReferenceFrame of type "":ReferenceFrameType.
    enum ns2__ReferenceFrameType*        ReferenceFrame                 0;	///< Optional element.
/// Element PhysicalUncertainty of type xs:string.
    std::string*                         PhysicalUncertainty            0;	///< Optional element.
/// Element ProductionDate of type xs:date.
    xsd__date*                           ProductionDate                 0;	///< Optional element.
};

/// "urn:poc":FitDataType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__FitDataType operations:
/// - soap_new_ns2__FitDataType(soap*) allocate
/// - soap_new_ns2__FitDataType(soap*, int num) allocate array
/// - soap_new_req_ns2__FitDataType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__FitDataType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__FitDataType(soap*, ns2__FitDataType*) deserialize from a stream
/// - int soap_write_ns2__FitDataType(soap, ns2__FitDataType*) serialize to a stream
class ns2__FitDataType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Reference to the fitting function
/// Element FunctionRef of type xs:IDREF.
    xsd__IDREF                           FunctionRef                    1;	///< Required element.
/// @brief Limits of the fit validity
/// Vector of ns2__FitValidityLimitsType* with length 1..unbounded
    std::vector<ns2__FitValidityLimitsType*> FitValidityLimits              1;
/// @brief Fitting parameters
/// Element FitParameters of type "":FitParametersType.
    ns2__FitParametersType*              FitParameters                  1;	///< Required element.
/// @brief Description of fit accuracy
/// Element FitAccuracy of type xs:string.
    std::string*                         FitAccuracy                    0;	///< Optional element.
/// @brief Description of physical uncertainty
/// Element PhysicalUncertainty of type xs:string.
    std::string*                         PhysicalUncertainty            0;	///< Optional element.
/// @brief Fit production date
/// Element ProductionDate of type xs:date.
    xsd__date*                           ProductionDate                 0;	///< Optional element.
};

/// "urn:poc":ExpressionType is a complexType with simpleContent.
/// class ns2__ExpressionType operations:
/// - soap_new_ns2__ExpressionType(soap*) allocate
/// - soap_new_ns2__ExpressionType(soap*, int num) allocate array
/// - soap_new_req_ns2__ExpressionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ExpressionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ExpressionType(soap*, ns2__ExpressionType*) deserialize from a stream
/// - int soap_write_ns2__ExpressionType(soap, ns2__ExpressionType*) serialize to a stream
class ns2__ExpressionType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// @brief Programming language for the function expression. Example: Fortran2003.
/// Attribute computerLanguage of type xs:string.
   @std::string                          computerLanguage               1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ValueType is a complexType with simpleContent.
/// class ns2__ValueType operations:
/// - soap_new_ns2__ValueType(soap*) allocate
/// - soap_new_ns2__ValueType(soap*, int num) allocate array
/// - soap_new_req_ns2__ValueType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ValueType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ValueType(soap*, ns2__ValueType*) deserialize from a stream
/// - int soap_write_ns2__ValueType(soap, ns2__ValueType*) serialize to a stream
class ns2__ValueType
{ public:
/// __item wraps 'xs:double' simpleContent.
    double                               __item                        ;
/// Attribute reference "":units.
/// @brief Description of physical units. Use "unitless" for dimensionless quantities.
   @enum _ns2__units                     units                          1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":MixingCoefficientType is a complexType with simpleContent.
/// class ns2__MixingCoefficientType operations:
/// - soap_new_ns2__MixingCoefficientType(soap*) allocate
/// - soap_new_ns2__MixingCoefficientType(soap*, int num) allocate array
/// - soap_new_req_ns2__MixingCoefficientType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MixingCoefficientType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MixingCoefficientType(soap*, ns2__MixingCoefficientType*) deserialize from a stream
/// - int soap_write_ns2__MixingCoefficientType(soap, ns2__MixingCoefficientType*) serialize to a stream
class ns2__MixingCoefficientType
{ public:
/// __item wraps 'xs:double' simpleContent.
    double                               __item                        ;
/// @brief Indicator of whether amplitude or amplitude squared is given
/// Attribute mixingClass of type "":MixingClassType.
   @enum ns2__MixingClassType            mixingClass                    1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":FunctionType is a complexType with complexContent extension of "":PrimaryType.
/// @brief Description of used functions
/// class ns2__FunctionType operations:
/// - soap_new_ns2__FunctionType(soap*) allocate
/// - soap_new_ns2__FunctionType(soap*, int num) allocate array
/// - soap_new_req_ns2__FunctionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__FunctionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__FunctionType(soap*, ns2__FunctionType*) deserialize from a stream
/// - int soap_write_ns2__FunctionType(soap, ns2__FunctionType*) serialize to a stream
class ns2__FunctionType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Function name. Example: BELI
/// Element Name of type xs:string.
    std::string*                         Name                           0;	///< Optional element.
/// @brief Function expression in a specified programming language. Example: a*X1**2+2.5 (a is the parameter defined in the "parameters" list).
/// Element Expression of type "":ExpressionType.
    ns2__ExpressionType*                 Expression                     1;	///< Required element.
/// Element Y of type "":ArgumentType.
    ns2__ArgumentType*                   Y                              1;	///< Required element.
/// Element Arguments of type "":ArgumentsType.
    ns2__ArgumentsType*                  Arguments                      1;	///< Required element.
/// @brief List of parameters used in the function
/// Element Parameters of type "":ParametersType.
    ns2__ParametersType*                 Parameters                     0;	///< Optional element.
/// @brief Reference frame in which is given the velocity, energy...
/// Element ReferenceFrame of type "":ReferenceFrameType.
    enum ns2__ReferenceFrameType*        ReferenceFrame                 0;	///< Optional element.
/// @brief Description of a function.
/// Element Description of type xs:string.
    std::string*                         Description                    0;	///< Optional element.
/// @brief Location of source code
/// Element SourceCodeURL of type xs:string.
    std::string*                         SourceCodeURL                  0;	///< Optional element.
/// Attribute reference "":functionID.
/// @brief ID for a specific function
   @_ns2__functionID                     functionID                     1;	///< Required attribute.
};

/// "urn:poc":AtomsType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__AtomsType operations:
/// - soap_new_ns2__AtomsType(soap*) allocate
/// - soap_new_ns2__AtomsType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomsType(soap*, ns2__AtomsType*) deserialize from a stream
/// - int soap_write_ns2__AtomsType(soap, ns2__AtomsType*) serialize to a stream
class ns2__AtomsType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__AtomType* with length 1..unbounded
    std::vector<ns2__AtomType*         > Atom                           1;
};

/// "urn:poc":AtomType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__AtomType operations:
/// - soap_new_ns2__AtomType(soap*) allocate
/// - soap_new_ns2__AtomType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomType(soap*, ns2__AtomType*) deserialize from a stream
/// - int soap_write_ns2__AtomType(soap, ns2__AtomType*) serialize to a stream
class ns2__AtomType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Description of chemical elements
/// Element ChemicalElement of type "":ChemicalElementType.
    ns2__ChemicalElementType*            ChemicalElement                1;	///< Required element.
/// @brief List of isotopes
/// Vector of ns2__IsotopeType* with length 1..unbounded
    std::vector<ns2__IsotopeType*      > Isotope                        1;
};

/// "urn:poc":IsotopeParametersType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__IsotopeParametersType operations:
/// - soap_new_ns2__IsotopeParametersType(soap*) allocate
/// - soap_new_ns2__IsotopeParametersType(soap*, int num) allocate array
/// - soap_new_req_ns2__IsotopeParametersType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__IsotopeParametersType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__IsotopeParametersType(soap*, ns2__IsotopeParametersType*) deserialize from a stream
/// - int soap_write_ns2__IsotopeParametersType(soap, ns2__IsotopeParametersType*) serialize to a stream
class ns2__IsotopeParametersType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Mass number. Example: 40.
/// Element MassNumber of type xs:integer.
    xsd__integer                         MassNumber                     1;	///< Required element.
/// @brief Measured mass.
/// Element Mass of type "":DataType.
    ns2__DataType*                       Mass                           0;	///< Optional element.
/// @brief Spin of an isotope
/// Element NuclearSpin of type "":AngularMomentumType.
    ns2__AngularMomentumType*            NuclearSpin                    0;	///< Optional element.
};

/// "urn:poc":IonStateType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__IonStateType operations:
/// - soap_new_ns2__IonStateType(soap*) allocate
/// - soap_new_ns2__IonStateType(soap*, int num) allocate array
/// - soap_new_req_ns2__IonStateType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__IonStateType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__IonStateType(soap*, ns2__IonStateType*) deserialize from a stream
/// - int soap_write_ns2__IonStateType(soap, ns2__IonStateType*) serialize to a stream
class ns2__IonStateType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Ion charge. Example: 12.
/// Element IonCharge of type xs:integer.
    xsd__integer                         IonCharge                      1;	///< Required element.
/// @brief Chemical element representation of isoelectronic sequence. Example: He.
/// Element IsoelectronicSequence of type "":ElementSymbolType.
    ns2__ElementSymbolType*              IsoelectronicSequence          0;	///< Optional element.
/// @brief List of atomic states within an ion
/// Vector of ns2__AtomicStateType* with length 1..unbounded
    std::vector<ns2__AtomicStateType*  > AtomicState                    1;
};

/// "urn:poc":AtomicStateType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__AtomicStateType operations:
/// - soap_new_ns2__AtomicStateType(soap*) allocate
/// - soap_new_ns2__AtomicStateType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomicStateType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomicStateType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomicStateType(soap*, ns2__AtomicStateType*) deserialize from a stream
/// - int soap_write_ns2__AtomicStateType(soap, ns2__AtomicStateType*) serialize to a stream
class ns2__AtomicStateType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief An arbitrary label
/// Element Description of type xs:string.
    std::string*                         Description                    0;	///< Optional element.
/// @brief Numerical parameters describing an atomic state
/// Element AtomicNumericalData of type "":AtomicNumericalDataType.
    ns2__AtomicNumericalDataType*        AtomicNumericalData            0;	///< Optional element.
/// @brief Discrete quantum numbers describing an atomic state
/// Element AtomicQuantumNumbers of type "":AtomicQuantumNumbersType.
    ns2__AtomicQuantumNumbersType*       AtomicQuantumNumbers           0;	///< Optional element.
/// @brief Expansion of the wavefunction in a specific basis
/// Element AtomicComposition of type "":AtomicCompositionType.
    ns2__AtomicCompositionType*          AtomicComposition              0;	///< Optional element.
/// Attribute reference "":stateID.
/// @brief ID for a specific state/particle.
   @_ns2__stateID                        stateID                        1;	///< Required attribute.
};

/// "urn:poc":AtomicNumericalDataType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__AtomicNumericalDataType operations:
/// - soap_new_ns2__AtomicNumericalDataType(soap*) allocate
/// - soap_new_ns2__AtomicNumericalDataType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomicNumericalDataType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomicNumericalDataType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomicNumericalDataType(soap*, ns2__AtomicNumericalDataType*) deserialize from a stream
/// - int soap_write_ns2__AtomicNumericalDataType(soap, ns2__AtomicNumericalDataType*) serialize to a stream
class ns2__AtomicNumericalDataType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Energy from the ground state
/// Element StateEnergy of type "":DataType.
    ns2__DataType*                       StateEnergy                    0;	///< Optional element.
/// @brief Energy required to remove an electron
/// Element IonizationEnergy of type "":DataType.
    ns2__DataType*                       IonizationEnergy               0;	///< Optional element.
/// @brief Lande factor
/// Element LandeFactor of type "":DataType.
    ns2__DataType*                       LandeFactor                    0;	///< Optional element.
/// @brief Quantum defect
/// Element QuantumDefect of type "":DataType.
    ns2__DataType*                       QuantumDefect                  0;	///< Optional element.
/// @brief State lifetime
/// Element TotalLifeTime of type "":DataType.
    ns2__DataType*                       TotalLifeTime                  0;	///< Optional element.
/// @brief State polarizability
/// Element Polarizability of type "":DataType.
    ns2__DataType*                       Polarizability                 0;	///< Optional element.
/// @brief Statistical weight. May be non-integer due to plasma environment effects.
/// Element StatisticalWeight of type xs:double.
    double*                              StatisticalWeight              0;	///< Optional element.
};

/// "urn:poc":AtomicCompositionType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__AtomicCompositionType operations:
/// - soap_new_ns2__AtomicCompositionType(soap*) allocate
/// - soap_new_ns2__AtomicCompositionType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomicCompositionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomicCompositionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomicCompositionType(soap*, ns2__AtomicCompositionType*) deserialize from a stream
/// - int soap_write_ns2__AtomicCompositionType(soap, ns2__AtomicCompositionType*) serialize to a stream
class ns2__AtomicCompositionType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Component of the state wavefunction
/// Vector of ns2__AtomicComponentType* with length 1..unbounded
    std::vector<ns2__AtomicComponentType*> Component                      1;
};

/// "urn:poc":AtomNType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__AtomNType operations:
/// - soap_new_ns2__AtomNType(soap*) allocate
/// - soap_new_ns2__AtomNType(soap*, int num) allocate array
/// - soap_new_req_ns2__AtomNType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__AtomNType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__AtomNType(soap*, ns2__AtomNType*) deserialize from a stream
/// - int soap_write_ns2__AtomNType(soap, ns2__AtomNType*) serialize to a stream
class ns2__AtomNType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Attribute nuclearSpinID of type xs:ID.
   @xsd__ID*                             nuclearSpinID                  0;	///< Optional attribute.
/// Attribute elementSymbol of type "":ElementSymbolType.
   @ns2__ElementSymbolType*              elementSymbol                  0;	///< Optional attribute.
/// Attribute isotope of type xs:positiveInteger.
   @xsd__positiveInteger*                isotope                        0;	///< Optional attribute.
/// Attribute nuclearSpin of type "":AngularMomentumType.
   @ns2__AngularMomentumType*            nuclearSpin                    0;	///< Optional attribute.
/// Attribute hydrogenCount of type xs:positiveInteger.
   @xsd__positiveInteger*                hydrogenCount                  0;	///< Optional attribute.
/// Attribute count of type xs:positiveInteger.
   @xsd__positiveInteger*                count                          0;	///< Optional attribute.
};

/// "urn:poc":CentralSymbolType is a complexType with simpleContent.
/// class ns2__CentralSymbolType operations:
/// - soap_new_ns2__CentralSymbolType(soap*) allocate
/// - soap_new_ns2__CentralSymbolType(soap*, int num) allocate array
/// - soap_new_req_ns2__CentralSymbolType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__CentralSymbolType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__CentralSymbolType(soap*, ns2__CentralSymbolType*) deserialize from a stream
/// - int soap_write_ns2__CentralSymbolType(soap, ns2__CentralSymbolType*) serialize to a stream
class ns2__CentralSymbolType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Attribute UpperLeftValue of type xs:string.
   @std::string*                         UpperLeftValue                 0;	///< Optional attribute.
/// Attribute LowerLeftValue of type xs:string.
   @std::string*                         LowerLeftValue                 0;	///< Optional attribute.
/// Attribute UpperRightValue of type xs:string.
   @std::string*                         UpperRightValue                0;	///< Optional attribute.
/// Attribute LowerRightValue of type xs:string.
   @std::string*                         LowerRightValue                0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":ComplexMolecularQuantumNumberType is a complexType with complexContent extension of "":MolecularQuantumNumberType.
/// class ns2__ComplexMolecularQuantumNumberType operations:
/// - soap_new_ns2__ComplexMolecularQuantumNumberType(soap*) allocate
/// - soap_new_ns2__ComplexMolecularQuantumNumberType(soap*, int num) allocate array
/// - soap_new_req_ns2__ComplexMolecularQuantumNumberType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ComplexMolecularQuantumNumberType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ComplexMolecularQuantumNumberType(soap*, ns2__ComplexMolecularQuantumNumberType*) deserialize from a stream
/// - int soap_write_ns2__ComplexMolecularQuantumNumberType(soap, ns2__ComplexMolecularQuantumNumberType*) serialize to a stream
class ns2__ComplexMolecularQuantumNumberType : public ns2__MolecularQuantumNumberType
{ public:
/*  INHERITED FROM ns2__MolecularQuantumNumberType:
/// Element Label of type xs:string.
    std::string                          Label                          1;	///< Required element.
/// Element Value of type "":AngularMomentumType.
    ns2__AngularMomentumType             Value                          1;	///< Required element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// Attribute quantumNumberID of type xs:ID.
   @xsd__ID*                             quantumNumberID                0;	///< Optional attribute.
    END OF INHERITED FROM ns2__MolecularQuantumNumberType */
/// Begin attributeGroup vibrationModeCharacteristics.
/// Attribute modesType of type "":ModesListType.
   @enum ns2__ModesListType*             modesType                      0;	///< Optional attribute.
/// Attribute vibrationLNu-i of type "":AngularMomentumType.
   @ns2__AngularMomentumType*            vibrationLNu_i                 0;	///< Optional attribute.
/// @brief check vocabulary in herzberg
/// Attribute vibrationSymmetry of type xs:string.
   @std::string*                         vibrationSymmetry              0;	///< Optional attribute.
/// Attribute vibrationInversion of type xs:string.
   @std::string*                         vibrationInversion             0;	///< Optional attribute.
/// Attribute vibrationSymmetryIndex of type xs:integer.
   @xsd__integer*                        vibrationSymmetryIndex         0;	///< Optional attribute.
/// End of attributeGroup vibrationModeCharacteristics.
/// Begin attributeGroup nuclearSpinCharacteristics.
/// Attribute nuclearSpinRefs2 of type xs:IDREFS.
   @xsd__IDREFS*                         nuclearSpinRefs2               0;	///< Optional attribute.
/// Attribute nuclearSpinRef of type xs:IDREF.
   @xsd__IDREF*                          nuclearSpinRef                 0;	///< Optional attribute.
/// Attribute spinSumRef of type xs:IDREF.
   @xsd__IDREF*                          spinSumRef                     0;	///< Optional attribute.
/// Attribute electronicSpinRef of type xs:IDREF.
   @xsd__IDREF*                          electronicSpinRef              0;	///< Optional attribute.
/// Attribute quantumNumberRef of type xs:IDREF.
   @xsd__IDREF*                          quantumNumberRef               0;	///< Optional attribute.
/// End of attributeGroup nuclearSpinCharacteristics.
};

/// "urn:poc":MolecularStateType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__MolecularStateType operations:
/// - soap_new_ns2__MolecularStateType(soap*) allocate
/// - soap_new_ns2__MolecularStateType(soap*, int num) allocate array
/// - soap_new_req_ns2__MolecularStateType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MolecularStateType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MolecularStateType(soap*, ns2__MolecularStateType*) deserialize from a stream
/// - int soap_write_ns2__MolecularStateType(soap, ns2__MolecularStateType*) serialize to a stream
class ns2__MolecularStateType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Element Description of type xs:string.
    std::string                          Description                    1;	///< Required element.
/// Element MolecularStateCharacterisation of type "":MolecularStateCharacterisationType.
    ns2__MolecularStateCharacterisationType*  MolecularStateCharacterisation 0;	///< Optional element.
/// Element TotalSpinMomentumS of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalSpinMomentumS             0;	///< Optional element.
/// Element TotalMagneticQuantumNumberS of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberS    0;	///< Optional element.
/// Element Parity of type "":ParityType.
    enum ns2__ParityType*                Parity                         0;	///< Optional element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// Element ElectronicHome of type "":ElectronicHomeType.
    ns2__ElectronicHomeType*             ElectronicHome                 0;	///< Optional element.
/// Attribute reference "":stateID.
/// @brief ID for a specific state/particle.
   @_ns2__stateID                        stateID                        1;	///< Required attribute.
};

/// "urn:poc":MoleculeType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__MoleculeType operations:
/// - soap_new_ns2__MoleculeType(soap*) allocate
/// - soap_new_ns2__MoleculeType(soap*, int num) allocate array
/// - soap_new_req_ns2__MoleculeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MoleculeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MoleculeType(soap*, ns2__MoleculeType*) deserialize from a stream
/// - int soap_write_ns2__MoleculeType(soap, ns2__MoleculeType*) serialize to a stream
class ns2__MoleculeType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Element MolecularChemicalSpecies of type "":MolecularChemicalSpeciesType.
    ns2__MolecularChemicalSpeciesType*   MolecularChemicalSpecies       1;	///< Required element.
/// Vector of ns2__MolecularStateType* with length 1..unbounded
    std::vector<ns2__MolecularStateType*> MolecularState                 1;
};

/// "urn:poc":MoleculesType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__MoleculesType operations:
/// - soap_new_ns2__MoleculesType(soap*) allocate
/// - soap_new_ns2__MoleculesType(soap*, int num) allocate array
/// - soap_new_req_ns2__MoleculesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MoleculesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MoleculesType(soap*, ns2__MoleculesType*) deserialize from a stream
/// - int soap_write_ns2__MoleculesType(soap, ns2__MoleculesType*) serialize to a stream
class ns2__MoleculesType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__MoleculeType* with length 1..unbounded
    std::vector<ns2__MoleculeType*     > Molecule                       1;
};

/// "urn:poc":PseudoStatisticalWeightType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__PseudoStatisticalWeightType operations:
/// - soap_new_ns2__PseudoStatisticalWeightType(soap*) allocate
/// - soap_new_ns2__PseudoStatisticalWeightType(soap*, int num) allocate array
/// - soap_new_req_ns2__PseudoStatisticalWeightType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__PseudoStatisticalWeightType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__PseudoStatisticalWeightType(soap*, ns2__PseudoStatisticalWeightType*) deserialize from a stream
/// - int soap_write_ns2__PseudoStatisticalWeightType(soap, ns2__PseudoStatisticalWeightType*) serialize to a stream
class ns2__PseudoStatisticalWeightType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Element Value of type xs:positiveInteger.
    xsd__positiveInteger                 Value                          1;	///< Required element.
};

/// "urn:poc":RoVibronicSplittingType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__RoVibronicSplittingType operations:
/// - soap_new_ns2__RoVibronicSplittingType(soap*) allocate
/// - soap_new_ns2__RoVibronicSplittingType(soap*, int num) allocate array
/// - soap_new_req_ns2__RoVibronicSplittingType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RoVibronicSplittingType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RoVibronicSplittingType(soap*, ns2__RoVibronicSplittingType*) deserialize from a stream
/// - int soap_write_ns2__RoVibronicSplittingType(soap, ns2__RoVibronicSplittingType*) serialize to a stream
class ns2__RoVibronicSplittingType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// SEQUENCE <xs:sequence maxOccurs="unbounded">
    std::vector<                                                       
    class __ns2__RoVibronicSplittingType_sequence
    {
/// Element Label of type xs:string.
    std::string                          Label                          1;	///< Required element.
/// Element Type of type xs:string.
    std::string                          Type                           1;	///< Required element.
    }>                                   __RoVibronicSplittingType_sequence;
//  END OF SEQUENCE
};

/// "urn:poc":SymbolType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__SymbolType operations:
/// - soap_new_ns2__SymbolType(soap*) allocate
/// - soap_new_ns2__SymbolType(soap*, int num) allocate array
/// - soap_new_req_ns2__SymbolType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SymbolType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SymbolType(soap*, ns2__SymbolType*) deserialize from a stream
/// - int soap_write_ns2__SymbolType(soap, ns2__SymbolType*) serialize to a stream
class ns2__SymbolType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__SimpleSymbolType* with length 1..unbounded
    std::vector<ns2__SimpleSymbolType* > Symbol                         1;
/// Element LatexExpression of type xs:string.
    std::string*                         LatexExpression                0;	///< Optional element.
};

/// "urn:poc":NonLinearElecHyperFType is a complexType with complexContent extension of "":NonLinearElecCouplingType.
/// class ns2__NonLinearElecHyperFType operations:
/// - soap_new_ns2__NonLinearElecHyperFType(soap*) allocate
/// - soap_new_ns2__NonLinearElecHyperFType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearElecHyperFType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearElecHyperFType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearElecHyperFType(soap*, ns2__NonLinearElecHyperFType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearElecHyperFType(soap, ns2__NonLinearElecHyperFType*) serialize to a stream
class ns2__NonLinearElecHyperFType : public ns2__NonLinearElecCouplingType
{ public:
/*  INHERITED FROM ns2__NonLinearElecCouplingType:
/// Element Label of type xs:string.
    std::string*                         Label                          0;	///< Optional element.
/// Element EfSymmetry of type "":EfSymmetryType.
    enum ns2__EfSymmetryType*            EfSymmetry                     0;	///< Optional element.
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          1;	///< Required element.
/// Element MolecularProjection of type "":MolecularProjectionType.
    ns2__MolecularProjectionType*        MolecularProjection            1;	///< Required element.
/// Element RoVibronicSplitting of type "":RoVibronicSplittingType.
    ns2__RoVibronicSplittingType*        RoVibronicSplitting            0;	///< Optional element.
    END OF INHERITED FROM ns2__NonLinearElecCouplingType */
/// Element HyperfineQuantumNumbers of type "":HyperfineQuantumNumbersType.
    ns2__HyperfineQuantumNumbersType*    HyperfineQuantumNumbers        1;	///< Required element.
};

/// "urn:poc":NonLinearElecNoHyperFType is a complexType with complexContent extension of "":NonLinearElecCouplingType.
/// class ns2__NonLinearElecNoHyperFType operations:
/// - soap_new_ns2__NonLinearElecNoHyperFType(soap*) allocate
/// - soap_new_ns2__NonLinearElecNoHyperFType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearElecNoHyperFType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearElecNoHyperFType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearElecNoHyperFType(soap*, ns2__NonLinearElecNoHyperFType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearElecNoHyperFType(soap, ns2__NonLinearElecNoHyperFType*) serialize to a stream
class ns2__NonLinearElecNoHyperFType : public ns2__NonLinearElecCouplingType
{ public:
/*  INHERITED FROM ns2__NonLinearElecCouplingType:
/// Element Label of type xs:string.
    std::string*                         Label                          0;	///< Optional element.
/// Element EfSymmetry of type "":EfSymmetryType.
    enum ns2__EfSymmetryType*            EfSymmetry                     0;	///< Optional element.
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element TotalAngularMomentumJ of type "":ComplexMolecularQuantumNumberType.
    ns2__ComplexMolecularQuantumNumberType*  TotalAngularMomentumJ          1;	///< Required element.
/// Element MolecularProjection of type "":MolecularProjectionType.
    ns2__MolecularProjectionType*        MolecularProjection            1;	///< Required element.
/// Element RoVibronicSplitting of type "":RoVibronicSplittingType.
    ns2__RoVibronicSplittingType*        RoVibronicSplitting            0;	///< Optional element.
    END OF INHERITED FROM ns2__NonLinearElecCouplingType */
/// Element TotalMagneticQuantumNumberJ of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberJ    0;	///< Optional element.
};

/// "urn:poc":NonLinearNoElecNoHyperFType is a complexType with complexContent extension of "":NonLinearNoElecType.
/// class ns2__NonLinearNoElecNoHyperFType operations:
/// - soap_new_ns2__NonLinearNoElecNoHyperFType(soap*) allocate
/// - soap_new_ns2__NonLinearNoElecNoHyperFType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearNoElecNoHyperFType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearNoElecNoHyperFType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearNoElecNoHyperFType(soap*, ns2__NonLinearNoElecNoHyperFType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearNoElecNoHyperFType(soap, ns2__NonLinearNoElecNoHyperFType*) serialize to a stream
class ns2__NonLinearNoElecNoHyperFType : public ns2__NonLinearNoElecType
{ public:
/*  INHERITED FROM ns2__NonLinearNoElecType:
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element MolecularProjection of type "":MolecularProjectionType.
    ns2__MolecularProjectionType*        MolecularProjection            1;	///< Required element.
/// Element C2Symmetries of type "":C2SymmetriesType.
    ns2__C2SymmetriesType*               C2Symmetries                   0;	///< Optional element.
    END OF INHERITED FROM ns2__NonLinearNoElecType */
/// Element TotalMagneticQuantumNumberN of type "":MagneticQuantumNumberType.
    ns2__MagneticQuantumNumberType*      TotalMagneticQuantumNumberN    0;	///< Optional element.
};

/// "urn:poc":NonLinearNoElecHyperFType is a complexType with complexContent extension of "":NonLinearNoElecType.
/// class ns2__NonLinearNoElecHyperFType operations:
/// - soap_new_ns2__NonLinearNoElecHyperFType(soap*) allocate
/// - soap_new_ns2__NonLinearNoElecHyperFType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonLinearNoElecHyperFType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonLinearNoElecHyperFType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonLinearNoElecHyperFType(soap*, ns2__NonLinearNoElecHyperFType*) deserialize from a stream
/// - int soap_write_ns2__NonLinearNoElecHyperFType(soap, ns2__NonLinearNoElecHyperFType*) serialize to a stream
class ns2__NonLinearNoElecHyperFType : public ns2__NonLinearNoElecType
{ public:
/*  INHERITED FROM ns2__NonLinearNoElecType:
/// Element TotalAngularMomentumN of type "":MolecularQuantumNumberType.
    ns2__MolecularQuantumNumberType*     TotalAngularMomentumN          1;	///< Required element.
/// Element MolecularProjection of type "":MolecularProjectionType.
    ns2__MolecularProjectionType*        MolecularProjection            1;	///< Required element.
/// Element C2Symmetries of type "":C2SymmetriesType.
    ns2__C2SymmetriesType*               C2Symmetries                   0;	///< Optional element.
    END OF INHERITED FROM ns2__NonLinearNoElecType */
/// Element HyperfineQuantumNumbers of type "":HyperfineQuantumNumbersType.
    ns2__HyperfineQuantumNumbersType*    HyperfineQuantumNumbers        1;	///< Required element.
};

/// "urn:poc":ReferencedTextType is a complexType with simpleContent.
/// class ns2__ReferencedTextType operations:
/// - soap_new_ns2__ReferencedTextType(soap*) allocate
/// - soap_new_ns2__ReferencedTextType(soap*, int num) allocate array
/// - soap_new_req_ns2__ReferencedTextType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ReferencedTextType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ReferencedTextType(soap*, ns2__ReferencedTextType*) deserialize from a stream
/// - int soap_write_ns2__ReferencedTextType(soap, ns2__ReferencedTextType*) serialize to a stream
class ns2__ReferencedTextType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "urn:poc":CharacterisationType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__CharacterisationType operations:
/// - soap_new_ns2__CharacterisationType(soap*) allocate
/// - soap_new_ns2__CharacterisationType(soap*, int num) allocate array
/// - soap_new_req_ns2__CharacterisationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__CharacterisationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__CharacterisationType(soap*, ns2__CharacterisationType*) deserialize from a stream
/// - int soap_write_ns2__CharacterisationType(soap, ns2__CharacterisationType*) serialize to a stream
class ns2__CharacterisationType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Element Name of type xs:string.
    std::string*                         Name                           0;	///< Optional element.
/// CHOICE <xs:choice minOccurs="0">
   $int                                  __union_CharacterisationType   0;	///< Union _ns2__union_CharacterisationType selector: set to SOAP_UNION__ns2__union_CharacterisationType_<fieldname> or 0
    union _ns2__union_CharacterisationType
    {
/// Element IntValue of type xs:integer.
    xsd__integer*                        IntValue                       1;	///< Required element.
/// Element FloatValue of type xs:float.
    float                                FloatValue                     1;	///< Required element.
/// Element StringValue of type xs:string.
    std::string*                         StringValue                    1;	///< Required element.
    }                                    union_CharacterisationType    ;
//  END OF CHOICE
};

/// "urn:poc":SolidType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__SolidType operations:
/// - soap_new_ns2__SolidType(soap*) allocate
/// - soap_new_ns2__SolidType(soap*, int num) allocate array
/// - soap_new_req_ns2__SolidType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SolidType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SolidType(soap*, ns2__SolidType*) deserialize from a stream
/// - int soap_write_ns2__SolidType(soap, ns2__SolidType*) serialize to a stream
class ns2__SolidType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__MaterialType* with length 1..unbounded
    std::vector<ns2__MaterialType*     > Layer                          1;
/// Attribute reference "":stateID.
/// @brief ID for a specific state/particle.
   @_ns2__stateID                        stateID                        1;	///< Required attribute.
};

/// "urn:poc":SolidsType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__SolidsType operations:
/// - soap_new_ns2__SolidsType(soap*) allocate
/// - soap_new_ns2__SolidsType(soap*, int num) allocate array
/// - soap_new_req_ns2__SolidsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__SolidsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__SolidsType(soap*, ns2__SolidsType*) deserialize from a stream
/// - int soap_write_ns2__SolidsType(soap, ns2__SolidsType*) serialize to a stream
class ns2__SolidsType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__SolidType* with length 1..unbounded
    std::vector<ns2__SolidType*        > Solid                          1;
};

/// "urn:poc":MaterialCompositionType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__MaterialCompositionType operations:
/// - soap_new_ns2__MaterialCompositionType(soap*) allocate
/// - soap_new_ns2__MaterialCompositionType(soap*, int num) allocate array
/// - soap_new_req_ns2__MaterialCompositionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MaterialCompositionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MaterialCompositionType(soap*, ns2__MaterialCompositionType*) deserialize from a stream
/// - int soap_write_ns2__MaterialCompositionType(soap, ns2__MaterialCompositionType*) serialize to a stream
class ns2__MaterialCompositionType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__MaterialComponentType* with length 1..unbounded
    std::vector<ns2__MaterialComponentType*> Component                      1;
};

/// "urn:poc":RadiativeType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__RadiativeType operations:
/// - soap_new_ns2__RadiativeType(soap*) allocate
/// - soap_new_ns2__RadiativeType(soap*, int num) allocate array
/// - soap_new_req_ns2__RadiativeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RadiativeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RadiativeType(soap*, ns2__RadiativeType*) deserialize from a stream
/// - int soap_write_ns2__RadiativeType(soap, ns2__RadiativeType*) serialize to a stream
class ns2__RadiativeType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Description of a specific radiative transition
/// Vector of ns2__RadiativeTransitionType* with length 1..unbounded
    std::vector<ns2__RadiativeTransitionType*> RadiativeTransition            1;
};

/// "urn:poc":RadiativeTransitionType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__RadiativeTransitionType operations:
/// - soap_new_ns2__RadiativeTransitionType(soap*) allocate
/// - soap_new_ns2__RadiativeTransitionType(soap*, int num) allocate array
/// - soap_new_req_ns2__RadiativeTransitionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RadiativeTransitionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RadiativeTransitionType(soap*, ns2__RadiativeTransitionType*) deserialize from a stream
/// - int soap_write_ns2__RadiativeTransitionType(soap, ns2__RadiativeTransitionType*) serialize to a stream
class ns2__RadiativeTransitionType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief List of energy/spectrum parameters
/// Element EnergyWavelength of type "":EnergyWavelengthType.
    ns2__EnergyWavelengthType*           EnergyWavelength               1;	///< Required element.
/// @brief Reference to the initial state
/// Element InitialStateRef of type "":StateRef.
    ns2__StateRef*                       InitialStateRef                0;	///< Optional element.
/// @brief Reference to the final state
/// Element FinalStateRef of type "":StateRef.
    ns2__StateRef*                       FinalStateRef                  0;	///< Optional element.
/// @brief Radiative transition probability and related parameters
/// Vector of ns2__RadiativeTransitionProbabilityType* with length 0..unbounded
    std::vector<ns2__RadiativeTransitionProbabilityType*> Probability                    0;
};

/// "urn:poc":RadiativeTransitionProbabilityType is a complexType with complexContent extension of "":PrimaryType.
/// @brief spontaneous transition probability, or Einstein coefficient
/// class ns2__RadiativeTransitionProbabilityType operations:
/// - soap_new_ns2__RadiativeTransitionProbabilityType(soap*) allocate
/// - soap_new_ns2__RadiativeTransitionProbabilityType(soap*, int num) allocate array
/// - soap_new_req_ns2__RadiativeTransitionProbabilityType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RadiativeTransitionProbabilityType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RadiativeTransitionProbabilityType(soap*, ns2__RadiativeTransitionProbabilityType*) deserialize from a stream
/// - int soap_write_ns2__RadiativeTransitionProbabilityType(soap, ns2__RadiativeTransitionProbabilityType*) serialize to a stream
class ns2__RadiativeTransitionProbabilityType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Transition probability (Einstein coefficient)
/// Element TransitionProbabilityA of type "":DataType.
    ns2__DataType*                       TransitionProbabilityA         0;	///< Optional element.
/// @brief Oscillator strength
/// Element OscillatorStrength of type "":DataType.
    ns2__DataType*                       OscillatorStrength             0;	///< Optional element.
/// @brief Line strength
/// Element LineStrength of type "":DataType.
    ns2__DataType*                       LineStrength                   0;	///< Optional element.
/// @brief Weighted oscillator strength
/// Element WeightedOscillatorStrength of type "":DataType.
    ns2__DataType*                       WeightedOscillatorStrength     0;	///< Optional element.
/// @brief Log10 of the weighted oscillator strength
/// Element Log10WeightedOscillatorStrength of type "":DataType.
    ns2__DataType*                       Log10WeightedOscillatorStrength 0;	///< Optional element.
/// @brief Line intensity for some specific conditions.
/// Element IdealisedIntensity of type "":DataType.
    ns2__DataType*                       IdealisedIntensity             0;	///< Optional element.
/// @brief Transition multipole type. Example: E2
/// Element Multipole of type "":MultipoleType.
    ns2__MultipoleType*                  Multipole                      0;	///< Optional element.
};

/// "urn:poc":WavelengthWavenumberType is a complexType with complexContent extension of "":PrimaryType.
/// @brief Complex type for observed, Ritz, or calculated wavelengths/wavenumbers.
/// class ns2__WavelengthWavenumberType operations:
/// - soap_new_ns2__WavelengthWavenumberType(soap*) allocate
/// - soap_new_ns2__WavelengthWavenumberType(soap*, int num) allocate array
/// - soap_new_req_ns2__WavelengthWavenumberType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__WavelengthWavenumberType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__WavelengthWavenumberType(soap*, ns2__WavelengthWavenumberType*) deserialize from a stream
/// - int soap_write_ns2__WavelengthWavenumberType(soap, ns2__WavelengthWavenumberType*) serialize to a stream
class ns2__WavelengthWavenumberType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Calculated from the difference of experimental energy levels
/// Element Ritz of type "":DataType.
    ns2__DataType*                       Ritz                           0;	///< Optional element.
/// @brief Experimentally measured
/// Element Experimental of type "":DataType.
    ns2__DataType*                       Experimental                   0;	///< Optional element.
/// @brief Calculated (theory)
/// Element Theoretical of type "":DataType.
    ns2__DataType*                       Theoretical                    0;	///< Optional element.
};

/// "urn:poc":EnergyWavelengthType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__EnergyWavelengthType operations:
/// - soap_new_ns2__EnergyWavelengthType(soap*) allocate
/// - soap_new_ns2__EnergyWavelengthType(soap*, int num) allocate array
/// - soap_new_req_ns2__EnergyWavelengthType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__EnergyWavelengthType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__EnergyWavelengthType(soap*, ns2__EnergyWavelengthType*) deserialize from a stream
/// - int soap_write_ns2__EnergyWavelengthType(soap, ns2__EnergyWavelengthType*) serialize to a stream
class ns2__EnergyWavelengthType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Transition wavenumber
/// Element Wavenumber of type "":WavelengthWavenumberType.
    ns2__WavelengthWavenumberType*       Wavenumber                     0;	///< Optional element.
/// @brief Transition wavelength
/// Element Wavelength of type "":WavelengthWavenumberType.
    ns2__WavelengthWavenumberType*       Wavelength                     0;	///< Optional element.
/// @brief Transition energy
/// Element Energy of type "":WavelengthWavenumberType.
    ns2__WavelengthWavenumberType*       Energy                         0;	///< Optional element.
/// @brief Transition frequency
/// Element Frequency of type "":WavelengthWavenumberType.
    ns2__WavelengthWavenumberType*       Frequency                      0;	///< Optional element.
};

/// "urn:poc":NonRadiativeType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__NonRadiativeType operations:
/// - soap_new_ns2__NonRadiativeType(soap*) allocate
/// - soap_new_ns2__NonRadiativeType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonRadiativeType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonRadiativeType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonRadiativeType(soap*, ns2__NonRadiativeType*) deserialize from a stream
/// - int soap_write_ns2__NonRadiativeType(soap, ns2__NonRadiativeType*) serialize to a stream
class ns2__NonRadiativeType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// Vector of ns2__NonRadiativeTransitionType* with length 1..unbounded
    std::vector<ns2__NonRadiativeTransitionType*> NonRadiativeTransition         1;
};

/// "urn:poc":NonRadiativeTransitionType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__NonRadiativeTransitionType operations:
/// - soap_new_ns2__NonRadiativeTransitionType(soap*) allocate
/// - soap_new_ns2__NonRadiativeTransitionType(soap*, int num) allocate array
/// - soap_new_req_ns2__NonRadiativeTransitionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NonRadiativeTransitionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NonRadiativeTransitionType(soap*, ns2__NonRadiativeTransitionType*) deserialize from a stream
/// - int soap_write_ns2__NonRadiativeTransitionType(soap, ns2__NonRadiativeTransitionType*) serialize to a stream
class ns2__NonRadiativeTransitionType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Reference to the initial state
/// Element InitialStateRef of type "":StateRef.
    ns2__StateRef                        InitialStateRef                1;	///< Required element.
/// @brief Reference to the final state
/// Element FinalStateRef of type "":StateRef.
    ns2__StateRef*                       FinalStateRef                  0;	///< Optional element.
/// @brief Transition probability
/// Element Probability of type "":DataType.
    ns2__DataType*                       Probability                    1;	///< Required element.
/// @brief NonRadiative width
/// Element NonRadiativeWidth of type "":DataType.
    ns2__DataType*                       NonRadiativeWidth              0;	///< Optional element.
/// @brief Transition energy
/// Element TransitionEnergy of type "":DataType.
    ns2__DataType*                       TransitionEnergy               0;	///< Optional element.
/// @brief Description of the transition (e.g., Coster-Kronig)
/// Element Type of type xs:string.
    std::string*                         Type                           0;	///< Optional element.
};

/// "urn:poc":CollisionsType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__CollisionsType operations:
/// - soap_new_ns2__CollisionsType(soap*) allocate
/// - soap_new_ns2__CollisionsType(soap*, int num) allocate array
/// - soap_new_req_ns2__CollisionsType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__CollisionsType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__CollisionsType(soap*, ns2__CollisionsType*) deserialize from a stream
/// - int soap_write_ns2__CollisionsType(soap, ns2__CollisionsType*) serialize to a stream
class ns2__CollisionsType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief A specific collisional transition
/// Vector of ns2__CollisionalTransitionType* with length 1..unbounded
    std::vector<ns2__CollisionalTransitionType*> CollisionalTransition          1;
};

/// "urn:poc":CollisionalTransitionType is a complexType with complexContent extension of "":PrimaryType.
/// class ns2__CollisionalTransitionType operations:
/// - soap_new_ns2__CollisionalTransitionType(soap*) allocate
/// - soap_new_ns2__CollisionalTransitionType(soap*, int num) allocate array
/// - soap_new_req_ns2__CollisionalTransitionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__CollisionalTransitionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__CollisionalTransitionType(soap*, ns2__CollisionalTransitionType*) deserialize from a stream
/// - int soap_write_ns2__CollisionalTransitionType(soap, ns2__CollisionalTransitionType*) serialize to a stream
class ns2__CollisionalTransitionType : public ns2__PrimaryType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/// @brief Collisional process
/// Element ProcessClass of type "":CollisionalProcessClassType.
    ns2__CollisionalProcessClassType*    ProcessClass                   1;	///< Required element.
/// @brief List of reacting systems
/// Element Reactants of type "":ReactantsType.
    ns2__ReactantsType*                  Reactants                      1;	///< Required element.
/// @brief List of intermediate state
/// Element IntermediateStates of type "":ProductsType.
    ns2__ProductsType*                   IntermediateStates             0;	///< Optional element.
/// @brief List of final states
/// Element Products of type "":ProductsType.
    ns2__ProductsType*                   Products                       0;	///< Optional element.
/// @brief Reaction threshold
/// Element Threshold of type "":DataType.
    ns2__DataType*                       Threshold                      0;	///< Optional element.
/// Element DataSets of type "":DataSetsType.
    ns2__DataSetsType*                   DataSets                       1;	///< Required element.
};

/// "urn:poc":StateEnergyType is a complexType with complexContent extension of "":DataType.
/// class ns2__StateEnergyType operations:
/// - soap_new_ns2__StateEnergyType(soap*) allocate
/// - soap_new_ns2__StateEnergyType(soap*, int num) allocate array
/// - soap_new_req_ns2__StateEnergyType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__StateEnergyType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__StateEnergyType(soap*, ns2__StateEnergyType*) deserialize from a stream
/// - int soap_write_ns2__StateEnergyType(soap, ns2__StateEnergyType*) serialize to a stream
class ns2__StateEnergyType : public ns2__DataType
{ public:
/*  INHERITED FROM ns2__PrimaryType:
/// @brief Arbitrary comments
/// Element Comments of type xs:string.
    std::string*                         Comments                       0;	///< Optional element.
/// Attribute reference "":sourceRef.
/// @brief Reference to specific bibliographic items.
   @_ns2__sourceRef*                     sourceRef                      0;	///< Optional attribute.
/// Attribute reference "":methodRef.
/// @brief Reference to a specific method.
   @_ns2__methodRef*                     methodRef                      0;	///< Optional attribute.
    END OF INHERITED FROM ns2__PrimaryType */
/*  INHERITED FROM ns2__DataType:
/// @brief Value of a particular quantity
/// Element Value of type "":ValueType.
    ns2__ValueType*                      Value                          1;	///< Required element.
/// @brief Description of the accuracy
/// Element Accuracy of type xs:string.
    std::string*                         Accuracy                       0;	///< Optional element.
    END OF INHERITED FROM ns2__DataType */
/// Attribute energyOrigin of type xs:string.
   @std::string                          energyOrigin                   1;	///< Required attribute.
};

/// "urn:poc":TotalSpinMomentumSType is a complexType with simpleContent.
/// class ns2__TotalSpinMomentumSType operations:
/// - soap_new_ns2__TotalSpinMomentumSType(soap*) allocate
/// - soap_new_ns2__TotalSpinMomentumSType(soap*, int num) allocate array
/// - soap_new_req_ns2__TotalSpinMomentumSType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__TotalSpinMomentumSType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__TotalSpinMomentumSType(soap*, ns2__TotalSpinMomentumSType*) deserialize from a stream
/// - int soap_write_ns2__TotalSpinMomentumSType(soap, ns2__TotalSpinMomentumSType*) serialize to a stream
class ns2__TotalSpinMomentumSType
{ public:
/// __item wraps '"":AngularMomentumType' simpleContent.
    ns2__AngularMomentumType             __item                        ;
/// Attribute electronicSpinId of type xs:ID.
   @xsd__ID*                             electronicSpinId               0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "urn:poc":Sources of type "":SourcesType.
/// @brief All relevant references to data sources
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Methods of type "":MethodsType.
/// @brief List of methods used to produce the data
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Functions of type "":FunctionsType.
/// @brief List of functions used for data description and/or presentation (e.g., fitting)
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Atoms of type "":AtomsType.
/// @brief Atoms or atomic ions
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Particles of type "":ParticlesType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Solids of type "":SolidsType.
/// @brief Solids, surfaces, etc.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Radiative of type "":RadiativeType.
/// @brief Radiative transitions (both emission and absorption)
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":NonRadiative of type "":NonRadiativeType.
/// @brief List of autoionization and predissociation transitions
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":Collisions of type "":CollisionsType.
/// @brief List of collisional processes
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "urn:poc":XSAMSData of type "":XSAMSDataType.
/// @brief XML schema for description of atomic, molecular, and particle-solid-interaction processes
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   urn:poc                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Services                                                                   *
 *                                                                            *
\******************************************************************************/


//gsoap ns2  service name:	poc 
//gsoap ns2  service type:	pocPortType 
//gsoap ns2  service port:	http://physics.muni.cz/~adamobrusnik/ws/poc.cgi 
//gsoap ns2  service namespace:	urn:poc 
//gsoap ns2  service transport:	http://schemas.xmlsoap.org/soap/http 

/** @mainpage poc Definitions

@section poc_bindings Service Bindings

  - @ref poc

@section poc_more More Information

  - @ref page_notes "Usage Notes"

  - @ref page_XMLDataBinding "XML Data Binding"

  - @ref SOAP_ENV__Header "SOAP Header Content" (when applicable)

  - @ref SOAP_ENV__Detail "SOAP Fault Detail Content" (when applicable)


*/

/**

@page poc Binding "poc"

@section poc_service Service Documentation "poc"
Proof of concept service

@section poc_operations Operations of Binding  "poc"

  - @ref ns2__getS

@section poc_ports Endpoints of Binding  "poc"

  - http://physics.muni.cz/~adamobrusnik/ws/poc.cgi

Note: use wsdl2h option -Nname to change the service binding prefix name


*/

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   poc                                                                      *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   ns2__getS                                                                *
 *                                                                            *
\******************************************************************************/


/// Operation "ns2__getS" of service binding "poc"

/**

Operation details:
Service definition of function ns__getS

  - http://schemas.xmlsoap.org/soap/encoding/ RPC encodingStyle="SOAP"

  - Addressing input action: ""

  - Addressing output action: "Response"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call_ns2__getS(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    std::string                         species1,
    std::string                         species2,
    unsigned int                        s,
    double                              x0,
    double                              Tmin,
    double                              Tmax,
    double                              Npoints,
    bool                                logaritmic,
    // output parameters:
    double                             &dat
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int ns2__getS(
    struct soap *soap,
    // input parameters:
    std::string                         species1,
    std::string                         species2,
    unsigned int                        s,
    double                              x0,
    double                              Tmin,
    double                              Tmax,
    double                              Npoints,
    bool                                logaritmic,
    // output parameters:
    double                             &dat
  );
@endcode

C++ proxy class (defined in soappocProxy.h):
@code
  class pocProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soappocService.h):
@code
  class pocService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns2  service method-protocol:	getS SOAP
//gsoap ns2  service method-style:	getS rpc
//gsoap ns2  service method-encoding:	getS http://schemas.xmlsoap.org/soap/encoding/
//gsoap ns2  service method-action:	getS ""
//gsoap ns2  service method-output-action:	getS Response
int ns2__getS(
    std::string                         species1,	///< Input parameter
    std::string                         species2,	///< Input parameter
    unsigned int                        s,	///< Input parameter
    double                              x0,	///< Input parameter
    double                              Tmin,	///< Input parameter
    double                              Tmax,	///< Input parameter
    double                              Npoints,	///< Input parameter
    bool                                logaritmic,	///< Input parameter
    double                             &dat	///< Output parameter
);

/**

@page poc Binding "poc"

@section poc_policy_enablers Policy Enablers of Binding  "poc"

Based on policies, this service imports

  - WS-Policy reminders and enablers:
    - WS-Addressing 1.0 (2005/08, accepts 2004/08):
	@code
	#import "wsa5.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsaapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	// See the user guide gsoap/doc/wsa/html/index.html
	@endcode
    - WS-Addressing (2004/08):
	@code
	#import "wsa.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsaapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	// See the user guide gsoap/doc/wsa/html/index.html
	@endcode
    - WS-ReliableMessaging 1.0:
	@code
	#import "wsrm5.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsrmapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	soap_register_plugin(soap, soap_wsrm); // register the wsrm plugin in your code
	// See the user guide gsoap/doc/wsrm/html/index.html
	@endcode
    - WS-ReliableMessaging 1.1:
	@code
	#import "wsrm.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsrmapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	soap_register_plugin(soap, soap_wsrm); // register the wsrm plugin in your code
	// See the user guide gsoap/doc/wsrm/html/index.html
	@endcode
    - WS-Security (SOAP Message Security) 1.0 (accepts 1.1):
	@code
	#import "wsse.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsseapi.h"
	soap_register_plugin(soap, soap_wsse); // register the wsse plugin in your code
	// See the user guide gsoap/doc/wsse/html/index.html
	@endcode
    - WS-Security (SOAP Message Security) 1.1 (accepts 1.0):
	@code
	#import "wsse11.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsseapi.h"
	soap_register_plugin(soap, soap_wsse); // register the wsse plugin in your code
	// See the user guide gsoap/doc/wsse/html/index.html
	@endcode
    - HTTP Digest Authentication:
	@code
	#include "plugin/httpda.h"
	soap_register_plugin(soap, soap_http_da); // register the HTTP DA plugin in your code
	// See the user guide gsoap/doc/httpda/html/index.html
	@endcode
*/


/******************************************************************************\
 *                                                                            *
 * XML Data Binding                                                           *
 *                                                                            *
\******************************************************************************/


/**

@page page_XMLDataBinding XML Data Binding

SOAP/XML services use data bindings contractually bound by WSDL and auto-
generated by wsdl2h and soapcpp2 (see Service Bindings). Plain data bindings
are adopted from XML schemas as part of the WSDL types section or when running
wsdl2h on a set of schemas to produce non-SOAP-based XML data bindings.

The following readers and writers are C/C++ data type (de)serializers auto-
generated by wsdl2h and soapcpp2. Run soapcpp2 on this file to generate the
(de)serialization code, which is stored in soapC.c[pp]. Include "soapH.h" in
your code to import these data type and function declarations. Only use the
soapcpp2-generated files in your project build. Do not include the wsdl2h-
generated .h file in your code.

Data can be read in XML and deserialized from:
  - a file descriptor, using soap->recvfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->is = ...
  - a buffer, using the soap->frecv() callback

Data can be serialized in XML and written to:
  - a file descriptor, using soap->sendfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->os = ...
  - a buffer, using the soap->fsend() callback

The following options are available for (de)serialization control:
  - soap->encodingStyle = NULL; to remove SOAP 1.1/1.2 encodingStyle
  - soap_mode(soap, SOAP_XML_TREE); XML without id-ref (no cycles!)
  - soap_mode(soap, SOAP_XML_GRAPH); XML with id-ref (including cycles)
  - soap_set_namespaces(soap, struct Namespace *nsmap); to set xmlns bindings


@section ns2 Top-level root elements of schema "urn:poc"

@section ns2 Top-level root elements of schema "urn:poc"

  - <ns2:Sources> (use wsdl2h option -g to auto-generate)

  - <ns2:Methods> (use wsdl2h option -g to auto-generate)

  - <ns2:Functions> (use wsdl2h option -g to auto-generate)

  - <ns2:Atoms> (use wsdl2h option -g to auto-generate)

  - <ns2:Particles> (use wsdl2h option -g to auto-generate)

  - <ns2:Solids> (use wsdl2h option -g to auto-generate)

  - <ns2:Radiative> (use wsdl2h option -g to auto-generate)

  - <ns2:NonRadiative> (use wsdl2h option -g to auto-generate)

  - <ns2:Collisions> (use wsdl2h option -g to auto-generate)

  - <ns2:XSAMSData> (use wsdl2h option -g to auto-generate)

*/

/* End of poc.h */
